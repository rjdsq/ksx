
<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>
			GitHub仓库管理器
		</title>
		<link rel="stylesheet" href="./vid/style.css">
		<link rel="stylesheet" href="./vid/文件图标.css">
		<link rel="stylesheet" href="./vid/主菜单.css">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
		
	</head>
	<style>



	</style>
	<body>
		<!-- 认证页面 -->
		
		<div id="authScreen">
		
			<div class="auth-header">
			
				<i class="fa fa-github"></i>
			
				<h1>
					GitHub仓库管理器
				</h1>
				<p>
					全方面的仓库管理工具
				</p>
			</div>
			
			
<div class="login-container">
    <div class="auth-form">
        <input type="text" id="tokenInput" placeholder="输入GitHub访问令牌">
        
        <div class="auth-buttons-container">
            <button class="auth-button" id="getTokenBtn">
                <span >复制链接</span>
                
            </button>
            <button id="authBtn"><span>登录</span><i class="fa fa-spinner fa-spin hidden"></i></button>
        </div>
    </div>

    <div class="token-instructions">
        <h4><i class="fa fa-key"></i> 令牌获取指南</h4>
        <ol>
            <li>点击上方的 <strong>“复制链接”</strong>点击按钮“复制官网链接”，即可直达令牌生成界面；若按钮操作失败，可手动复制以下链接前往：https://github.com/settings/tokens/new </li>
            <li>在浏览器中粘贴链接并登录账号 (新用户需注册)。
                <small>如果注册登录后未跳转到令牌生成页，请重新粘贴一次链接直达token生成界面。</small>
            </li>
            <li>进入令牌(Token)设置页面后，按以下步骤操作：
                <ul>
                    <li><strong>勾选：</strong>下滑页面，勾选所有权限选框。</li>
                    <li><strong>效期：</strong>选择一个合适的有效期。</li>
                    <li><strong>生成：</strong>点击页面底部的绿色按钮生成令牌。</li>
                </ul>
            </li>
            <li><strong>复制</strong> 生成的新令牌(Token)。</li>
            <li>返回本页面，将令牌粘贴到输入框内完成登录。</li>
        </ol>
        <p class="instructions-note">
            <i class="fa fa-fighter-jet"></i>
            提示：如果GitHub网站无法访问，请尝试使用小飞机
        </p>
    </div>
</div>

		

		</div>
		<!-- 提示消息框 -->
			<div id="toast" class="hidden">
				<span id="toastMessage">
				</span>
			</div>
		<!-- 主应用容器 -->
		<div id="app" class="hidden">
			<!-- 头部栏 -->
			<header>
				<div class="header-left">
					<i id="headerGithubIcon" class="fa fa-github" title="查看API状态"></i>
					<h1 id="currentRepo">
						选择仓库
					</h1>
					<div id="branchSwitcherContainer" class="hidden">
					</div>
					<div id="pathNav">
					</div>
					<div id="pathNavContainer">
					</div>
				</div>
				<div class="header-right">
					<button id="mainMenuBtn" title="菜单">
						<i class="fa fa-cog">
						</i>
					</button>
				</div>
			</header>
			<!-- 主内容区 -->
			<main>
				<!-- 全局加载动画 -->
				<div id="mainLoader" class="loading-overlay hidden">
					<div class="spinner">
					</div>
				</div>
				<!-- 文件工具栏 -->
				<div id="toolbar" class="hidden">
					<div class="toolbar-left">
						<input id="searchInput" placeholder="搜索文件/文件夹..." class="hidden">
					</div>
					<button id="searchToggleBtn" class="btn-icon" title="搜索">
						<i class="fa fa-search">
						</i>
					</button>
					<button id="proxyQuickToggle" title="代理状态">
						<i class="fa fa-power-off">
						</i>
					</button>
					<div class="toolbar-right">
						<div class="custom-select-container">
							<button id="sortToggleBtn" class="btn-icon" title="排序">
								<i class="fa fa-sort-alpha-asc">
								</i>
							</button>
							<!-- 排序下拉菜单 -->
							<div id="customSortDropdown" class="hidden custom-dropdown">      
							<div class="dropdown-item" data-priority="dirs_first">
									<i class="fa fa-folder-o">
									</i>
									文件夹优先
								</div>
								<div class="dropdown-item" data-priority="files_first">
									<i class="fa fa-file-o">
									</i>
									文件优先
								</div>
								
								<div class="dropdown-divider">
								</div>
								<div class="dropdown-item" data-value="name_asc">
									名称 A→Z
								</div>
								<div class="dropdown-item" data-value="name_desc">
									名称 Z→A
								</div>
								<div class="dropdown-item" data-value="type_name_asc">
									类型 A→Z
								</div>
								<div class="dropdown-item" data-value="type_time_desc">
									类型 新→旧
								</div>
								<div class="dropdown-item" data-value="time_desc">
									时间 新→旧
								</div>
								<div class="dropdown-item" data-value="time_asc">
									时间 旧→新
								</div>
								
								<div class="dropdown-item" data-value="size_desc">
									大小 大→小
								</div>
								<div class="dropdown-item" data-value="size_asc">
									大小 小→大
								</div>
							</div>
						</div>
						<button id="multiSelectToggleBtn" class="btn-icon" title="多项选择">
							<i class="fa fa-check-circle-o">
							</i>
						</button>
						<button id="viewToggleBtn" title="切换视图">
							<i class="fa fa-th-large">
							</i>
						</button>
					</div>
				</div>
				<!-- 仓库列表 -->
				<div id="repoList">
					<div class="loading-spinner">
						<div class="spinner">
						</div>
					</div>
				</div>
				<!-- 文件列表 -->
				<div id="fileList" class="hidden">
					<div class="loading-spinner">
						<div class="spinner">
						</div>
					</div>
				</div>
			</main>
			<!-- 重命名弹窗 -->
			<div id="renameModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3 id="renameTitle">
						<span class="modal-title-text">
							重命名
						</span>
						<button class="btn-icon-sm" onclick="hideRenameModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input type="text" id="renameInput" value="" autocomplete="off">
					<div id="renameWarn" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;">
					</div>
					<div class="modal-buttons">
						<button id="renameCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="renameConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			<!-- 删除确认弹窗 -->
			<div id="deleteModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3 id="deleteTitle">
						<span class="modal-title-text">
							确认删除
						</span>
						<button class="btn-icon-sm" onclick="hideDeleteModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<p id="deleteDesc">
					</p>
					<div class="modal-buttons">
						<button id="deleteCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="deleteConfirm" class="btn btn-danger">
							确认删除
						</button>
					</div>
				</div>
			</div>
			<!-- 文件编辑弹窗 -->
			<div id="editModal" class="hidden">
				<div class="modal-content">
					<div class="modal-header">
						<h5 id="editFileName">
							编辑文件
						</h5>
						<div style="display:flex; gap:2rem;">
   
    <button id="revertEditBtn" title="撤销修改" disabled>
        <i class="fa fa-undo">
        </i>
    </button>
    

    <button id="toggleMaximizeModal" title="最大化">
        <i class="fa fa-expand">
        </i>
    </button>
    <button id="closeEditModal">
        <i class="fa fa-times">
        </i>
    </button>
</div>
					</div>
					<div id="editStatus">
					</div>
					<div class="editor-container">
						<div id="editorOverlay">
							<div class="spinner-container">
								<i class="fa fa-spinner fa-spin">
								</i>
							</div>
						</div>
						<div id="saveNotification">
							<i class="fa fa-check">
							</i>
							保存成功
						</div>
						<textarea id="fileContent">
						</textarea>
					</div>
					<div class="modal-footer">
						<button id="cancelEdit">
							取消
						</button>
						<button id="saveEdit">
							保存修改
						</button>
					</div>
				</div>
			</div>
			<!-- 通用模态框遮罩层 -->
			<div id="modalOverlay" class="hidden">
				<div class="modal-content">
					<div id="modalContent">
					</div>
				</div>
			</div>
			<!-- 右键/长按菜单 -->
			<div id="contextMenu" class="hidden">
				<div id="contextMenuItems">
				</div>
			</div>
			
			<!-- 隐藏的文件上传输入框 -->
			<input type="file" id="fileUploadInput" multiple class="hidden">
			<!-- 主菜单弹窗 -->
			<div id="mainMenuPopup" class="hidden">
    <div class="user-profile-header">
        <!-- 用户头像容器 -->
        <div id="avatarContainer" title="点击更换头像">
            <i id="userAvatarPlaceholder" class="fa fa-github"></i>
            <img id="userAvatar" src="" alt="User Avatar" class="fa fa-github hidden">
        </div>
        <span id="userName">
            name
        </span>
    </div>
    
				<div class="menu-items-container">
					
					<button id="menuProxySettings">
						<i class="fa fa-fighter-jet">
						</i>
						代理设置
					</button>
					<button id="menuContextMenuSettings">
    <i class="fa fa-hand-pointer-o"></i>
    菜单设置
</button>
					
					<button id="menuClearCache">
						<i class="fa fa-trash">
						</i>
						清除缓存
					</button>
					<button id="menuLogout">
						<i class="fa fa-sign-out">
						</i>
						退出登录
					</button>
				</div>
			</div>
			<!-- 底部操作栏 -->
			<footer>
				<button id="backBtn" title="返回上级">
					<i class="fa fa-arrow-up">
					</i>
				</button>
				<button id="newFolderBtn" title="新建仓库">
					<i class="fa fa-plus">
					</i>
				</button>
				<button id="newFileBtn" title="新建文件">
					<i class="fa fa-file-o">
					</i>
				</button>
				<button id="uploadBtn" title="上传文件">
					<i class="fa fa-upload">
					</i>
				</button>
			</footer>
			<!-- 媒体文件预览容器 -->
			<div id="mediaPreview" class="hidden">
				<img id="mediaPreviewImg" style="display:none;" alt="预览图片">
				<video id="mediaPreviewVideo" style="display:none;" controls>
				</video>
			</div>
			<!-- 新建仓库弹窗 -->
			<div id="createRepoModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建仓库
						</span>
						<button class="btn-icon-sm" onclick="hideCreateRepoModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createRepoNameInput" placeholder="输入仓库名称（仅支持英文、数字、连字符）">
					<div id="repoNameError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;">
					</div>
					<textarea id="createRepoDescInput" placeholder="仓库描述（可选）">
					</textarea>
					<div class="checkbox-container">
						<input type="checkbox" id="createRepoPrivate">
						<label for="createRepoPrivate">
							公开仓库
						</label>
					</div>
					<div class="modal-buttons">
						<button id="createRepoCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createRepoConfirm" class="btn btn-primary" disabled>
							创建仓库
						</button>
					</div>
				</div>
			</div>
			<!-- 新建文件夹弹窗 -->
			<div id="createFolderModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建文件夹
						</span>
						<button class="btn-icon-sm" onclick="hideCreateFolderModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createFolderInput" placeholder="输入文件夹名称">
					<div class="modal-buttons">
						<button id="createFolderCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createFolderConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			<!-- 新建文件弹窗 -->
			<div id="createFileModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建文件
						</span>
						<button class="btn-icon-sm" onclick="hideCreateFileModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createFileNameInput" placeholder="输入文件名，如 example.txt">
					<textarea id="createFileContentInput" placeholder="文件内容（可选）">
					</textarea>
					<div class="modal-buttons">
						<button id="createFileCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createFileConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			<!-- 新建分支弹窗 -->
			<div id="createBranchModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建分支
						</span>
						<button class="btn-icon-sm" onclick="hideCreateBranchModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<div class="form-group">
						<label for="createBranchNameInput">
							新分支名称:
						</label>
						<input id="createBranchNameInput" placeholder="输入新分支名称">
					</div>
					<div class="form-group">
						<label>
							基于分支:
						</label>
						<div class="branch-select-container">
							<div id="sourceBranchSelector" class="custom-branch-select-wrapper">
								<button class="custom-branch-select-trigger">
									<span>
									</span>
									<i class="fa fa-chevron-down">
									</i>
									
								</button>
								<div class="custom-branch-select-options">
								</div>
							</div>
							<button id="renameBranchBtn" class="btn-icon" title="重命名所选分支">
								<i class="fa fa-pencil">
								</i>
							</button>
							<button id="deleteBranchBtn" class="btn-icon danger" title="删除所选分支">
								<i class="fa fa-trash">
								</i>
							</button>
						</div>
					</div>
					<div class="modal-buttons">
						<button id="createBranchCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createBranchConfirm" class="btn btn-primary" disabled>
							创建分支
						</button>
					</div>
				</div>
			</div>
		</div>
		<div class="modal-buttons hidden">
			<button id="createBranchCancel" class="btn btn-cancel">
				取消
			</button>
			<button id="createBranchConfirm" class="btn btn-primary" disabled>
				创建分支
			</button>
		</div>
		</div>
		</div>
		<!-- 文件上传面板 -->
		<div id="uploadPanel" class="hidden">
			<div id="uploadItems" class="scmz">
			</div>
		</div>
		<!-- 代理设置弹窗 -->
<div id="proxySettingsModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <!-- 弹窗头部 -->
        <h3>
            <span class="modal-title-text">代理设置</span>
            <div class="proxy-header-actions">
                <label class="switch" title="点击切换全局代理状态">
                    <input type="checkbox" id="proxyGlobalEnableToggle">
                    <span class="slider round"></span>
                </label>
                <button id="proxyCancelSettingsBtn" class="btn-icon-sm" title="关闭设置">
                    <i class="fa fa-times"></i>
                </button>
            </div>
        </h3>

        <!-- 代理列表区域 -->
        <div class="proxy-list-container" id="proxyListContainer">
            <div class="empty-state hidden" id="proxyListEmpty">
                <i class="fa fa-plug"></i>
                <p>暂无代理节点</p>
                <span>点击右下角的 <i class="fa fa-plus-circle"></i> 添加，或从工具栏 <i class="fa fa-cloud-download"></i> 导入</span>
            </div>
            <!-- 代理项动态生成 -->
        </div>

        <!-- 底部操作区 -->
        <div class="proxy-footer-actions">
            <div class="proxy-footer-toolbar">
                <button id="importBtn" class="btn-icon" title="从订阅链接导入并刷新">
                    <i class="fa fa-cloud-download"></i>
                </button>
                <button id="proxyTestAllBtn" class="btn-icon" title="全部测试延迟">
                    <i class="fa fa-flash"></i>
                    <span class="spinner-small hidden" id="proxyTestAllSpinner"></span>
                </button>
                <button id="proxyAutoSelectToggle" class="btn-icon" title="点击切换自动选择最低延迟代理">
                    <i class="fa fa-magic"></i>
                </button>
                <button id="proxyClearAllBtn" class="btn-icon danger" title="清空所有代理">
                    <i class="fa fa-trash"></i>
                </button>
                <button id="proxyAddBtn" class="btn-icon" title="添加代理">
            <i class="fa fa-plus"></i>
        </button>
            </div>
            
            
        </div>
    </div>
</div>
		<!-- 添加/编辑代理弹窗 -->
<div id="addEditProxyModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3 id="addEditProxyTitle">
            <span class="modal-title-text">添加新代理</span>
            <button class="btn-icon-sm" onclick="closeAddEditProxyModal()" title="关闭">
                <i class="fa fa-times"></i>
            </button>
        </h3>

        <input id="addEditProxyUrlInput" type="url" placeholder="请输入代理域名或URL" autocomplete="off">
        
        <div id="addEditProxyError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;">
            
        </div>

      

        
        <div class="modal-buttons" style="margin-top:0.6rem;">
            <button id="addEditProxyCancelBtn" class="btn btn-cancel">取消</button>
            <button id="addEditProxySaveBtn" class="btn btn-primary" disabled>保存</button>
        </div>
    </div>
</div>
		<!-- 确认删除代理弹窗 -->
		<div id="confirmDeleteProxyModal" class="modal-overlay hidden">
			<div class="modal-form-container">
				<h3 id="confirmDeleteProxyTitle">
					<span class="modal-title-text">
						确认删除
					</span>
					<button class="btn-icon-sm" onclick="hideConfirmDeleteProxyModal()" title="取消">
						<i class="fa fa-times">
						</i>
					</button>
				</h3>
				<p id="confirmDeleteProxyMessage">
				</p>
				<div class="modal-buttons">
					<button id="confirmDeleteProxyCancelBtn" class="btn btn-cancel">
						取消
					</button>
					<button id="confirmDeleteProxyConfirmBtn" class="btn btn-danger">
						确认删除
					</button>
				</div>
			</div>
		</div>
		<!-- 确认清空代理弹窗 -->
		<div id="confirmClearAllProxiesModal" class="modal-overlay hidden">
			<div class="modal-form-container">
				<h3>
					<span class="modal-title-text">
						确认清空所有代理
					</span>
					<button class="btn-icon-sm" onclick="hideConfirmClearAllProxiesModal()"
					title="取消">
						<i class="fa fa-times">
						</i>
					</button>
				</h3>
				<p>
					这将删除所有代理
				</p>
				<div class="modal-buttons">
					<button id="clearAllProxiesCancelBtn" class="btn btn-cancel">
						取消
					</button>
					<button id="clearAllProxiesConfirmBtn" class="btn btn-danger">
						确认清空
					</button>
				</div>
			</div>
		</div>
		</div>
		<!-- 多选操作栏 -->
		<div id="multi-select-bar">
			<button class="action-btn cancel-btn" id="cancel-select-btn" title="取消">
				<i class="fa fa-times">
				</i>
			</button>
			<div id="selected-count">
				未选择项目
			</div>
			<div class="action-buttons">
				<button class="action-btn delete-btn" id="delete-btn" title="删除" disabled>
					<i class="fa fa-trash-o">
					</i>
				</button>
				
				<button class="action-btn" id="download-btn" title="下载" disabled>
					<i class="fa fa-download">
					</i>
				</button>
				<button class="action-btn" id="invert-select-btn" title="反选" disabled>
					<i class="fa fa-check-square">
					</i>
				</button>
				<button class="action-btn" id="select-all-btn" title="全选">
					<i class="fa fa-check-square-o">
					</i>
				</button>
			</div>
		</div>
		<!-- API状态侧边栏 -->
<div id="apiStatusOverlay" class="api-status-overlay hidden"></div>
<div id="apiStatusPanel" class="api-status-panel">
    <div class.api-status-header">

    <!-- 头部操作按钮 -->
    <div class="api-status-header-actions">
        <h5>API 状态仪表盘</h5>
        <!-- 刷新按钮 -->
        <button id="refreshApiStatusBtn" class="btn-icon-sm" title="刷新">
            <i class="fa fa-refresh"></i>
        </button>
        <!-- 关闭按钮 -->
        <button id="closeApiStatusPanel" class="btn-icon-sm" title="关闭">
            <i class="fa fa-times"></i>
        </button>
    </div>
</div>
    <div id="apiStatusContent" class="api-status-content">
        <!-- 内容动态生成 -->
        <div class="loading-spinner" style="height: auto; padding: 2rem 0;">
            <div class="spinner"></div>
        </div>
    </div>
</div>
		<!-- 右键菜单设置弹窗 -->
<div id="contextMenuSettingsModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">长按菜单项设置</span>
            <button class="btn-icon-sm" id="contextMenuSettingsCloseBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p style="font-size:0.7rem; margin-top:-0.4rem; margin-bottom:0.4rem;">选择在长按时希望看到的快捷操作。</p>
        <div class="context-menu-settings-tabs">
        <button class="tab-btn  active" data-tab="file">文件</button>
        <button class="tab-btn" data-tab="folder">文件夹</button>
            <button class="tab-btn" data-tab="repo">仓库</button>
            
            
        </div>
        <div id="contextMenuSettingsContent">
            <!-- 设置项动态生成 -->
        </div>
    </div>
</div>
<!-- 隐藏的头像上传输入框 -->
    <input type="file" id="avatarUploadInput" class="hidden" accept="image/*">
    
    
    
<script>
const CURRENT_VERSION = "3.2";
document.documentElement.style.userSelect = 'none';
const toastQueue = [];
let isToastVisible = false;
const PROXY_TEST_URL = 'https://raw.githubusercontent.com/rjdsq/rjdsq.github.io/main/proxy/proxy.txt';
const IMAGE_EXTS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'];
const VIDEO_EXTS = ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'];
const AUDIO_EXTS = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];
const uiStateStack = [];

const state = {
    token: localStorage.getItem('gh_token') || null,
    localAvatar: null,
    currentRepo: null,
    currentPath: '',
    currentBranch: null,
    branches: [],
    files: [],
    displayFiles: [],
    repos: [],
    selectedFile: null,
    selectedRepo: null,
    uploadQueue: [],
    editingFile: null,
    fileSha: '',
    originalContent: '',
    proxies: JSON.parse(localStorage.getItem('proxies') || '[]'),
    activeProxyIndex: parseInt(localStorage.getItem('active_proxy_index') || '0'),
    proxyGlobalEnable: JSON.parse(localStorage.getItem('proxy_global_enable') || 'true'),
    autoSelectProxy: JSON.parse(localStorage.getItem('proxy_auto_select') || 'false'),
    editingProxyIndex: null,
    lastTestResult: null,
    lastTestUrl: null,
    user: null,
    fileCache: new Map(),
    viewMode: localStorage.getItem('view_mode') || 'list',
    sortBy: localStorage.getItem('sort_by') || 'name_asc',
    directorySortPriority: localStorage.getItem('directory_sort_priority') || 'dirs_first',
    searchQuery: '',
    isMultiSelectMode: false,
    selectedItems: new Set(),
    contextMenuVisibility: {}
};

if (state.proxies.length === 0) {
    state.activeProxyIndex = -1;
} else if (state.activeProxyIndex < 0 || state.activeProxyIndex >= state.proxies.length) {
    state.activeProxyIndex = 0;
}

const CONTEXT_MENU_DEFINITIONS = {
    repo: [{ action: 'setAsMainSite', icon: 'fa-home', text: '设为网站' },{ action: 'copyMainSiteLink', icon: 'fa-link', text: '网站链接' },{ action: 'copyRepoGitHubLink', icon: 'fa-link', text: '仓库链接' },{ action: 'renameRepo', icon: 'fa-pencil', text: '重命名' },{ action: 'createBranch', icon: 'fa-code-fork', text: '新建分支' },{ action: 'downloadRepoDirect', icon: 'fa-download', text: '下载 ZIP' },{ action: 'deleteRepo', icon: 'fa-trash', text: '删除', className: 'text-red-400' }],
    folder: [{ action: 'copyGitHubLink', icon: 'fa-external-link', text: '复制链接' },{ action: 'rename', icon: 'fa-pencil', text: '重命名' },{ action: 'downloadFolder', icon: 'fa-file-archive-o', text: '下载 ZIP' },{ action: 'delete', icon: 'fa-trash', text: '删除', className: 'text-red-400' }],
    file: [{ action: 'edit', icon: 'fa-edit', text: '编辑' },{ action: 'rename', icon: 'fa-pencil', text: '重命名' },{ action: 'download', icon: 'fa-download', text: '下载文件(代理)' },{ action: 'copyGitHubLink', icon: 'fa-share', text: '复制链接' },{ action: 'copyLink', icon: 'fa-link', text: '复制raw链接' },{ action: 'copyProxy', icon: 'fa-link', text: '复制代理链接' },{ action: 'delete', icon: 'fa-trash', text: '删除', className: 'text-red-400' }]
};

const DEFAULT_MENU_VISIBILITY = {
    repo: CONTEXT_MENU_DEFINITIONS.repo.reduce((acc, item) => ({ ...acc, [item.action]: true }), {}),
    folder: CONTEXT_MENU_DEFINITIONS.folder.reduce((acc, item) => ({ ...acc, [item.action]: true }), {}),
    file: CONTEXT_MENU_DEFINITIONS.file.reduce((acc, item) => ({ ...acc, [item.action]: true }), {})
};

const el = {
    authScreen: document.getElementById('authScreen'),
    app: document.getElementById('app'),
    tokenInput: document.getElementById('tokenInput'),
    authBtn: document.getElementById('authBtn'),
    fileList: document.getElementById('fileList'),
    repoList: document.getElementById('repoList'),
    pathNav: document.getElementById('pathNav'),
    pathNavContainer: document.getElementById('pathNavContainer'),
    currentRepo: document.getElementById('currentRepo'),
    branchSwitcherContainer: document.getElementById('branchSwitcherContainer'),
    backBtn: document.getElementById('backBtn'),
    newFolderBtn: document.getElementById('newFolderBtn'),
    uploadBtn: document.getElementById('uploadBtn'),
    modalOverlay: document.getElementById('modalOverlay'),
    modalContent: document.getElementById('modalContent'),
    contextMenu: document.getElementById('contextMenu'),
    contextMenuItems: document.getElementById('contextMenuItems'),
    toast: document.getElementById('toast'),
    toastMessage: document.getElementById('toastMessage'),
    uploadPanel: document.getElementById('uploadPanel'),
    uploadItems: document.getElementById('uploadItems'),
    editModal: document.getElementById('editModal'),
    editFileName: document.getElementById('editFileName'),
    fileContent: document.getElementById('fileContent'),
    closeEditModal: document.getElementById('closeEditModal'),
    cancelEdit: document.getElementById('cancelEdit'),
    saveEdit: document.getElementById('saveEdit'),
    editStatus: document.getElementById('editStatus'),
    editorOverlay: document.getElementById('editorOverlay'),
    saveNotification: document.getElementById('saveNotification'),
    fileUploadInput: document.getElementById('fileUploadInput'),
    mainLoader: document.getElementById('mainLoader'),
    mainMenuPopup: document.getElementById('mainMenuPopup'),
    menuLogout: document.getElementById('menuLogout'),
    menuProxySettings: document.getElementById('menuProxySettings'),
    menuClearCache: document.getElementById('menuClearCache'),
    newFileBtn: document.getElementById('newFileBtn'),
    mainMenuBtn: document.getElementById('mainMenuBtn'),
    toolbar: document.getElementById('toolbar'),
    searchInput: document.getElementById('searchInput'),
    viewToggleBtn: document.getElementById('viewToggleBtn'),
    proxyQuickToggle: document.getElementById('proxyQuickToggle'),
    proxySettingsModal: document.getElementById('proxySettingsModal'),
    proxyAutoSelectToggle: document.getElementById('proxyAutoSelectToggle'),
    userName: document.getElementById('userName'),
    importBtn: document.getElementById('importBtn'),
    proxyGlobalEnableToggle: document.getElementById('proxyGlobalEnableToggle'),
    proxyAddBtn: document.getElementById('proxyAddBtn'),
    proxyListContainer: document.getElementById('proxyListContainer'),
    proxyListEmpty: document.getElementById('proxyListEmpty'),
    proxyTestAllBtn: document.getElementById('proxyTestAllBtn'),
    proxyTestAllSpinner: document.getElementById('proxyTestAllSpinner'),
    proxyClearAllBtn: document.getElementById('proxyClearAllBtn'),
    proxyCancelSettingsBtn: document.getElementById('proxyCancelSettingsBtn'),
    addEditProxyModal: document.getElementById('addEditProxyModal'),
    addEditProxyTitle: document.getElementById('addEditProxyTitle'),
    addEditProxyUrlInput: document.getElementById('addEditProxyUrlInput'),
    addEditProxyError: document.getElementById('addEditProxyError'),
    addEditProxySaveBtn: document.getElementById('addEditProxySaveBtn'),
    confirmDeleteProxyModal: document.getElementById('confirmDeleteProxyModal'),
    confirmDeleteProxyTitle: document.getElementById('confirmDeleteProxyTitle'),
    confirmDeleteProxyMessage: document.getElementById('confirmDeleteProxyMessage'),
    confirmDeleteProxyCancelBtn: document.getElementById('confirmDeleteProxyCancelBtn'),
    confirmDeleteProxyConfirmBtn: document.getElementById('confirmDeleteProxyConfirmBtn'),
    confirmClearAllProxiesModal: document.getElementById('confirmClearAllProxiesModal'),
    clearAllProxiesCancelBtn: document.getElementById('clearAllProxiesCancelBtn'),
    clearAllProxiesConfirmBtn: document.getElementById('clearAllProxiesConfirmBtn'),
    renameModal: document.getElementById('renameModal'),
    renameTitle: document.getElementById('renameTitle'),
    renameInput: document.getElementById('renameInput'),
    renameWarn: document.getElementById('renameWarn'),
    renameCancel: document.getElementById('renameCancel'),
    renameConfirm: document.getElementById('renameConfirm'),
    renameBranchBtn: document.getElementById('renameBranchBtn'),
    deleteModal: document.getElementById('deleteModal'),
    deleteTitle: document.getElementById('deleteTitle'),
    deleteDesc: document.getElementById('deleteDesc'),
    deleteCancel: document.getElementById('deleteCancel'),
    deleteConfirm: document.getElementById('deleteConfirm'),
    createRepoModal: document.getElementById('createRepoModal'),
    createRepoNameInput: document.getElementById('createRepoNameInput'),
    createRepoDescInput: document.getElementById('createRepoDescInput'),
    createRepoPrivate: document.getElementById('createRepoPrivate'),
    repoNameError: document.getElementById('repoNameError'),
    createRepoCancel: document.getElementById('createRepoCancel'),
    createRepoConfirm: document.getElementById('createRepoConfirm'),
    createFolderModal: document.getElementById('createFolderModal'),
    createFolderInput: document.getElementById('createFolderInput'),
    createFolderCancel: document.getElementById('createFolderCancel'),
    createFolderConfirm: document.getElementById('createFolderConfirm'),
    createFileModal: document.getElementById('createFileModal'),
    createFileNameInput: document.getElementById('createFileNameInput'),
    createFileContentInput: document.getElementById('createFileContentInput'),
    createFileCancel: document.getElementById('createFileCancel'),
    createFileConfirm: document.getElementById('createFileConfirm'),
    createBranchModal: document.getElementById('createBranchModal'),
    createBranchNameInput: document.getElementById('createBranchNameInput'),
    createBranchCancel: document.getElementById('createBranchCancel'),
    createBranchConfirm: document.getElementById('createBranchConfirm'),
    deleteBranchBtn: document.getElementById('deleteBranchBtn'),
    searchToggleBtn: document.getElementById('searchToggleBtn'),
    sortToggleBtn: document.getElementById('sortToggleBtn'),
    customSortDropdown: document.getElementById('customSortDropdown'),
    avatarContainer: document.getElementById('avatarContainer'),
    avatarUploadInput: document.getElementById('avatarUploadInput'),
    userAvatar: document.getElementById('userAvatar'),
    userAvatarPlaceholder: document.getElementById('userAvatarPlaceholder'),
    multiSelectToggleBtn: document.getElementById('multiSelectToggleBtn'),
    multiSelectBar: document.getElementById('multi-select-bar'),
    cancelSelectBtn: document.getElementById('cancel-select-btn'),
    selectAllBtn: document.getElementById('select-all-btn'),
    invertSelectBtn: document.getElementById('invert-select-btn'),
    downloadBtn: document.getElementById('download-btn'),
    deleteBtn: document.getElementById('delete-btn'),
    selectedCountSpan: document.getElementById('selected-count'),
    menuContextMenuSettings: document.getElementById('menuContextMenuSettings'),
    contextMenuSettingsModal: document.getElementById('contextMenuSettingsModal'),
    contextMenuSettingsCloseBtn: document.getElementById('contextMenuSettingsCloseBtn'),
    contextMenuSettingsContent: document.getElementById('contextMenuSettingsContent'),
    headerGithubIcon: document.getElementById('headerGithubIcon'),
    apiStatusPanel: document.getElementById('apiStatusPanel'),
    apiStatusOverlay: document.getElementById('apiStatusOverlay'),
    apiStatusContent: document.getElementById('apiStatusContent'),
    closeApiStatusPanel: document.getElementById('closeApiStatusPanel'),
    refreshApiStatusBtn: document.getElementById('refreshApiStatusBtn'),
    revertEditBtn: document.getElementById('revertEditBtn')
};

function handleBackPress() {
    if (uiStateStack.length > 0) {
        const closeFunction = uiStateStack.pop();
        if (typeof closeFunction === 'function') {
            closeFunction();
        }
        history.pushState(history.state, '', window.location.href);
        return true;
    }
    return false;
}

function getFileIcon(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const icons = {
        js: 'fa-code', html: 'fa-html5', css: 'fa-css3', php: 'fa-file-code-o', py: 'fa-file-code-o',
        java: 'fa-file-code-o', rb: 'fa-file-code-o', cpp: 'fa-file-code-o', c: 'fa-file-code-o',
        cs: 'fa-file-code-o', swift: 'fa-file-code-o', go: 'fa-file-code-o', xml: 'fa-file-code-o',
        json: 'fa-file-code-o', yml: 'fa-file-code-o', yaml: 'fa-file-code-o', sql: 'fa-database',
        csv: 'fa-file-excel-o', ini: 'fa-cog', conf: 'fa-cog', log: 'fa-file-text-o',
        md: 'fa-file-text-o', txt: 'fa-file-text-o', rtf: 'fa-file-word-o', pdf: 'fa-file-pdf-o',
        doc: 'fa-file-word-o', docx: 'fa-file-word-o', xls: 'fa-file-excel-o', xlsx: 'fa-file-excel-o',
        ppt: 'fa-file-powerpoint-o', pptx: 'fa-file-powerpoint-o', png: 'fa-file-image-o',
        jpg: 'fa-file-image-o', jpeg: 'fa-file-image-o', gif: 'fa-file-image-o', svg: 'fa-file-image-o',
        bmp: 'fa-file-image-o', ico: 'fa-file-image-o', webp: 'fa-file-image-o', mp3: 'fa-file-audio-o',
        wav: 'fa-file-audio-o', ogg: 'fa-file-audio-o', flac: 'fa-file-audio-o', m4a: 'fa-file-audio-o',
        mp4: 'fa-file-video-o', webm: 'fa-file-video-o', mov: 'fa-file-video-o', mkv: 'fa-file-video-o',
        avi: 'fa-file-video-o', flv: 'fa-file-video-o', zip: 'fa-file-archive-o', rar: 'fa-file-archive-o',
        '7z': 'fa-file-archive-o', tar: 'fa-file-archive-o', gz: 'fa-file-archive-o', git: 'fa-git',
        apk: 'fa-android', exe: 'fa-cogs', dmg: 'fa-apple', ttf: 'fa-font', otf: 'fa-font',
        woff: 'fa-font', woff2: 'fa-font'
    };
    return icons[ext] || 'fa-file-o';
}

function formatSize(bytes) {
    if (!bytes && bytes !== 0) return '';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.max(0, Math.log(bytes || 1) / Math.log(k)));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatRelativeTime(date) {
    const diffMs = new Date() - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    if (diffMins < 1) return '刚刚';
    if (diffMins < 60) return `${diffMins}分钟前`;
    if (diffHours < 24) return `${diffHours}小时前`;
    if (diffDays < 30) return `${diffDays}天前`;
    return date.toLocaleDateString();
}

function escapeHtml(unsafe) {
    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;")
        .replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function getDomainFromUrl(url) {
    try {
        const urlObj = new URL(url.startsWith('http') ? url : `https://${url}`);
        return urlObj.hostname;
    } catch (e) {
        return '';
    }
}

function getProxiedUrl(originalUrl) {
    if (!state.proxyGlobalEnable || state.proxies.length === 0 || state.activeProxyIndex === -1) {
        return originalUrl;
    }
    const activeProxy = state.proxies[state.activeProxyIndex];
    if (!activeProxy || !activeProxy.url || activeProxy.status === 'fail' || !activeProxy.type) {
        return originalUrl;
    }
    const isRawGitHubUserContent = originalUrl.startsWith('https://raw.githubusercontent.com/');
    if (!isRawGitHubUserContent) {
        return originalUrl;
    }
    let proxiedUrl = originalUrl;
    const proxyInputUrl = (activeProxy.url || '').trim();
    const proxyDomain = getDomainFromUrl(proxyInputUrl);
    if (activeProxy.type === 'prefix') {
        let base = proxyInputUrl;
        if (!base.endsWith('/')) {
            base += '/';
        }
        proxiedUrl = base + originalUrl;
    } else if (activeProxy.type === 'raw_domain_replace') {
        proxiedUrl = originalUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
        if (!proxiedUrl.startsWith('http')) {
            proxiedUrl = 'https://' + proxiedUrl;
        }
    } else {
        proxiedUrl = originalUrl;
    }
    return proxiedUrl;
}

function applyFiltersAndSort() {
    let arr = Array.isArray(state.files) ? [...state.files] : [];
    const q = (state.searchQuery || '').toLowerCase();
    if (q) {
        arr = arr.filter(f => (f.name || '').toLowerCase().includes(q));
    }
    const getSortableExtension = (file) => {
        if (file.type === 'dir') return '!';
        const parts = file.name.split('.');
        if (parts.length > 1 && parts[0] !== '') {
            return parts.pop().toLowerCase();
        }
        return ' ';
    };
    const directorySorter = (a, b) => {
        if (a.type === b.type) return 0;
        if (state.directorySortPriority === 'files_first') {
            return a.type === 'file' ? -1 : 1;
        }
        return a.type === 'dir' ? -1 : 1;
    };
    const by = state.sortBy;
    const sorters = {
        name_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            return dirCompare !== 0 ? dirCompare : a.name.localeCompare(b.name);
        },
        name_desc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            return dirCompare !== 0 ? dirCompare : b.name.localeCompare(a.name);
        },
        time_desc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            const ta = a.last_modified ? +new Date(a.last_modified) : 0;
            const tb = b.last_modified ? +new Date(b.last_modified) : 0;
            return tb - ta;
        },
        time_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            const ta = a.last_modified ? +new Date(a.last_modified) : 0;
            const tb = b.last_modified ? +new Date(b.last_modified) : 0;
            return ta - tb;
        },
        size_desc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            return (b.size || 0) - (a.size || 0);
        },
        size_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            return (a.size || 0) - (b.size || 0);
        },
        type_name_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            const typeA = getSortableExtension(a);
            const typeB = getSortableExtension(b);
            if (typeA !== typeB) return typeA.localeCompare(typeB);
            return a.name.localeCompare(b.name);
        },
        type_time_desc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            const typeA = getSortableExtension(a);
            const typeB = getSortableExtension(b);
            if (typeA !== typeB) return typeA.localeCompare(typeB);
            const ta = a.last_modified ? +new Date(a.last_modified) : 0;
            const tb = b.last_modified ? +new Date(b.last_modified) : 0;
            return tb - ta;
        }
    };
    (sorters[by] || sorters.name_asc) && arr.sort(sorters[by]);
    state.displayFiles = arr;
}

function updateFileListViewMode() {
    if (!el.fileList) return;
    if (state.viewMode === 'grid') {
        el.fileList.classList.add('grid');
        el.viewToggleBtn && el.viewToggleBtn.classList.add('active');
        if (el.viewToggleBtn) {
            el.viewToggleBtn.title = '切换为列表视图';
            el.viewToggleBtn.innerHTML = '<i class="fa fa-align-justify"></i>';
        }
    } else {
        el.fileList.classList.remove('grid');
        el.viewToggleBtn && el.viewToggleBtn.classList.remove('active');
        if (el.viewToggleBtn) {
            el.viewToggleBtn.title = '切换为网格视图';
            el.viewToggleBtn.innerHTML = '<i class="fa fa-list"></i>';
        }
    }
}

function updateAllProxySwitchUI() {
    const isEnabled = !!state.proxyGlobalEnable;
    const currentProxy = state.proxies[state.activeProxyIndex];
    const title = isEnabled && currentProxy ? `代理已开启 (${currentProxy.url})` : '代理已关闭';
    if (el.proxyQuickToggle) {
        el.proxyQuickToggle.classList.toggle('active', isEnabled);
        el.proxyQuickToggle.title = title;
    }
    if (el.proxyGlobalEnableToggle) {
        el.proxyGlobalEnableToggle.checked = isEnabled;
        const label = el.proxyGlobalEnableToggle.parentElement;
        if (label) {
            label.title = isEnabled ? '点击关闭全局代理' : '点击开启全局代理';
        }
    }
}

function updateProxyUI() {
    updateAllProxySwitchUI();
}

async function setProxyGlobalState(isEnabled, shouldRefreshFiles = false) {
    if (state.proxyGlobalEnable === isEnabled) {
        return;
    }
    state.proxyGlobalEnable = isEnabled;
    localStorage.setItem('proxy_global_enable', JSON.stringify(isEnabled));
    updateAllProxySwitchUI();
    showToast(isEnabled ? '全局代理已开启' : '全局代理已关闭');
    if (shouldRefreshFiles && state.currentRepo && !el.fileList.classList.contains('hidden')) {
        el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
        await fetchFiles(true);
    }
}

function toggleView(showRepoList) {
    if (showRepoList) {
        el.repoList.classList.remove('hidden');
        el.fileList.classList.add('hidden');
        el.toolbar.classList.add('hidden');
        el.pathNavContainer.classList.add('hidden');
        el.branchSwitcherContainer.classList.add('hidden');
        el.currentRepo.textContent = '选择仓库';
        el.newFolderBtn.title = '新建仓库';
        el.newFolderBtn.innerHTML = '<i class="fa fa-plus"></i>';
    } else {
        el.repoList.classList.add('hidden');
        el.fileList.classList.remove('hidden');
        el.toolbar.classList.remove('hidden');
        el.pathNavContainer.classList.remove('hidden');
        el.branchSwitcherContainer.classList.remove('hidden');
        el.newFolderBtn.title = '新建文件夹';
        el.newFolderBtn.innerHTML = '<i class="fa fa-folder"></i>';
        updateFileListViewMode();
    }
}

function showAuth() {
    el.authScreen.classList.remove('hidden');
    el.app.classList.add('hidden');
}

function showApp() {
    el.authScreen.classList.add('hidden');
    el.app.classList.remove('hidden');
}

function showModal(content) {
    el.modalContent.innerHTML = content;
    el.modalOverlay.classList.remove('hidden');
    el.modalOverlay.classList.add('flex');
}

function hideModal() {
    el.modalOverlay.classList.add('hidden');
    el.modalOverlay.classList.remove('flex');
    el.modalContent.innerHTML = '';
}

function showToast(message) {
    toastQueue.push(message);
    processToastQueue();
}

function processToastQueue() {
    if (isToastVisible || toastQueue.length === 0) {
        return;
    }
    isToastVisible = true;
    const message = toastQueue.shift();
    el.toastMessage.innerHTML = message.replace(/\n/g, '<br>');
    el.toast.classList.remove('hidden');
    setTimeout(() => {
        el.toast.classList.add('hidden');
        isToastVisible = false;
        processToastQueue();
    }, 1888);
}

function showSaveNotification() {
    el.saveNotification.classList.add('show');
    setTimeout(() => el.saveNotification.classList.remove('show'), 3000);
}

async function fetchUserInfo() {
    try {
        const res = await fetch('https://api.github.com/user', {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (res.ok) {
            state.user = await res.json();
            updateUserUI();
        }
    } catch (e) {
        console.error("Failed to fetch user info", e);
    }
}

function updateUserUI() {
    if (state.localAvatar) {
        el.userAvatar.src = state.localAvatar;
        el.userAvatar.classList.remove('hidden');
        el.userAvatarPlaceholder.classList.add('hidden');
        el.userName.textContent = state.user ? state.user.login : 'User';
    }
    else if (state.user && state.user.avatar_url) {
        el.userName.textContent = state.user.login;
        el.userAvatar.src = state.user.avatar_url;
        el.userAvatar.classList.remove('hidden');
        el.userAvatarPlaceholder.classList.add('hidden');
    }
    else {
        el.userName.textContent = 'User';
        el.userAvatar.classList.add('hidden');
        el.userAvatarPlaceholder.classList.remove('hidden');
    }
}

async function fetchReposInBackground() {
    try {
        const res = await fetch('https://api.github.com/user/repos?timestamp=' + Date.now(), {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (res.ok) {
            const repos = await res.json();
            localStorage.setItem('cached_repos', JSON.stringify(repos));
            localStorage.setItem('repos_cache_time', Date.now().toString());
        }
    } catch (err) {
        console.log('后台更新失败:', err);
    }
}

async function fetchRepos(forceRefresh = false) {
    const cacheKey = 'cached_repos';
    const cacheTimeKey = 'repos_cache_time';
    const CACHE_LIFETIME = 5 * 60 * 1000;
    const cachedRepos = localStorage.getItem(cacheKey);
    const cacheTime = localStorage.getItem(cacheTimeKey);
    if (!forceRefresh && cachedRepos && cacheTime && (Date.now() - parseInt(cacheTime) < CACHE_LIFETIME)) {
        try {
            state.repos = JSON.parse(cachedRepos);
            if (state.repos.length > 0) {
                renderRepoList();
                showRepoListView();
            }
            if (Date.now() - parseInt(cacheTime) > CACHE_LIFETIME / 2) {
                fetchRepos(true);
            }
            return;
        } catch (e) {
            console.error('缓存数据解析失败, 尝试从网络获取:', e);
        }
    }
    el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    try {
        const res = await fetch('https://api.github.com/user/repos?timestamp=' + Date.now(), {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            },
            cache: 'no-store'
        });
        if (!res.ok) throw new Error('获取仓库失败');
        const repos = await res.json();
        state.repos = repos;
        localStorage.setItem(cacheKey, JSON.stringify(state.repos));
        localStorage.setItem(cacheTimeKey, Date.now().toString());
        renderRepoList();
        showRepoListView();
    } catch (err) {
        showToast('加载仓库失败: ' + err.message);
        console.error(err);
        state.repos = [];
        renderRepoList();
        showRepoListView();
    }
}

function invalidateCacheForPathAndParents(path) {
    if (typeof path !== 'string') return;
    let currentPath = path;
    while (true) {
        const cacheKey = `${state.currentRepo}:${state.currentBranch}:${currentPath}`;
        state.fileCache.delete(cacheKey);
        if (currentPath === '') {
            break;
        }
        let tempPath = currentPath.endsWith('/') ? currentPath.slice(0, -1) : currentPath;
        let lastSlashIndex = tempPath.lastIndexOf('/');
        if (lastSlashIndex === -1) {
            currentPath = '';
        } else {
            currentPath = tempPath.substring(0, lastSlashIndex) + '/';
        }
    }
}

function renderRepoList() {
    state.repos.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
    el.repoList.innerHTML = state.repos.length === 0 ? '<div class="empty-state"><i class="fa fa-github"></i><p>没有找到仓库</p></div>' : '';
    state.repos.forEach(repo => {
        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `
            <div class="file-icon"><i class="fa fa-github"></i></div>
            <div class="file-info">
                <p class="file-name">${repo.name}</p>
                <p class="file-meta">
                    ${repo.private ? '私有仓库' : '公开仓库'} ${repo.size || repo.updated_at ? ' · ' : ''}
                    ${repo.size ? formatSize(repo.size * 1024) : ''}
                    ${repo.size && repo.updated_at ? ' · ' : ''}
                    ${formatRelativeTime(new Date(repo.updated_at))}
                </p>
                <p class="file-meta">${repo.description || ''}</p>
            </div>
        `;
        let pressTimer = null;
        let isLongPress = false;
        item.addEventListener('touchstart', (e) => {
            isLongPress = false;
            pressTimer = setTimeout(() => {
                isLongPress = true;
            }, 500);
        }, { passive: true });
        item.addEventListener('touchmove', () => {
            clearTimeout(pressTimer);
        });
        item.addEventListener('touchend', () => {
            clearTimeout(pressTimer);
        });
        item.addEventListener('click', async (e) => {
            if (!isLongPress) {
                el.mainLoader.classList.remove('hidden');
                try {
                    const lastBranch = localStorage.getItem(`last_branch_${repo.full_name}`);
                    const branchToLoad = lastBranch || repo.default_branch;
                    const newState = { repo: repo.full_name, path: '', branch: branchToLoad };
                    history.pushState(newState, '', `#/${repo.full_name}`);
                    state.currentRepo = repo.full_name;
                    state.currentPath = '';
                    state.currentBranch = branchToLoad;
                    el.currentRepo.textContent = repo.name;
                    await fetchBranches(repo);
                    await fetchFiles();
                    renderPathNav();
                    renderBranchSwitcher();
                    toggleView(false);
                } catch (error) {
                    showToast('加载仓库失败');
                    console.error(error);
                } finally {
                    el.mainLoader.classList.add('hidden');
                }
            }
        });
        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            clearTimeout(pressTimer);
            isLongPress = true;
            state.selectedRepo = repo;
            showRepoContextMenu(e, repo);
        });
        el.repoList.appendChild(item);
    });
}

function showRepoListView() {
    el.repoList.classList.remove('hidden');
    el.fileList.classList.add('hidden');
    el.pathNavContainer.classList.add('hidden');
    el.branchSwitcherContainer.classList.add('hidden');
    el.currentRepo.textContent = '选择仓库';
    toggleView(true);
    state.currentRepo = null;
    state.currentPath = '';
    state.currentBranch = null;
    state.branches = [];
}

async function fetchBranches(repo) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches`, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (res.ok) {
            state.branches = await res.json();
        } else {
            state.branches = [];
            showToast('获取分支列表失败');
        }
    } catch (e) {
        state.branches = [];
        showToast('获取分支列表失败');
        console.error(e);
    }
}

function renderBranchSwitcher() {
    const container = el.branchSwitcherContainer;
    container.innerHTML = '';
    if (!state.branches || state.branches.length === 0) {
        container.classList.add('hidden');
        return;
    }
    const wrapper = document.createElement('div');
    wrapper.className = 'custom-branch-select-wrapper';
    const trigger = document.createElement('button');
    trigger.className = 'custom-branch-select-trigger';
    trigger.innerHTML = `
        <span>${escapeHtml(state.currentBranch)}</span>
        <i class="fa fa-chevron-down"></i>
    `;
    const optionsPanel = document.createElement('div');
    optionsPanel.className = 'custom-branch-select-options';
    state.branches.forEach(branch => {
        const option = document.createElement('div');
        option.className = 'custom-branch-select-option';
        if (branch.name === state.currentBranch) {
            option.classList.add('selected');
        }
        option.textContent = branch.name;
        option.dataset.branchName = branch.name;
        option.addEventListener('click', () => {
            const selectedBranch = option.dataset.branchName;
            if (selectedBranch === state.currentBranch) {
                wrapper.classList.remove('open');
                return;
            }
            const previouslySelected = optionsPanel.querySelector('.custom-branch-select-option.selected');
            if (previouslySelected) {
                previouslySelected.classList.remove('selected');
            }
            option.classList.add('selected');
            state.currentBranch = selectedBranch;
            state.currentPath = '';
            localStorage.setItem(`last_branch_${state.currentRepo}`, state.currentBranch);
            el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
            const newState = { repo: state.currentRepo, path: '', branch: state.currentBranch };
            history.replaceState(newState, '', `#/${state.currentRepo}/`);
            renderPathNav();
            fetchFiles(true);
            trigger.querySelector('span').textContent = selectedBranch;
            wrapper.classList.remove('open');
        });
        optionsPanel.appendChild(option);
    });
    wrapper.appendChild(trigger);
    wrapper.appendChild(optionsPanel);
    container.appendChild(wrapper);
    container.classList.remove('hidden');
    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        wrapper.classList.toggle('open');
    });
    document.addEventListener('click', (e) => {
        if (!wrapper.contains(e.target)) {
            wrapper.classList.remove('open');
        }
    });
}

async function fetchFiles(forceRefresh = false) {
    if (!state.currentRepo || !state.currentBranch) return;
    const cacheKey = `${state.currentRepo}:${state.currentBranch}:${state.currentPath}`;
    
    if (!forceRefresh && state.fileCache.has(cacheKey)) {
        state.files = state.fileCache.get(cacheKey);
        applyFiltersAndSort();
        renderFileList();
        return;
    }
    
    el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    await fetchFilesFromNetwork(cacheKey);
}

async function fetchFilesFromNetwork(cacheKey) {
    try {
        const timestamp = Date.now();
        const url = `https://api.github.com/repos/${state.currentRepo}/contents/${state.currentPath}?ref=${state.currentBranch}&t=${timestamp}`;
        const res = await fetch(url, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            },
            cache: 'no-store'
        });
        if (!res.ok) {
            if (res.status === 404) {
                state.files = [];
                applyFiltersAndSort();
                renderFileList();
                return;
            }
            throw new Error('加载文件失败');
        }
        const data = await res.json();
        if (data.message) throw new Error(data.message);
        state.files = Array.isArray(data) ? data : [];
        state.files.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));
        state.fileCache.set(cacheKey, [...state.files]);
        applyFiltersAndSort();
        renderFileList();
    } catch (err) {
        if (err.message.includes('404')) {
            state.files = [];
            applyFiltersAndSort();
            renderFileList();
            return;
        }
        showToast('加载文件失败: ' + err.message);
        console.error(err);
    }
}

async function fetchFilesInBackground(cacheKey) {
    try {
        const timestamp = Date.now();
        const url = `https://api.github.com/repos/${state.currentRepo}/contents/${state.currentPath}?ref=${state.currentBranch}&t=${timestamp}`;
        const res = await fetch(url, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            },
            cache: 'no-store'
        });
        if (res.ok) {
            const data = await res.json();
            if (!data.message && Array.isArray(data)) {
                const files = data.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));
                state.fileCache.set(cacheKey, [...files]);
            }
        }
    } catch (err) {
        console.log('后台文件更新失败:', err);
    }
}

function renderFileList() {
    const list = (state.displayFiles && state.displayFiles.length >= 0) ? state.displayFiles : state.files;
    const fragment = document.createDocumentFragment();
    const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'];
    const isGridView = state.viewMode === 'grid';
    if (!list || list.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        emptyState.innerHTML = '<i class="fa fa-github"></i><p>此分支为空</p>';
        fragment.appendChild(emptyState);
    } else {
        list.forEach((file) => {
            const isDir = file.type === 'dir';
            const icon = isDir ? 'fa-folder' : getFileIcon(file.name);
            const item = document.createElement('div');
            const fileExtension = file.name.split('.').pop()?.toLowerCase();
            const isImage = !isDir && imageExtensions.includes(fileExtension);
            item.className = 'file-item';
            if (state.selectedItems.has(file.path)) {
                item.classList.add('selected');
            }
            if (isGridView && isImage) {
                item.classList.add('is-image-grid');
            }
            const checkboxHTML = `
                <div class="select-checkbox-wrapper">
                    <div class="select-checkbox-bg"></div>
                    <i class="fa fa-check"></i>
                </div>
            `;
            let innerHTML = '';
            const fileMetaHTML = `
                <p class="file-meta">
                    ${isDir ? '文件夹' : formatSize(file.size)}
                    ${(isDir || file.size) && file.last_modified ? ' · ' : ''}
                    ${file.last_modified ? formatRelativeTime(new Date(file.last_modified)) : ''}
                </p>
            `;
            if (isGridView) {
                let gridContentHTML = '';
                if (isImage) {
                    const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                    const imageUrl = getProxiedUrl(rawUrl);
                    gridContentHTML = `
                        <div class="file-thumbnail-container loading" data-image-url="${escapeHtml(imageUrl)}" data-image-name="${escapeHtml(file.name)}">
                             <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-exclamation-triangle"></i></div>
                        </div>
                        <div class="file-info">
                            <p class="file-name">${escapeHtml(file.name)}</p>
                            ${fileMetaHTML}
                        </div>
                    `;
                } else {
                    gridContentHTML = `
                        <div class="file-icon"><i class="fa ${icon}"></i></div>
                        <div class="file-info">
                            <p class="file-name">${escapeHtml(file.name)}</p>
                            ${fileMetaHTML}
                        </div>
                    `;
                }
                innerHTML = checkboxHTML + gridContentHTML;
            } else {
                let listContentHTML = '';
                if (isImage) {
                     const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                     const imageUrl = getProxiedUrl(rawUrl);
                     listContentHTML = `
                        <div class="file-thumbnail-container loading" data-image-url="${escapeHtml(imageUrl)}" data-image-name="${escapeHtml(file.name)}">
                           <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-exclamation-triangle"></i></div>
                        </div>
                     `;
                } else {
                    listContentHTML = `<div class="file-icon"><i class="fa ${icon}"></i></div>`;
                }
                listContentHTML += `
                    <div class="file-info">
                        <p class="file-name">${escapeHtml(file.name)}</p>
                        ${fileMetaHTML}
                    </div>
                `;
                innerHTML = checkboxHTML + listContentHTML;
            }
            item.innerHTML = innerHTML;
            let pressTimer = null;
            let isLongPress = false;
            item.addEventListener('touchstart', (e) => {
                isLongPress = false;
                pressTimer = setTimeout(() => { isLongPress = true; }, 500);
            }, { passive: true });
            item.addEventListener('touchmove', () => { clearTimeout(pressTimer); });
            item.addEventListener('touchend', () => { clearTimeout(pressTimer); });
            item.addEventListener('click', (e) => {
                if (e.target.closest('.retry-trigger') || isLongPress) return;
                if (state.isMultiSelectMode) {
                    item.classList.toggle('selected');
                    if (state.selectedItems.has(file.path)) {
                        state.selectedItems.delete(file.path);
                    } else {
                        state.selectedItems.add(file.path);
                    }
                    updateActionBar();
                } else {
                    if (isDir) {
                        navigateToDir(file.name);
                    } else {
                        const isMedia = IMAGE_EXTS.includes(fileExtension) || VIDEO_EXTS.includes(fileExtension) || AUDIO_EXTS.includes(fileExtension);
                        if (!isMedia) {
                           editFile(file);
                        }
                    }
                }
            });
            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                clearTimeout(pressTimer);
                isLongPress = true;
                showContextMenu(e, file);
            });
            fragment.appendChild(item);
        });
    }
    el.fileList.innerHTML = '';
    el.fileList.appendChild(fragment);
    updateActionBar();
    processImagePlaceholders();
}

function processImagePlaceholders() {
    const placeholders = document.querySelectorAll('.file-thumbnail-container.loading');
    placeholders.forEach(container => {
        const imageUrl = container.dataset.imageUrl;
        const imageName = container.dataset.imageName;
        if (!imageUrl) return;
        const img = new Image();
        img.className = 'file-thumbnail';
        img.alt = imageName;
        img.onload = () => {
            container.appendChild(img);
            container.classList.remove('loading');
            container.classList.add('loaded');
        };
        img.onerror = () => {
            console.error('图片加载失败:', imageUrl);
            container.classList.remove('loading');
            container.classList.add('error');
        };
        img.src = imageUrl;
    });
}

function renderPathNav() {
    el.pathNav.innerHTML = '';
    const rootItem = document.createElement('span');
    rootItem.className = 'path-item root';
    rootItem.innerHTML = '<i title="返回仓库根目录"></i>';
    rootItem.dataset.path = '';
    rootItem.addEventListener('click', () => {
        navigateToPath('');
    });
    el.pathNav.appendChild(rootItem);
    const parts = state.currentPath.split('/').filter(p => p);
    let currentPath = '';
    parts.forEach(part => {
        const separator = document.createElement('span');
        separator.className = 'path-separator';
        separator.textContent = '/';
        el.pathNav.appendChild(separator);
        currentPath += part + '/';
        const item = document.createElement('span');
        item.className = 'path-item';
        item.textContent = part;
        item.dataset.path = currentPath;
        item.addEventListener('click', () => {
            navigateToPath(item.dataset.path);
        });
        el.pathNav.appendChild(item);
    });
}

function navigateToDir(dirName) {
    const newPath = state.currentPath ? `${state.currentPath}${dirName}/` : `${dirName}/`;
    navigateToPath(newPath);
}

function navigateToPath(path) {
    state.currentPath = path;
    const newState = {
        repo: state.currentRepo,
        path: path,
        branch: state.currentBranch
    };
    history.pushState(newState, '', `#/${state.currentRepo}/${path}`);
    fetchFiles();
    renderPathNav();
}

function updateSortDropdownUI() {
    const dropdown = el.customSortDropdown;
    if (!dropdown) return;
    Array.from(dropdown.children).forEach(item => {
        const value = item.dataset.value;
        const priority = item.dataset.priority;
        if (value) {
            item.classList.toggle('selected', state.sortBy === value);
        }
        if (priority) {
            item.classList.toggle('active', state.directorySortPriority === priority);
        }
    });
}

function hideMainMenuPopup() {
    el.mainMenuPopup.classList.add('hidden');
    const index = uiStateStack.indexOf(hideMainMenuPopup);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showMainMenuPopup() {
    el.mainMenuPopup.classList.remove('hidden');
    uiStateStack.push(hideMainMenuPopup);
}

function hideSortDropdown() {
    el.customSortDropdown.classList.add('hidden');
    const index = uiStateStack.indexOf(hideSortDropdown);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showSortDropdown() {
    el.customSortDropdown.classList.remove('hidden');
    uiStateStack.push(hideSortDropdown);
}

function showEditModal() {
    el.editModal.classList.remove('hidden');
    el.editModal.classList.add('flex');
    el.editorOverlay.classList.add('show');
    setTimeout(adjustEditorDimensions, 10);
    uiStateStack.push(hideEditModal);
}

function hideEditModal() {
    
    el.editModal.classList.add('hidden');
    el.editModal.classList.remove('flex');
    state.editingFile = state.fileSha = state.originalContent = '';
    el.saveEdit.classList.remove('modified');
    const index = uiStateStack.indexOf(hideEditModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showEditStatus(text, type) {
    el.editStatus.textContent = text;
    el.editStatus.className = `edit-status ${type}`;
}

function adjustEditorDimensions() {
    const viewportHeight = window.innerHeight;
    const targetEditorHeight = viewportHeight * 0.6;
    const modal = el.editModal.querySelector('.modal-content');
    const headerHeight = modal.querySelector('.modal-header').offsetHeight;
    const statusHeight = el.editStatus.offsetHeight;
    const footerHeight = modal.querySelector('.modal-footer').offsetHeight;
    const paddingOffset = 20;
    const otherElementsHeight = headerHeight + statusHeight + footerHeight + paddingOffset;
    modal.style.height = `${targetEditorHeight + otherElementsHeight}px`;
    el.fileContent.style.height = `${targetEditorHeight}px`;
}

async function editFile(file) {
    state.editingFile = file;
    el.editFileName.textContent = `${file.name}`;
    el.fileContent.value = '';
    showEditStatus('', '');
    showEditModal();
    const cacheKey = `edit_cache_${state.currentRepo}_${state.currentBranch}_${state.editingFile.path}`;
    const cachedItem = localStorage.getItem(cacheKey);
    if (cachedItem) {
        try {
            const parsedData = JSON.parse(cachedItem);
            if (Date.now() - parsedData.timestamp < 3 * 60 * 1000) {
                el.fileContent.value = parsedData.content;
                el.editorOverlay.classList.remove('show');
                fetch(`https://api.github.com/repos/${state.currentRepo.split('/')[0]}/${state.currentRepo.split('/')[1]}/contents/${file.path}?ref=${state.currentBranch}`, { headers: { 'Authorization': `token ${state.token}` } })
                    .then(res => res.json())
                    .then(data => {
                        state.originalContent = decodeURIComponent(escape(atob(data.content)));
                        state.fileSha = data.sha;
                        el.fileContent.oninput = checkContentChanges;
                        checkContentChanges();
                    });
                return;
            } else {
                localStorage.removeItem(cacheKey);
            }
        } catch (e) {
            localStorage.removeItem(cacheKey);
        }
    }
    try {
        const res = await fetch(`https://api.github.com/repos/${state.currentRepo.split('/')[0]}/${state.currentRepo.split('/')[1]}/contents/${file.path}?ref=${state.currentBranch}`, {
            headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
        });
        if (!res.ok) throw new Error((await res.json()).message || '加载文件失败');
        
        const data = await res.json();
        const content = decodeURIComponent(escape(atob(data.content)));
        
        el.fileContent.value = content;
        state.originalContent = content;
        state.fileSha = data.sha;
        el.editorOverlay.classList.remove('show');
        el.fileContent.oninput = checkContentChanges;
        checkContentChanges();
    } catch (e) {
        el.editorOverlay.classList.remove('show');
        showEditStatus(`错误：${e.message}`, 'error');
    }
}

function checkContentChanges() {
    const isModified = el.fileContent.value !== state.originalContent;
    el.saveEdit.classList.toggle('modified', isModified);
    el.revertEditBtn.disabled = !isModified;
}

async function saveEditedFile() {
    if (!state.editingFile || !state.fileSha) return;
    const currentContent = el.fileContent.value;
    if (currentContent === state.originalContent) {
        showToast('未检测到修改');
        return;
    }
    el.editorOverlay.classList.add('show');
    el.saveEdit.classList.add('btn-processing');
    try {
        const [owner, repo] = state.currentRepo.split('/');
        const encodedContent = btoa(unescape(encodeURIComponent(currentContent)));
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${state.editingFile.path}`;
        const requestBody = {
            message: `Update ${state.editingFile.name} via web editor`,
            content: encodedContent,
            sha: state.fileSha,
            branch: state.currentBranch
        };
        const requestHeaders = {
            'Authorization': `token ${state.token}`,
            'Content-Type': 'application/json',
            'User-Agent': 'Mozilla/5.0'
        };
        let res = await fetch(url, {
            method: 'PUT',
            headers: requestHeaders,
            body: JSON.stringify(requestBody)
        });
        if (!res.ok) {
            if (res.status === 409) {
                const latestInfoRes = await fetch(url, { headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' } });
                if (!latestInfoRes.ok) throw new Error('获取最新文件版本失败');
                const latestInfo = await latestInfoRes.json();
                
                requestBody.sha = latestInfo.sha;
                res = await fetch(url, {
                    method: 'PUT',
                    headers: requestHeaders,
                    body: JSON.stringify(requestBody)
                });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(`保存失败: ${err.message}`);
                }
            } else {
                const err = await res.json();
                throw new Error(`保存失败: ${err.message}`);
            }
        }
        const result = await res.json();
        state.fileSha = result.content.sha;
        state.originalContent = currentContent;
        const cacheKey = `edit_cache_${state.currentRepo}_${state.currentBranch}_${state.editingFile.path}`;
    const cacheData = {
        content: currentContent, 
        timestamp: Date.now()
    };
    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
        el.editorOverlay.classList.remove('show');
        showToast('文件已保存');
        showSaveNotification();
        fetchFiles(true);
        checkContentChanges();
    } catch (e) {
        el.editorOverlay.classList.remove('show');
        showEditStatus(`错误：${e.message}`, 'error');
        console.error(e);
    } finally {
        el.saveEdit.classList.remove('btn-processing');
    }
}

async function downloadFile(item) {
    if (item.type === 'dir') return;
    try {
        showToast(`准备下载 ${item.name}`);
        const rawUrl = (item.download_url) ? item.download_url : item.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const url = getProxiedUrl(rawUrl);
        const response = await fetch(url);
        if (!response.ok) throw new Error(`下载失败 (${response.status})`);
        const blob = await response.blob();
        const objectUrl = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = objectUrl;
        a.download = item.name;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(objectUrl);
        }, 500);
        showToast(`开始下载 ${item.name}`);
    } catch (e) {
        showToast(`下载出错: ${e.message}`);
        console.error(e);
    }
}

function copyLink(file) {
    const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    navigator.clipboard.writeText(rawUrl).then(() => {
        showToast('Raw 链接已复制');
    }).catch(e => {
        showToast(`复制失败: ${e.message || '请检查浏览器权限或非安全上下文'}`);
        console.error(e);
    });
}

function copyProxyLink(file) {
    const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    const activeProxy = state.proxies[state.activeProxyIndex];
    if (state.proxyGlobalEnable && activeProxy && activeProxy.url && activeProxy.type) {
        let proxiedUrl = rawUrl;
        const proxyDomain = getDomainFromUrl(activeProxy.url);
        
        if (activeProxy.type === 'prefix') {
            let base = activeProxy.url;
            if (!base.endsWith('/')) {
                base += '/';
            }
            proxiedUrl = base + rawUrl;
        } else if (activeProxy.type === 'raw_domain_replace') {
            proxiedUrl = rawUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
            if (!proxiedUrl.startsWith('http')) {
                proxiedUrl = 'https://' + proxiedUrl;
            }
        }
        navigator.clipboard.writeText(proxiedUrl).then(() => {
            const displayUrl = activeProxy.url.replace(/^https?:\/\//, '').replace(/\/$/, '');
            showToast(`已复制当前代理链接 [${displayUrl}]`);
        }).catch(e => {
            showToast(`复制失败: ${e.message || '请检查浏览器权限'}`);
            console.error(e);
        });
    } else {
        navigator.clipboard.writeText(rawUrl).then(() => {
            showToast('代理未开启，已复制直连 Raw 链接');
        }).catch(e => {
            showToast(`复制失败: ${e.message || '请检查浏览器权限'}`);
            console.error(e);
        });
    }
}

function positionContextMenu(e, menuWidth, menuHeight) {
    let clickX, clickY;
    if (e.touches && e.touches.length > 0) {
        clickX = e.touches[0].clientX;
        clickY = e.touches[0].clientY;
    } else {
        clickX = e.clientX;
        clickY = e.clientY;
    }
    const offsetX = 30;
    const offsetY = 30;
    let leftPos = clickX + offsetX;
    let topPos = clickY + offsetY;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    if (leftPos + menuWidth > windowWidth) {
        leftPos = clickX - menuWidth - offsetX;
    }
    if (topPos + menuHeight > windowHeight) {
        topPos = clickY - menuHeight - offsetY;
    }
    if (leftPos < 0) leftPos = 5;
    if (topPos < 0) topPos = 5;
    return { top: topPos, left: leftPos };
}

function renderContextMenuItems(file) {
    el.contextMenuItems.innerHTML = '';
    const isDir = file.type === 'dir';
    const category = isDir ? 'folder' : 'file';
    const visibleItems = CONTEXT_MENU_DEFINITIONS[category].filter(item => 
        state.contextMenuVisibility[category][item.action]
    );
    visibleItems.forEach(({ action, icon, text, className = '' }) => {
        const item = document.createElement('a');
        item.className = `context-menu-item ${className}`;
        item.dataset.action = action;
        item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
        item.addEventListener('click', () => {
            handleContextMenuAction(action, state.selectedFile);
            hideContextMenu();
        });
        el.contextMenuItems.appendChild(item);
    });
}

function showContextMenu(e, file) {
    state.selectedFile = file;
    const menu = el.contextMenu;
    menu.style.opacity = '0';
    menu.style.transform = 'scale(0.8)';
    menu.classList.remove('hidden');
    renderContextMenuItems(file);
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const position = positionContextMenu(e, menuWidth, menuHeight);
    menu.style.top = `${position.top}px`;
    menu.style.left = `${position.left}px`;
    let start = null, duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = progress.toString();
        menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
        if (progress < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    uiStateStack.push(hideContextMenu);
}

async function showRepoContextMenu(e, repo) {
    state.selectedRepo = repo;
    const menu = el.contextMenu;
    menu.style.opacity = '0';
    menu.style.transform = 'scale(0.8)';
    menu.classList.remove('hidden');
    await renderRepoContextMenuItems(repo);
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const position = positionContextMenu(e, menuWidth, menuHeight);
    menu.style.top = `${position.top}px`;
    menu.style.left = `${position.left}px`;
    let start = null, duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = progress.toString();
        menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
        if (progress < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    uiStateStack.push(hideContextMenu);
}

async function renderRepoContextMenuItems(repo) {
    el.contextMenuItems.innerHTML = '';
    const mainSiteName = state.user ? `${state.user.login}.github.io` : '';
    const isMainSite = mainSiteName && repo.name === mainSiteName;
    const visibleItems = CONTEXT_MENU_DEFINITIONS.repo.filter(item => {
        if (isMainSite && item.action === 'setAsMainSite') return false;
        if (!isMainSite && item.action === 'copyMainSiteLink') return false;
        return state.contextMenuVisibility.repo[item.action];
    });
    visibleItems.forEach(({ action, icon, text, className = '' }) => {
        const item = document.createElement('a');
        item.className = `context-menu-item ${className}`;
        item.dataset.action = action;
        item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
        item.addEventListener('click', () => {
            handleRepoContextMenuAction(action, state.selectedRepo);
            hideContextMenu();
        });
        el.contextMenuItems.appendChild(item);
    });
}

const hideContextMenu = () => {
    const menu = el.contextMenu;
    if (menu.classList.contains('hidden')) return;
    let start = null,
        duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = (1 - progress).toString();
        menu.style.transform = `scale(${1 - 0.2 * progress})`;
        if (progress < 1) requestAnimationFrame(animate);
        else {
            menu.classList.add('hidden');
            state.selectedFile = null;
            state.selectedRepo = null;
        }
    }
    requestAnimationFrame(animate);
    const index = uiStateStack.indexOf(hideContextMenu);
    if (index > -1) uiStateStack.splice(index, 1);
};

async function deleteSingleItem(item) {
    const [owner, repo] = state.currentRepo.split('/');
    const deleteFile = async (path, sha) => {
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
            method: 'DELETE',
            headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: `Delete ${item.name}`, sha: sha, branch: state.currentBranch })
        });
        if (!res.ok) throw new Error((await res.json()).message || `删除 ${item.name} 失败`);
    };
    const getAllFiles = async (path) => {
        let allFiles = [];
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`, { headers: { Authorization: `token ${state.token}` } });
        const items = await res.json();
        if (!Array.isArray(items)) return [];
        for (const i of items) {
            if (i.type === 'dir') {
                allFiles = allFiles.concat(await getAllFiles(i.path));
            } else {
                allFiles.push(i);
            }
        }
        return allFiles;
    };
    if (item.type === 'dir') {
        const filesToDelete = await getAllFiles(item.path);
        for (const f of filesToDelete.reverse()) {
            await deleteFile(f.path, f.sha);
        }
    } else {
        await deleteFile(item.path, item.sha);
    }
}

function handleContextMenuAction(action, oldFileObject) {
    const currentFile = state.files.find(f => f.path === oldFileObject.path);
    if (!currentFile) {
        showToast('文件已更新，请重新选择或刷新页面');
        return;
    }
    switch (action) {
        case 'multiSelect':
            toggleMultiSelectMode(true);
            state.selectedItems.add(currentFile.path);
            renderFileList();
            updateActionBar();
            break;
        case 'download':
            downloadFile(currentFile);
            break;
        case 'downloadFolder':
            downloadFolderAsZip(currentFile);
            break;
        case 'copyLink':
            copyLink(currentFile);
            break;
        case 'copyProxy':
            copyProxyLink(currentFile);
            break;
        case 'copyGitHubLink':
            navigator.clipboard.writeText(currentFile.html_url).then(() => {
                showToast('GitHub 链接已复制');
            }).catch(e => {
                showToast(`复制失败: ${e.message || '请检查浏览器权限或非安全上下文'}`);
                console.error(e);
            });
            break;
        case 'edit':
            editFile(currentFile);
            break;
        case 'rename':
            showRenameModal(currentFile);
            break;
        case 'delete':
            showDeleteModal(currentFile);
            break;
    }
}

function handleRepoContextMenuAction(action, repo) {
    switch (action) {
        case 'copyRepoGitHubLink':
            navigator.clipboard.writeText(repo.html_url).then(() => showToast('仓库链接已复制'));
            break;
        case 'createBranch':
            showCreateBranchModal(repo);
            break;
        case 'setAsMainSite':
            setAsMainSite(repo);
            break;
        case 'copyMainSiteLink':
            navigator.clipboard.writeText(`https://${repo.name}`).then(() => showToast('网站链接已复制'));
            break;
        case 'downloadRepoDirect':
            downloadRepoAsZip(repo, false);
            break;
        case 'renameRepo':
            showRenameRepoModal(repo);
            break;
        case 'deleteRepo':
            showDeleteRepoModal(repo);
            break;
    }
}

function findNextAvailableBackupName() {
    let maxNum = 0;
    const prefix = 'Github----';
    state.repos.forEach(repo => {
        if (repo.name.startsWith(prefix)) {
            const numPart = repo.name.substring(prefix.length);
            if (/^\d+$/.test(numPart)) {
                const num = parseInt(numPart, 10);
                if (num > maxNum) {
                    maxNum = num;
                }
            }
        }
    });
    return `${prefix}${maxNum + 1}`;
}

async function setAsMainSite(selectedRepo) {
    if (!state.user || !state.user.login) {
        showToast('无法获取用户信息，请稍后重试');
        return;
    }
    const mainSiteName = `${state.user.login}.github.io`;
    if (selectedRepo.name === mainSiteName) {
        showToast('此仓库已是您的主站');
        return;
    }
    el.mainLoader.classList.remove('hidden');
    try {
        const existingMainSite = state.repos.find(r => r.name === mainSiteName);
        if (existingMainSite) {
            const backupName = findNextAvailableBackupName();
            showToast(`正在重命名旧仓库名称`);
            const backupRes = await fetch(`https://api.github.com/repos/${existingMainSite.full_name}`, {
                method: 'PATCH',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: backupName })
            });
            if (!backupRes.ok) throw new Error('重命名旧主站失败');
        }
        showToast(`正在创建新网站`);
        const renameRes = await fetch(`https://api.github.com/repos/${selectedRepo.full_name}`, {
            method: 'PATCH',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: mainSiteName })
        });
        if (!renameRes.ok) throw new Error('设置新主站失败');
        const newRepoData = await renameRes.json();
        showToast('正在发布网站...');
        const pagesRes = await fetch(`https://api.github.com/repos/${newRepoData.full_name}/pages`, {
            method: 'POST',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ source: { branch: newRepoData.default_branch, path: "/" } })
        });
        if (!pagesRes.ok && pagesRes.status !== 409) throw new Error('发布网站失败');
        showToast('网站发布成功');
        await fetchRepos(true);
    } catch (e) {
        showToast(`操作失败: ${e.message}`);
        await fetchRepos(true);
    } finally {
        el.mainLoader.classList.add('hidden');
    }
}

async function toggleGitHubPages(repo) {
    el.mainLoader.classList.remove('hidden');
    try {
        showToast(`正在发布网站: ${repo.name}`);
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
            method: 'POST',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ source: { branch: repo.default_branch, path: "/" } })
        });
        if (!res.ok) throw new Error('发布网站失败');
        showToast('网站发布成功！');
    } catch (e) {
        showToast(`操作失败: ${e.message}`);
    } finally {
        el.mainLoader.classList.add('hidden');
    }
}

function downloadRepoAsZip(repo, useProxy) {
    const zipRaw = `https://github.com/${repo.full_name}/archive/refs/heads/${repo.default_branch || 'main'}.zip`;
    const zipUrl = useProxy ? getProxiedUrl(zipRaw) : zipRaw;
    const a = document.createElement('a');
    a.href = zipUrl;
    a.download = `${repo.name}.zip`;
    a.classList.add('hidden');
    document.body.appendChild(a);
    a.click();
    setTimeout(() => document.body.removeChild(a), 500);
    showToast(`正在下载 ${repo.name}.zip (${useProxy ? '代理' : '直连'})`);
}

function handleUploadClick() {
    if (!state.currentRepo) {
        showToast('请先选择仓库');
        return;
    }
    el.fileUploadInput.click();
}

function handleFilesSelected(e) {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;
    el.uploadPanel.classList.remove('hidden');
    el.uploadItems.innerHTML = '';
    files.forEach((file, index) => {
        let displayName = file.name;
        if (displayName.length > 25) {
            displayName = displayName.slice(0, 22) + '...';
        }
        const uploadItem = document.createElement('div');
        uploadItem.className = 'upload-item';
        uploadItem.innerHTML = `
            <div class="upload-info">
                <span class="upload-name" title="${file.name}">${displayName}</span>
                <span class="upload-size">${formatSize(file.size)}</span>
            </div>
            <div class="upload-progress-container">
                <div class="upload-progress" data-index="${index}">
                    <span class="percent-text" data-index="${index}">0%</span>
                </div>
            </div>
            <div class="upload-status" data-index="${index}">等待上传...</div>
        `;
        el.uploadItems.appendChild(uploadItem);
    });
    uploadFilesInSequence(files, 0);
    e.target.value = '';
}

async function uploadFilesInSequence(files, index) {
    if (index >= files.length) {
        setTimeout(() => {
            el.uploadPanel.classList.add('hidden');
        }, 200);
        return;
    }
    const file = files[index];
    const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
    if (statusElement) statusElement.textContent = '准备上传...';
    try {
        await uploadSingleFile(file, index);
    } catch (error) {
        console.error(`Upload failed for file at index ${index}:`, error);
    } finally {
        invalidateCacheForPathAndParents(state.currentPath);
        await fetchFiles(true);
    }
    await uploadFilesInSequence(files, index + 1);
}

async function uploadSingleFile(file, index) {
    const MAX_FILE_SIZE_BYTES = 100 * 1024 * 1024;
    return new Promise(async (resolve, reject) => {
        const progressBar = document.querySelector(`.upload-progress[data-index="${index}"]`);
        const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
        const percentTextEl = progressBar ? progressBar.querySelector(`.percent-text[data-index="${index}"]`) : null;
        if (file.size > MAX_FILE_SIZE_BYTES) {
            if (statusElement) {
                statusElement.textContent = `文件过大 (限制100MB)`;
                statusElement.className = 'upload-status error';
            }
            showToast(`文件 "${file.name}" 超过100MB官方限制`);
            reject(new Error('文件过大'));
            return;
        }
        if (statusElement) statusElement.textContent = '正在上传...';
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = async (e) => {
            let progress = 0;
            let progressInterval = null;
            const [owner, repo] = state.currentRepo.split('/');
            const fileName = file.name;
            const filePath = state.currentPath ? `${state.currentPath}${fileName}` : fileName;
            const verifyUpload = async () => {
                if (statusElement) statusElement.textContent = '上传超时，正在验证...';
                try {
                    await new Promise(res => setTimeout(res, 2000));
                    const verifyUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${state.currentBranch}&t=${Date.now()}`;
                    const verifyRes = await fetch(verifyUrl, {
                        headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
                    });
                    if (verifyRes.ok) {
                        return true;
                    }
                    return false;
                } catch (verifyError) {
                    return false;
                }
            };
            try {
                progressInterval = setInterval(() => {
                    if (progress < 95) {
                        progress += 1;
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (percentTextEl) percentTextEl.textContent = `${progress}%`;
                    }
                }, 100);
                const base64String = arrayBufferToBase64(e.target.result);
                if (!state || !state.currentRepo) throw new Error('未选择仓库');
                let existingFileSha = null;
                try {
                    const checkUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${state.currentBranch}`;
                    const checkRes = await fetch(checkUrl, { headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' } });
                    if (checkRes.ok) existingFileSha = (await checkRes.json()).sha;
                } catch (e) { console.warn(`无法获取文件SHA: ${e.message}`); }
                const requestBody = {
                    message: `Upload ${fileName}`,
                    content: base64String,
                    branch: state.currentBranch
                };
                if (existingFileSha) requestBody.sha = existingFileSha;
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                    body: JSON.stringify(requestBody),
                    signal: AbortSignal.timeout(300000)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `上传失败: HTTP ${response.status}`);
                }
                clearInterval(progressInterval);
                progress = 100;
                if (progressBar) progressBar.style.width = '100%';
                if (percentTextEl) percentTextEl.textContent = '100%';
                if (statusElement) {
                    statusElement.textContent = '上传成功';
                    statusElement.className = 'upload-status success';
                }
                resolve();
            } catch (error) {
                let isVerifiedSuccess = false;
                if (error.name === 'AbortError' || error.message.includes('Failed to fetch')) {
                    isVerifiedSuccess = await verifyUpload();
                }
                if (isVerifiedSuccess) {
                    if (statusElement) {
                        statusElement.textContent = '上传成功 (已验证)';
                        statusElement.className = 'upload-status success';
                    }
                    resolve();
                } else {
                    if (statusElement) {
                        statusElement.textContent = '上传失败';
                        statusElement.className = 'upload-status error';
                    }
                    reject(new Error(`上传失败: ${error.message}`));
                }
            } finally {
                if (progressInterval) clearInterval(progressInterval);
                const itemContainer = statusElement ? statusElement.closest('.upload-item') : null;
                if (itemContainer && statusElement.classList.contains('success')) {
                    setTimeout(() => {
                        itemContainer.style.transition = 'opacity 0.5s, height 0.5s, margin 0.5s, padding 0.5s';
                        itemContainer.style.opacity = '0';
                        itemContainer.style.height = '0';
                        itemContainer.style.margin = '0';
                        itemContainer.style.padding = '0';
                        itemContainer.style.overflow = 'hidden';
                        setTimeout(() => itemContainer.remove(), 500);
                    }, 1500);
                }
            }
        };
        reader.onerror = () => {
            if (statusElement) {
                statusElement.textContent = '文件读取失败';
                statusElement.className = 'upload-status error';
            }
            reject(new Error('文件读取失败'));
        };
    });
}

function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

async function renameWithGitDataAPI(item, newName) {
    const [owner, repo] = state.currentRepo.split('/');
    const oldPath = item.path;
    const newPath = oldPath.substring(0, oldPath.lastIndexOf('/') + 1) + newName;
    const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!refResponse.ok) throw new Error('无法获取分支信息');
    const refData = await refResponse.json();
    const latestCommitSha = refData.object.sha;
    const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits/${latestCommitSha}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!commitResponse.ok) throw new Error('无法获取提交信息');
    const commitData = await commitResponse.json();
    const baseTreeSha = commitData.tree.sha;
    const createTreeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            base_tree: baseTreeSha,
            tree: [
                { path: newPath, mode: '100644', type: 'blob', sha: item.sha },
                { path: oldPath, mode: '100644', type: 'blob', sha: null }
            ]
        })
    });
    if (!createTreeResponse.ok) throw new Error('创建新目录树失败');
    const treeData = await createTreeResponse.json();
    const newTreeSha = treeData.sha;
    const createCommitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            message: `Rename ${item.name} to ${newName}`,
            tree: newTreeSha,
            parents: [latestCommitSha]
        })
    });
    if (!createCommitResponse.ok) throw new Error('创建新提交失败');
    const newCommitData = await createCommitResponse.json();
    const newCommitSha = newCommitData.sha;
    const updateRefResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        method: 'PATCH',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ sha: newCommitSha })
    });
    if (!updateRefResponse.ok) throw new Error('更新分支引用失败');
}

async function renameFolderWithGitDataAPI(item, newName) {
    const [owner, repo] = state.currentRepo.split('/');
    const oldPath = item.path;
    const newPath = oldPath.substring(0, oldPath.lastIndexOf('/') + 1) + newName;
    const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!refResponse.ok) throw new Error('无法获取分支信息');
    const refData = await refResponse.json();
    const latestCommitSha = refData.object.sha;
    const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits/${latestCommitSha}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!commitResponse.ok) throw new Error('无法获取提交信息');
    const commitData = await commitResponse.json();
    const baseTreeSha = commitData.tree.sha;
    const createTreeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            base_tree: baseTreeSha,
            tree: [
                { path: newPath, mode: '040000', type: 'tree', sha: item.sha },
                { path: oldPath, mode: '040000', type: 'tree', sha: null }
            ]
        })
    });
    if (!createTreeResponse.ok) throw new Error('创建新目录树失败');
    const treeData = await createTreeResponse.json();
    const newTreeSha = treeData.sha;
    const createCommitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            message: `Rename ${item.name} to ${newName}`,
            tree: newTreeSha,
            parents: [latestCommitSha]
        })
    });
    if (!createCommitResponse.ok) throw new Error('创建新提交失败');
    const newCommitData = await createCommitResponse.json();
    const newCommitSha = newCommitData.sha;
    const updateRefResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        method: 'PATCH',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ sha: newCommitSha })
    });
    if (!updateRefResponse.ok) throw new Error('更新分支引用失败');
}

function hideRenameModal() {
    el.renameModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideRenameModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showRenameModal(item) {
    const isDir = item.type === 'dir';
    const ONE_MB = 1024 * 1024;
    el.renameTitle.querySelector('.modal-title-text').textContent = `重命名${isDir ? '文件夹' : '文件'}`;
    el.renameInput.value = item.name;
    el.renameWarn.style.display = 'none';
    el.renameWarn.textContent = '';
    el.renameModal.classList.remove('hidden');
    el.renameConfirm.disabled = true;
    el.renameInput.oninput = function() {
        const newName = el.renameInput.value.trim();
        el.renameConfirm.disabled = !newName || newName === item.name;
    };
    el.renameConfirm.onclick = async function() {
        const v = el.renameInput.value.trim();
        if (!v || v === item.name) return;
        el.renameConfirm.disabled = true;
        el.renameConfirm.classList.add('btn-processing');
        el.renameConfirm.innerHTML = '保存中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            if (isDir) {
                await renameFolderWithGitDataAPI(item, v);
            } else {
                if (item.size > ONE_MB) {
                    await renameWithGitDataAPI(item, v);
                } else {
                    const [owner, repo] = state.currentRepo.split('/');
                    const oldPath = item.path;
                    const base = oldPath.slice(0, -item.name.length);
                    const newPath = base + v;
                    const d = await (await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}?ref=${state.currentBranch}`, {
                        headers: { Authorization: `token ${state.token}` }
                    })).json();
                    await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${newPath}`, {
                        method: 'PUT',
                        headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: `Rename to ${v}`, content: d.content, sha: d.sha, branch: state.currentBranch })
                    });
                    await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}`, {
                        method: 'DELETE',
                        headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: `Delete old file`, sha: d.sha, branch: state.currentBranch })
                    });
                }
            }
            showToast(`重命名成功: ${v}`);
            hideRenameModal();
            fetchFiles(true);
        } catch (e) {
            showToast(`失败: ${e.message}`);
        } finally {
            el.renameConfirm.disabled = false;
            el.renameConfirm.classList.remove('btn-processing');
            el.renameConfirm.innerHTML = '确认';
        }
    };
    uiStateStack.push(hideRenameModal);
}

function hideCreateFolderModal() {
    el.createFolderModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateFolderModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateFolderModal() {
    el.createFolderInput.value = '';
    el.createFolderModal.classList.remove('hidden');
    el.createFolderConfirm.disabled = true;
    el.createFolderConfirm.onclick = async function() {
        const name = el.createFolderInput.value.trim();
        if (!name || el.createFolderConfirm.classList.contains('btn-processing')) return;
        el.createFolderConfirm.classList.add('btn-processing');
        el.createFolderConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const path = state.currentPath ? `${state.currentPath}${name}` : name;
            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}/.gitkeep`, {
                method: 'PUT',
                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                body: JSON.stringify({ message: `create folder ${name}`, content: '', branch: state.currentBranch })
            });
            showToast(`已创建文件夹: ${name}`);
            hideCreateFolderModal();
            fetchFiles(true);
        } catch (e) {
            showToast(`失败: ${e.message}`);
        } finally {
            el.createFolderConfirm.classList.remove('btn-processing');
            el.createFolderConfirm.innerHTML = '确认';
            el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
        }
    };
    uiStateStack.push(hideCreateFolderModal);
}

function hideCreateFileModal() {
    el.createFileModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateFileModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateFileModal() {
    if (!state.currentRepo) {
        showToast('请先选择仓库');
        return;
    }
    el.createFileNameInput.value = '';
    el.createFileContentInput.value = '';
    el.createFileModal.classList.remove('hidden');
    el.createFileConfirm.disabled = true;
    el.createFileConfirm.onclick = async function() {
        const name = el.createFileNameInput.value.trim();
        const content = el.createFileContentInput.value;
        if (!name) return;
        el.createFileConfirm.disabled = true;
        el.createFileConfirm.classList.add('btn-processing');
        el.createFileConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const path = state.currentPath ? `${state.currentPath}${name}` : name;
            const encodedContent = btoa(unescape(encodeURIComponent(content)));
            const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                method: 'PUT',
                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: `create file ${name}`, content: encodedContent, branch: state.currentBranch })
            });
            if (!res.ok) throw new Error('创建失败');
            showToast(`已创建文件: ${name}`);
            hideCreateFileModal();
            fetchFiles(true);
        } catch (e) {
            showToast(`失败: ${e.message}`);
        } finally {
            el.createFileConfirm.disabled = false;
            el.createFileConfirm.classList.remove('btn-processing');
            el.createFileConfirm.innerHTML = '确认';
        }
    };
    uiStateStack.push(hideCreateFileModal);
}

function hideCreateBranchModal() {
    el.createBranchModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateBranchModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function showCreateBranchModal(repo) {
    el.createBranchNameInput.value = '';
    el.createBranchConfirm.disabled = true;
    el.createBranchModal.classList.remove('hidden');
    el.createBranchNameInput.oninput = () => {
        el.createBranchConfirm.disabled = !el.createBranchNameInput.value.trim();
    };
    const sourceSelector = {
        wrapper: document.getElementById('sourceBranchSelector'),
        trigger: document.getElementById('sourceBranchSelector').querySelector('.custom-branch-select-trigger'),
        optionsPanel: document.getElementById('sourceBranchSelector').querySelector('.custom-branch-select-options'),
        triggerText: document.getElementById('sourceBranchSelector').querySelector('span'),
        currentSelection: { name: null, sha: null }
    };
    sourceSelector.triggerText.textContent = '加载中...';
    sourceSelector.optionsPanel.innerHTML = '';
    const updateBranchActionButtonsState = () => {
        const selectedBranchName = sourceSelector.currentSelection.name;
        if (!selectedBranchName) {
            el.renameBranchBtn.disabled = true;
            el.deleteBranchBtn.disabled = true;
            el.renameBranchBtn.title = '重命名所选分支';
            el.deleteBranchBtn.title = '删除所选分支';
            return;
        };
        const isDefaultBranch = selectedBranchName === repo.default_branch;
        el.renameBranchBtn.disabled = isDefaultBranch;
        el.renameBranchBtn.title = isDefaultBranch ? '不能重命名默认分支' : `重命名分支: ${selectedBranchName}`;
        el.deleteBranchBtn.disabled = isDefaultBranch;
        el.deleteBranchBtn.title = isDefaultBranch ? '不能删除默认分支' : `删除分支: ${selectedBranchName}`;
    };
    try {
        await fetchBranches(repo);
        const populateBranchOptions = () => {
            sourceSelector.optionsPanel.innerHTML = '';
            if (!state.branches || state.branches.length === 0) {
                sourceSelector.triggerText.textContent = '无可用分支';
                sourceSelector.currentSelection = { name: null, sha: null };
                el.createBranchConfirm.disabled = true; 
                return;
            }
            state.branches.forEach(branch => {
                const option = document.createElement('div');
                option.className = 'custom-branch-select-option';
                option.textContent = branch.name;
                option.dataset.branchName = branch.name;
                option.dataset.branchSha = branch.commit.sha;
                option.addEventListener('click', () => {
                    sourceSelector.currentSelection = { name: branch.name, sha: branch.commit.sha };
                    const previouslySelected = sourceSelector.optionsPanel.querySelector('.selected');
                    if (previouslySelected) previouslySelected.classList.remove('selected');
                    option.classList.add('selected');
                    sourceSelector.triggerText.textContent = branch.name;
                    sourceSelector.wrapper.classList.remove('open');
                    updateBranchActionButtonsState();
                });
                sourceSelector.optionsPanel.appendChild(option);
            });
            const defaultBranch = state.branches.find(b => b.name === repo.default_branch) || state.branches[0];
            if (defaultBranch) {
                sourceSelector.currentSelection = { name: defaultBranch.name, sha: defaultBranch.commit.sha };
                sourceSelector.triggerText.textContent = defaultBranch.name;
                const defaultOption = sourceSelector.optionsPanel.querySelector(`[data-branch-name="${defaultBranch.name}"]`);
                if (defaultOption) defaultOption.classList.add('selected');
            }
        };
        populateBranchOptions();
    } catch (error) {
        console.error("加载分支失败:", error);
        sourceSelector.triggerText.textContent = '加载分支失败';
        showToast('加载分支列表失败');
        sourceSelector.currentSelection = { name: null, sha: null };
        el.createBranchConfirm.disabled = true;
    }
    updateBranchActionButtonsState();
    sourceSelector.trigger.onclick = (e) => {
        if (!state.branches || state.branches.length === 0) return;
        e.stopPropagation();
        sourceSelector.wrapper.classList.toggle('open');
    };
    document.addEventListener('click', (e) => {
        if (!sourceSelector.wrapper.contains(e.target)) {
            sourceSelector.wrapper.classList.remove('open');
        }
    });
    el.renameBranchBtn.onclick = function() {
        const branchToRename = sourceSelector.currentSelection.name;
        if (!branchToRename || branchToRename === repo.default_branch) {
            showToast('禁止重命名默认分支');
            return;
        }
        showRenameModal({ name: branchToRename });
    };
    el.deleteBranchBtn.onclick = function() {
        const branchToDelete = sourceSelector.currentSelection.name;
        if (!branchToDelete || branchToDelete === repo.default_branch) {
            showToast('禁止删除默认分支');
            return;
        }
        el.createBranchModal.style.pointerEvents = 'none';
        showDeleteModal(null, false, '确认删除分支', `确定要删除分支 "${branchToDelete}" 吗？此操作不可撤销。`, async () => {
            try {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs/heads/${branchToDelete}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `token ${state.token}` }
                });
                if (!res.ok) throw new Error((await res.json()).message || '删除分支失败');
                showToast(`分支 &nbsp;${branchToDelete}已成功删除,请等待服务器刷新`);
                if (state.currentRepo === repo.full_name) {
                    await fetchBranches(repo);
                }
            } catch (e) {
                showToast(`删除失败: ${e.message}`);
            } finally {
                el.createBranchModal.style.pointerEvents = 'auto';
            }
        });
    };
    el.createBranchConfirm.onclick = async function() {
        const newBranchName = el.createBranchNameInput.value.trim();
        const sourceBranchSha = sourceSelector.currentSelection.sha;
        if (!newBranchName || !sourceBranchSha) return;
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs`, {
                method: 'POST',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ ref: `refs/heads/${newBranchName}`, sha: sourceBranchSha })
            });
            if (!res.ok) throw new Error((await res.json()).message || '创建分支失败');
            showToast(`分支 &nbsp;${newBranchName}创建成功,请等待服务器刷新`);
            hideCreateBranchModal();
            await fetchRepos(true);
            if (state.currentRepo === repo.full_name) {
                await fetchBranches(repo);
                renderBranchSwitcher();
            }
        } catch (e) {
            showToast(`创建失败: ${e.message}`);
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '创建分支';
        }
    };
    uiStateStack.push(hideCreateBranchModal);
}

function showRenameRepoModal(repo) {
    const renameTitleText = el.renameTitle.querySelector('.modal-title-text');
    renameTitleText.textContent = `重命名仓库: ${repo.name}`;
    el.renameWarn.innerHTML = `<textarea id="newRepoDesc" placeholder="仓库描述（可选）" style="width: 100%; min-height: 70px; margin-top: 10px;">${repo.description || ''}</textarea>`;
    el.renameWarn.style.display = 'block';
    el.renameInput.value = repo.name;
    el.renameConfirm.disabled = true;
    el.renameModal.classList.remove('hidden');
    const descTextarea = document.getElementById('newRepoDesc');
    const updateButtonState = () => {
        const newName = el.renameInput.value.trim();
        const newDesc = descTextarea.value.trim();
        const nameChanged = newName !== repo.name;
        const descChanged = newDesc !== (repo.description || '');
        const isModified = nameChanged || descChanged;
        el.renameConfirm.disabled = !isModified || !newName;
    };
    el.renameInput.oninput = updateButtonState;
    descTextarea.oninput = updateButtonState;
    el.renameConfirm.onclick = async function() {
        const newName = el.renameInput.value.trim();
        const newDesc = descTextarea.value.trim();
        if (newName === repo.name && newDesc === (repo.description || '')) return;
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                method: 'PATCH',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName, description: newDesc })
            });
            if (!res.ok) throw new Error((await res.json()).message || '修改失败');
            showToast(`保存成功`);
            hideRenameModal();
            await fetchRepos(true);
        } catch (e) {
            showToast(`修改失败: ${e.message}`);
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '确认';
            el.renameWarn.style.display = 'none';
            el.renameWarn.innerHTML = '';
        }
    };
    uiStateStack.push(hideRenameModal);
}

function showDeleteRepoModal(repo) {
    showDeleteModal(null, false, '确认删除仓库', `确定要删除仓库 "${repo.name}" 吗？此操作不可撤销！`, async () => {
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                method: 'DELETE',
                headers: { 'Authorization': `token ${state.token}` }
            });
            if (!res.ok) throw new Error((await res.json()).message || '删除失败');
            showToast(`仓库 "${repo.name}" 已删除`);
            fetchRepos(true);
        } catch (e) {
            showToast(`删除失败: ${e.message}`);
        }
    });
}

function hideDeleteModal() {
    el.deleteModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideDeleteModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showDeleteModal(item, isDir = false, title, description, onConfirm) {
    el.deleteTitle.querySelector('.modal-title-text').textContent = title || '确认删除';
    if (item) {
        isDir = item.type === 'dir';
        el.deleteDesc.textContent = description || (isDir ? `确定要删除文件夹 "${item.name}" 吗？这将删除其所有内容。` : `确定要删除文件 "${item.name}" 吗？此操作不可撤销。`);
    } else {
        el.deleteDesc.textContent = description;
    }
    el.deleteModal.classList.remove('hidden');
    el.deleteConfirm.onclick = async function() {
        const confirmBtn = this;
        confirmBtn.disabled = true;
        confirmBtn.classList.add('btn-processing');
        confirmBtn.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            if (onConfirm) {
                await onConfirm();
            } else if (item) {
                await deleteSingleItem(item);
                showToast(`"${escapeHtml(item.name)}" 已删除`);
                fetchFiles(true);
            }
        } catch (error) {
            showToast(`删除失败: ${error.message}`);
        } finally {
            hideDeleteModal();
            confirmBtn.disabled = false;
            confirmBtn.classList.remove('btn-processing');
            confirmBtn.innerHTML = '确认删除';
        }
    };
    uiStateStack.push(hideDeleteModal);
}

function goUp() {
    history.back();
}

function closeProxySettingsModal() {
    el.proxySettingsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeProxySettingsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function openProxySettingsModal() {
    updateProxySettingsUI();
    renderProxyList();
    el.proxySettingsModal.classList.remove('hidden');
    uiStateStack.push(closeProxySettingsModal);
}

function updateProxySettingsUI() {
    updateProxyUI();
    const isAutoSelectEnabled = !!state.autoSelectProxy;
    el.proxyAutoSelectToggle.classList.toggle('active', isAutoSelectEnabled);
    el.proxyAutoSelectToggle.title = isAutoSelectEnabled ? '自动优选代理已开启' : '自动优选代理已关闭';
}

async function testProxyConnectivity(proxyDetails) {
   const testRawUrl = PROXY_TEST_URL;
    let proxiedTestUrl = '';
    const proxyInputUrl = (proxyDetails.url || '').trim();
    const proxyDomain = getDomainFromUrl(proxyInputUrl);
    if (!proxyInputUrl) return { ok: false, ms: null, err: 'URL为空', type: proxyDetails.type };
    if (proxyDetails.type === 'prefix') {
        let base = proxyInputUrl;
        if (!base.endsWith('/')) base += '/';
        proxiedTestUrl = base + testRawUrl;
    } else if (proxyDetails.type === 'raw_domain_replace') {
        proxiedTestUrl = testRawUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
        if (!proxiedTestUrl.startsWith('http')) proxiedTestUrl = 'https://' + proxiedTestUrl;
    } else {
        return { ok: false, ms: null, err: '未知测试类型', type: proxyDetails.type };
    }
    const start = performance.now();
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000);
        const r = await fetch(proxiedTestUrl, { method: 'GET', cache: 'no-store', signal: controller.signal });
        clearTimeout(timeoutId);
        if (!r.ok) {
            console.error(`Proxy test failed for ${proxyDetails.url} (${proxyDetails.type}): HTTP ${r.status}`);
            return { ok: false, ms: null, err: '连接失败 (404)', type: proxyDetails.type };
        }
        await r.text();
        return { ok: true, ms: Math.round(performance.now() - start), err: null, type: proxyDetails.type };
    } catch (e) {
        let errorMsg = '连接失败 (404)';
        if (e.name === 'AbortError') errorMsg = '连接失败 (超时)';
        else if (e.message.includes('Failed to fetch')) errorMsg = '连接失败 (网络错误)';
        return { ok: false, ms: null, err: errorMsg, type: proxyDetails.type };
    }
}

async function determineBestProxyTypeAndTest(proxyUrl) {
    const results = await Promise.all([
        testProxyConnectivity({ url: proxyUrl, type: 'prefix' }),
        testProxyConnectivity({ url: proxyUrl, type: 'raw_domain_replace' })
    ]);
    let bestResult = { ok: false, ms: null, err: '所有模式均失败', type: null };
    let prefixResult = results[0];
    let rawDomainResult = results[1];
    if (prefixResult.ok && rawDomainResult.ok) {
        bestResult = prefixResult.ms < rawDomainResult.ms ? prefixResult : rawDomainResult;
    } else if (prefixResult.ok) {
        bestResult = prefixResult;
    } else if (rawDomainResult.ok) {
        bestResult = rawDomainResult;
    } else {
        bestResult = prefixResult;
    }
    return bestResult;
}

function renderProxyList() {
    const container = el.proxyListContainer;
    container.innerHTML = '';
    if (state.proxies.length === 0) {
        el.proxyListEmpty.classList.remove('hidden');
        el.proxyTestAllBtn.disabled = true;
        el.proxyClearAllBtn.disabled = true;
        el.proxyAutoSelectToggle.disabled = true;
    } else {
        el.proxyListEmpty.classList.add('hidden');
        el.proxyTestAllBtn.disabled = false;
        el.proxyClearAllBtn.disabled = false;
        el.proxyAutoSelectToggle.disabled = false;
    }
    state.proxies.forEach((proxy, index) => {
        const proxyItem = document.createElement('div');
        proxyItem.className = 'proxy-item';
        if (index === state.activeProxyIndex) proxyItem.classList.add('active');
        let statusClass = 'gray', latencyText = '未测试';
        if (proxy.status === 'testing') {
            latencyText = `<span class="spinner-small"></span>`;
        } else if (proxy.status === 'ok') {
            latencyText = `${proxy.latency} ms`;
            if (proxy.latency <= 500) statusClass = 'green';
            else if (proxy.latency <= 2000) statusClass = 'yellow';
            else statusClass = 'red';
        } else if (proxy.status === 'fail') {
            statusClass = 'red';
            latencyText = '失败';
        }
        proxyItem.innerHTML = `
            <div class="proxy-identity">
                <span class="status-dot ${statusClass}"></span>
                <span class="proxy-url" title="${proxy.url || ''}">${getDomainFromUrl(proxy.url) || '无效URL'}</span>
            </div>
            <div class="proxy-status-actions">
                <span class="latency-text ${statusClass}">${latencyText}</span>
                <div class="proxy-actions">
                    <button class="btn-icon-sm edit-proxy-btn" data-index="${index}" title="编辑"><i class="fa fa-pencil"></i></button>
                    <button class="btn-icon-sm delete-proxy-btn danger" data-index="${index}" title="删除"><i class="fa fa-trash"></i></button>
                </div>
            </div>
        `;
        proxyItem.addEventListener('click', (e) => {
            if (e.target.closest('.edit-proxy-btn, .delete-proxy-btn')) return;
            if (index === state.activeProxyIndex) return;
            setActiveProxy(index);
        });
        container.appendChild(proxyItem);
    });
    container.querySelectorAll('.edit-proxy-btn').forEach(button => {
        button.onclick = (e) => { e.stopPropagation(); openAddEditProxyModal(parseInt(e.currentTarget.dataset.index)); };
    });
    container.querySelectorAll('.delete-proxy-btn').forEach(button => {
        button.onclick = (e) => { e.stopPropagation(); showConfirmDeleteProxyModal(parseInt(e.currentTarget.dataset.index)); };
    });
    saveProxyConfig();
}

function saveProxyConfig() {
    localStorage.setItem('proxies', JSON.stringify(state.proxies));
    localStorage.setItem('active_proxy_index', JSON.stringify(state.activeProxyIndex));
    localStorage.setItem('proxy_global_enable', JSON.stringify(state.proxyGlobalEnable));
    updateProxyUI();
}

function openAddEditProxyModal(index = null) {
    state.editingProxyIndex = index;
    const modal = el.addEditProxyModal;
    const titleTextSpan = el.addEditProxyTitle.querySelector('.modal-title-text');
    const urlInput = el.addEditProxyUrlInput;
    const saveBtn = el.addEditProxySaveBtn;
    const cancelBtn = document.getElementById('addEditProxyCancelBtn');
    urlInput.value = '';
    el.addEditProxyError.style.display = 'none';
    if (index !== null && state.proxies[index]) {
        const proxy = state.proxies[index];
        titleTextSpan.textContent = '编辑代理';
        urlInput.value = proxy.url;
        urlInput.placeholder = '修改代理地址';
    } else {
        titleTextSpan.textContent = '添加新代理';
        urlInput.placeholder = '例如：https://ghproxy.net/';
    }
    cancelBtn.onclick = closeAddEditProxyModal;
    saveBtn.onclick = null; 
    modal.classList.remove('hidden');
    validateAddEditProxyInput();
    uiStateStack.push(closeAddEditProxyModal);
}

function closeAddEditProxyModal() {
    el.addEditProxyModal.classList.add('hidden');
    state.editingProxyIndex = null;
    el.addEditProxySaveBtn.disabled = false;
    el.addEditProxySaveBtn.classList.remove('btn-processing');
    el.addEditProxySaveBtn.innerHTML = '保存';
    const index = uiStateStack.indexOf(closeAddEditProxyModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function validateAddEditProxyInput() {
    const url = el.addEditProxyUrlInput.value.trim();
    const saveBtn = el.addEditProxySaveBtn;
    let fullUrl = url;
    if (url && !/^https?:\/\//i.test(fullUrl)) fullUrl = 'https://' + fullUrl;
    const isDuplicate = state.proxies.some((proxy, index) => {
        if (state.editingProxyIndex !== null && index === state.editingProxyIndex) return false;
        let existingUrl = proxy.url;
        if (!/^https?:\/\//i.test(existingUrl)) existingUrl = 'https://' + existingUrl;
        return existingUrl === fullUrl;
    });
    if (!url) {
        saveBtn.disabled = true;
        saveBtn.onclick = null;
    } else if (isDuplicate) {
        saveBtn.disabled = true;
        saveBtn.onclick = () => { showToast('该代理已存在'); };
    } else {
        saveBtn.disabled = false;
        saveBtn.onclick = handleSaveProxy;
    }
    return !isDuplicate && !!url;
}

async function handleSaveProxy() {
    let url = el.addEditProxyUrlInput.value.trim();
    if (url && !/^https?:\/\//i.test(url)) url = 'https://' + url;
    const isEditing = state.editingProxyIndex !== null;
    let indexToTest;
    if (isEditing) {
        indexToTest = state.editingProxyIndex;
        const proxyToEdit = state.proxies[indexToTest];
        proxyToEdit.url = url;
        proxyToEdit.status = 'testing';
        proxyToEdit.latency = null;
        proxyToEdit.err = null;
        proxyToEdit.type = null;
        showToast('代理已更新，正在重新测试...');
    } else {
        const newProxy = { url: url, status: 'testing', latency: null, err: null, type: null };
        state.proxies.unshift(newProxy); 
        indexToTest = 0;
        showToast('代理已添加，正在后台测试...');
    }
    closeAddEditProxyModal();
    renderProxyList();
    const proxyToTest = state.proxies[indexToTest];
    if (!proxyToTest) return;
    const result = await determineBestProxyTypeAndTest(proxyToTest.url);
    proxyToTest.latency = result.ms;
    proxyToTest.status = result.ok ? 'ok' : 'fail';
    proxyToTest.err = result.err;
    proxyToTest.type = result.type;
    renderProxyList();
}

function showConfirmDeleteProxyModal(index) {
    const proxy = state.proxies[index];
    el.confirmDeleteProxyTitle.querySelector('.modal-title-text').textContent = '确认删除代理';
    el.confirmDeleteProxyMessage.innerHTML = `确定要删除代理 <strong>"${escapeHtml(proxy.url)}"</strong> 吗？此操作不可撤销。`;
    el.confirmDeleteProxyModal.classList.remove('hidden');
    el.confirmDeleteProxyConfirmBtn.onclick = null;
    el.confirmDeleteProxyCancelBtn.onclick = null;
    el.confirmDeleteProxyConfirmBtn.onclick = async () => {
        el.confirmDeleteProxyConfirmBtn.disabled = true;
        el.confirmDeleteProxyConfirmBtn.classList.add('btn-processing');
        el.confirmDeleteProxyConfirmBtn.innerHTML = `删除中 <span class="spinner-small"></span>`;
        try {
            await deleteProxy(index);
            hideConfirmDeleteProxyModal();
        } finally {
            el.confirmDeleteProxyConfirmBtn.disabled = false;
            el.confirmDeleteProxyConfirmBtn.classList.remove('btn-processing');
            el.confirmDeleteProxyConfirmBtn.innerHTML = '确认删除';
        }
    };
    el.confirmDeleteProxyCancelBtn.onclick = hideConfirmDeleteProxyModal;
    uiStateStack.push(hideConfirmDeleteProxyModal);
}

function hideConfirmDeleteProxyModal() {
    el.confirmDeleteProxyModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideConfirmDeleteProxyModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showConfirmClearAllProxiesModal() {
    el.confirmClearAllProxiesModal.classList.remove('hidden');
    el.clearAllProxiesConfirmBtn.disabled = false;
    el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
    uiStateStack.push(hideConfirmClearAllProxiesModal);
}

function hideConfirmClearAllProxiesModal() {
    el.confirmClearAllProxiesModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideConfirmClearAllProxiesModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function clearAllProxiesConfirmed() {
    el.clearAllProxiesConfirmBtn.disabled = true;
    el.clearAllProxiesConfirmBtn.classList.add('btn-processing');
    el.clearAllProxiesConfirmBtn.innerHTML = `清空中 <span class="spinner-small"></span>`;
    state.proxies = [];
    state.activeProxyIndex = -1;
    showToast('所有代理已清空');
    hideConfirmClearAllProxiesModal();
    renderProxyList();
    el.clearAllProxiesConfirmBtn.disabled = false;
    el.clearAllProxiesConfirmBtn.classList.remove('btn-processing');
    el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
}

async function deleteProxy(index) {
    state.proxies.splice(index, 1);
    if (state.activeProxyIndex === index) {
        state.activeProxyIndex = state.proxies.length > 0 ? 0 : -1;
    } else if (state.activeProxyIndex > index) {
        state.activeProxyIndex--;
    }
    showToast('代理已删除');
    renderProxyList();
}

function setActiveProxy(index) {
    if (index < 0 || index >= state.proxies.length) return;
    state.proxyGlobalEnable = true;
    if (state.activeProxyIndex === index) {
        saveProxyConfig();
        return;
    }
    state.activeProxyIndex = index;
    showToast(`已切换全局代理`);
    renderProxyList();
    if (state.currentRepo) {
        fetchFiles(true);
    }
}

async function testSingleProxy(index) {
    if (index < 0 || index >= state.proxies.length) return;
    const proxy = state.proxies[index];
    proxy.status = 'testing';
    proxy.latency = null;
    proxy.err = null;
    proxy.type = null;
    renderProxyList();
    const result = await determineBestProxyTypeAndTest(proxy.url);
    proxy.latency = result.ms;
    proxy.status = result.ok ? 'ok' : 'fail';
    proxy.err = result.err;
    proxy.type = result.type;
    renderProxyList();
}

async function testAllProxies() {
    if (state.proxies.length === 0) {
        showToast('没有代理可供测试');
        return;
    }
    el.proxyTestAllBtn.disabled = true;
    el.proxyTestAllSpinner.classList.remove('hidden');
    showToast(`开始测试 ${state.proxies.length} 个代理`);
    state.proxies.forEach(proxy => {
        proxy.status = 'testing';
        proxy.latency = null;
        proxy.err = null;
        proxy.type = null;
    });
    renderProxyList();
    const testPromises = state.proxies.map(proxy => determineBestProxyTypeAndTest(proxy.url));
    const results = await Promise.allSettled(testPromises);
    results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
            const data = result.value;
            state.proxies[index].latency = data.ms;
            state.proxies[index].status = data.ok ? 'ok' : 'fail';
            state.proxies[index].err = data.err;
            state.proxies[index].type = data.type;
        } else {
            state.proxies[index].status = 'fail';
            state.proxies[index].err = '测试脚本错误';
        }
    });
    renderProxyList();
    el.proxyTestAllBtn.disabled = false;
    el.proxyTestAllSpinner.classList.add('hidden');
}

async function clearCache() {
    localStorage.removeItem('cached_repos');
    localStorage.removeItem('repos_cache_time');
    state.fileCache.clear();
    showToast('缓存已清除');
    if (state.currentRepo) {
        await fetchFiles(true);
    } else {
        await fetchRepos();
    }
    hideMainMenuPopup();
}

async function findAndSetBestProxy(manual = false) {
    if (manual) showToast('手动导入并测试所有节点…');
    let directConnectResult = { ok: false, ms: Infinity, err: 'N/A' };
    let proxyListText = '';
    try {
        let testRawUrl = PROXY_TEST_URL;
        const start = performance.now();
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000);
        const res = await fetch('https://gh-proxy.com/' + testRawUrl, { method: 'GET', cache: 'no-store', signal: controller.signal });
        clearTimeout(timeoutId);
        if (res.ok) {
            directConnectResult = { ok: true, ms: Math.round(performance.now() - start), err: null };
            proxyListText = await res.text();
        } else {
            directConnectResult = { ok: false, ms: Infinity, err: `HTTP ${res.status}` };
            if (manual) showToast(`导入失败，无法获取远程列表: ${directConnectResult.err}`);
        }
    } catch (e) {
        let errorMsg = '网络错误';
        if (e.name === 'AbortError') errorMsg = '连接超时';
        directConnectResult = { ok: false, ms: Infinity, err: errorMsg };
        if (manual) showToast(`导入失败: ${errorMsg}`);
    }
    if (proxyListText) {
        const list = proxyListText.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#') && l.length > 5).filter(u => !state.proxies.some(p => p.url.replace(/\/$/, '') === u.replace(/\/$/, '')));
        if (list.length > 0) {
            const newProxies = list.map(url => ({ url, latency: null, status: null, err: null, type: null }));
            state.proxies.push(...newProxies);
            state.activeProxyIndex = state.activeProxyIndex < 0 ? 0 : state.activeProxyIndex;
            if (manual) showToast(`成功新增 ${list.length} 个代理`);
        } else {
            if (manual) showToast('无新的代理可导入');
        }
    }
    await testAllProxies();
    let bestLatency = directConnectResult.ok ? directConnectResult.ms : Infinity;
    let bestChoice = { type: 'direct', index: -1 };
    state.proxies.forEach((proxy, index) => {
        if (proxy.status === 'ok' && proxy.latency < bestLatency) {
            bestLatency = proxy.latency;
            bestChoice = { type: 'proxy', index: index };
        }
    });
    if (bestChoice.type === 'proxy') {
        setActiveProxy(bestChoice.index);
        const bestProxy = state.proxies[bestChoice.index];
        showToast(`已选择最佳代理`);
    } else {
        state.proxyGlobalEnable = false;
        localStorage.setItem('proxy_global_enable', 'false');
        updateProxyUI();
        if (bestLatency !== Infinity) {
            showToast(`直连速度最快 &nbsp;${bestLatency}ms`);
        } else {
            showToast('所有代理及直连均不可用。');
        }
    }
}

async function handleRefreshApiStatus() {
    const refreshBtn = el.refreshApiStatusBtn;
    const icon = refreshBtn.querySelector('i');
    refreshBtn.disabled = true;
    icon.classList.add('fa-spin-custom');
    try {
        await fetchAndRenderApiStatus();
    } catch (error) {
        console.error("手动刷新API状态时出错:", error);
    } finally {
        refreshBtn.disabled = false;
        icon.classList.remove('fa-spin-custom');
    }
}

const closeMultiSelect = () => toggleMultiSelectMode(false);

function toggleMultiSelectMode(enable) {
    state.isMultiSelectMode = enable;
    const fileListEl = el.fileList;
    const toggleBtn = el.multiSelectToggleBtn;
    if (enable) {
        fileListEl.classList.add('multi-select-mode');
        el.multiSelectBar.classList.add('active');
        toggleBtn.classList.add('active');
        toggleBtn.title = '取消多选';
        uiStateStack.push(closeMultiSelect);
    } else {
        fileListEl.classList.remove('multi-select-mode');
        el.multiSelectBar.classList.remove('active');
        toggleBtn.classList.remove('active');
        toggleBtn.title = '多项选择';
        fileListEl.querySelectorAll('.file-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
        state.selectedItems.clear();
        const index = uiStateStack.indexOf(closeMultiSelect);
        if (index > -1) uiStateStack.splice(index, 1);
    }
    updateActionBar();
}

function updateActionBar() {
    const count = state.selectedItems.size;
    const total = state.displayFiles.length;
    el.selectedCountSpan.textContent = count > 0 ? `已选 ${count} / ${total} 项` : '未选择';
    el.downloadBtn.disabled = count === 0;
    el.deleteBtn.disabled = count === 0;
    el.invertSelectBtn.disabled = count === 0;
    const selectAllIcon = el.selectAllBtn.querySelector('i');
    if (total > 0 && count === total) {
        selectAllIcon.className = 'fa fa-minus-square-o';
        el.selectAllBtn.title = '取消全选';
    } else {
        selectAllIcon.className = 'fa fa-check-square-o';
        el.selectAllBtn.title = '全选';
    }
}

function previewMedia(file) {
    const rawUrl = file.download_url ? file.download_url : file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    const url = getProxiedUrl(rawUrl);
    const ext = file.name.split('.').pop()?.toLowerCase();
    const openPreview = () => {
        el.mediaPreview.classList.remove('hidden');
        uiStateStack.push(hideMediaPreview);
    };
    if (IMAGE_EXTS.includes(ext)) {
        el.mediaPreviewImg.src = url;
        el.mediaPreviewImg.style.display = '';
        el.mediaPreviewVideo.style.display = 'none';
        openPreview();
    } else if (VIDEO_EXTS.includes(ext)) {
        el.mediaPreviewVideo.src = url;
        el.mediaPreviewVideo.style.display = '';
        el.mediaPreviewImg.style.display = 'none';
        openPreview();
        el.mediaPreviewVideo.load();
    } else if (AUDIO_EXTS.includes(ext)) {
        const nameWithoutExt = file.name.substring(0, file.name.lastIndexOf('.'));
        if (window.audioManager) window.audioManager.play(url, nameWithoutExt);
    }
}

async function downloadSelectedItemsAsZip() {
    if (state.selectedItems.size === 0) return;
    showToast(`正在准备打包 ${state.selectedItems.size} 个项目...`);
    const zip = new JSZip();
    const [owner, repo] = state.currentRepo.split('/');
    const fetchFileContent = async (path) => {
        try {
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`;
            const res = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
            const data = await res.json();
            return atob(data.content);
        } catch (error) {
            console.error(`无法获取文件内容: ${path}`, error);
            return null;
        }
    };
    const addFolderToZip = async (folderPath, zipFolder) => {
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${folderPath}?ref=${state.currentBranch}`;
        const res = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
        const items = await res.json();
        for (const item of items) {
            if (item.type === 'file') {
                const content = await fetchFileContent(item.path);
                if (content !== null) zipFolder.file(item.name, content, { binary: true });
            } else if (item.type === 'dir') {
                await addFolderToZip(item.path, zipFolder.folder(item.name));
            }
        }
    };
    const rootFiles = state.files.filter(file => state.selectedItems.has(file.path));
    for (const item of rootFiles) {
        if (item.type === 'file') {
            const content = await fetchFileContent(item.path);
            if (content !== null) zip.file(item.name, content, { binary: true });
        } else if (item.type === 'dir') {
            await addFolderToZip(item.path, zip.folder(item.name));
        }
    }
    try {
        const content = await zip.generateAsync({ type: "blob" });
        const objectUrl = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = objectUrl;
        a.download = `${repo}-${state.currentBranch}-selection.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(objectUrl);
        showToast('打包完成，下载已开始！');
    } catch(e) {
        showToast(`打包失败: ${e.message}`);
    }
}

async function downloadFolderAsZip(folderItem) {
    if (folderItem.type !== 'dir') return;
    showToast(`正在打包文件夹 &nbsp;${folderItem.name}&nbsp;`);
    const zip = new JSZip();
    const [owner, repo] = state.currentRepo.split('/');
    const fetchFolderContents = async (path, zipFolder) => {
        try {
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`;
            const res = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
            if (!res.ok) throw new Error(`无法获取文件夹内容: ${path}`);
            const items = await res.json();
            for (const item of items) {
                if (item.type === 'file') {
                    const fileRes = await fetch(item.url, { headers: { 'Authorization': `token ${state.token}` } });
                    if (!fileRes.ok) continue;
                    const fileData = await fileRes.json();
                    if (fileData.content) zipFolder.file(item.name, atob(fileData.content), { binary: true });
                } else if (item.type === 'dir') {
                    await fetchFolderContents(item.path, zipFolder.folder(item.name));
                }
            }
        } catch (error) {
            console.error(`处理文件夹 &nbsp;${path}&nbsp; 失败:`, error);
            showToast(`打包文件夹出错: ${folderItem.name} 遇到问题`);
        }
    };
    try {
        await fetchFolderContents(folderItem.path, zip.folder(folderItem.name));
        const content = await zip.generateAsync({ type: "blob" });
        const objectUrl = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = objectUrl;
        a.download = `${folderItem.name}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(objectUrl);
        showToast(`文件夹 &nbsp;${folderItem.name}.zip&nbsp; 已开始下载！`);
    } catch (e) {
        showToast(`打包失败: ${e.message}`);
    }
}

function saveContextMenuSettings() {
    localStorage.setItem('context_menu_visibility', JSON.stringify(state.contextMenuVisibility));
}

function loadContextMenuSettings() {
    const savedSettings = JSON.parse(localStorage.getItem('context_menu_visibility'));
    state.contextMenuVisibility = JSON.parse(JSON.stringify(DEFAULT_MENU_VISIBILITY));
    if (savedSettings) {
        for (const category in state.contextMenuVisibility) {
            if (savedSettings[category]) {
                for (const action in state.contextMenuVisibility[category]) {
                    if (savedSettings[category][action] !== undefined) {
                        state.contextMenuVisibility[category][action] = savedSettings[category][action];
                    }
                }
            }
        }
    }
}

function renderContextMenuSettings(category) {
    const content = el.contextMenuSettingsContent;
    content.innerHTML = '';
    const settings = state.contextMenuVisibility[category];
    const definitions = CONTEXT_MENU_DEFINITIONS[category];
    definitions.forEach(item => {
        if (category === 'repo' && (item.action === 'copyMainSiteLink')) return;
        let labelText = item.text;
        if (category === 'repo' && item.action === 'setAsMainSite') {
            labelText = '设为网站/复制链接';
        }
        const isVisible = settings[item.action];
        const settingItem = document.createElement('div');
        settingItem.className = 'setting-item';
        settingItem.innerHTML = `
            <label for="toggle-${category}-${item.action}">${labelText}</label>
            <label class="switch">
                <input type="checkbox" id="toggle-${category}-${item.action}" data-category="${category}" data-action="${item.action}" ${isVisible ? 'checked' : ''}>
                <span class="slider round"></span>
            </label>
        `;
        content.appendChild(settingItem);
    });
}

function hideContextMenuSettingsModal() {
    el.contextMenuSettingsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideContextMenuSettingsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function openContextMenuSettingsModal() {
    el.contextMenuSettingsModal.classList.remove('hidden');
    const activeTab = el.contextMenuSettingsModal.querySelector('.context-menu-settings-tabs .tab-btn.active');
    if (activeTab) {
        const activeCategory = activeTab.dataset.tab;
        renderContextMenuSettings(activeCategory);
    } else {
        renderContextMenuSettings('file');
    }
    uiStateStack.push(hideContextMenuSettingsModal);
}

function loadLocalAvatar() {
    const savedAvatar = localStorage.getItem('user_avatar');
    if (savedAvatar) state.localAvatar = savedAvatar;
}

function handleAvatarChange(event) {
    const file = event.target.files[0];
    if (!file) return;
    if (!file.type.startsWith('image/')) {
        showToast('请选择一个图片文件');
        return;
    }
    if (file.size > 2 * 1024 * 1024) {
        showToast('图片文件不能超过 2MB');
        return;
    }
    const reader = new FileReader();
    reader.onload = () => {
        const base64String = reader.result;
        localStorage.setItem('user_avatar', base64String);
        state.localAvatar = base64String;
        updateUserUI();
        showToast('头像更新成功');
    };
    reader.onerror = () => { showToast('读取文件失败'); };
    reader.readAsDataURL(file);
}

function hideMediaPreview() {
    const preview = document.getElementById('mediaPreview');
    if (!preview.classList.contains('hidden')) {
        preview.classList.add('hidden');
        document.getElementById('mediaPreviewImg').src = '';
        const video = document.getElementById('mediaPreviewVideo');
        video.src = '';
        video.pause();
        const index = uiStateStack.indexOf(hideMediaPreview);
        if (index > -1) uiStateStack.splice(index, 1);
    }
}

function initMediaPreview() {
    const preview = document.getElementById('mediaPreview');
    const img = document.getElementById('mediaPreviewImg');
    const video = document.getElementById('mediaPreviewVideo');
    const audioExts = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];
    let audioManager = {
        audio: null,
        currentUrl: '',
        currentName: '',
        isPlaying: false,
        init() {
            if (!this.audio) {
                this.audio = new Audio();
                this.audio.preload = 'none';
                this.audio.crossOrigin = 'anonymous';
                this.audio.addEventListener('play', () => { this.isPlaying = true; });
                this.audio.addEventListener('pause', () => { this.isPlaying = false; });
                this.audio.addEventListener('ended', () => { this.isPlaying = false; showToast(`播放完成: ${this.currentName}`); });
                this.audio.addEventListener('error', (e) => { this.isPlaying = false; showToast('播放出错'); console.error('Audio error:', e); });
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && this.isPlaying && this.audio.paused) {
                        this.audio.play().catch(() => {});
                    }
                });
            }
        },
        play(url, name) {
            this.init();
            showToast(`正在播放: ${name}`);
            if (this.currentUrl === url) {
                if (this.audio.paused) { this.audio.play().catch(() => { showToast('播放失败'); }); }
                else { this.audio.pause(); showToast(`已暂停: ${name}`); }
                return;
            }
            this.currentUrl = url;
            this.currentName = name;
            this.audio.src = url;
            const playPromise = this.audio.play();
            if (playPromise !== undefined) {
                playPromise.catch((error) => { console.log('Autoplay prevented:', error); });
            }
        }
    };
    preview.onclick = function(e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        hideMediaPreview();
    };
    document.getElementById('fileList').addEventListener('click', function(e) {
        if (state.isMultiSelectMode) return;
        if (e.target.classList.contains('multi-select-checkbox')) return;
        if (e.target.closest('.flex.gap-1,button')) return;
        const item = e.target.closest('.file-item');
        if (!item) return;
        const name = item.querySelector('.file-name') ? item.querySelector('.file-name').textContent : '';
        const ext = name.split('.').pop()?.toLowerCase();
        const file = state.files.find(f => f.name === name);
        if (!file || file.type !== 'file') return;
        const raw = file.download_url ? file.download_url : file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const url = getProxiedUrl(raw);
        if (audioExts.includes(ext)) {
            const nameWithoutExt = name.substring(0, name.lastIndexOf('.'));
            audioManager.play(url, nameWithoutExt);
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        const openPreview = () => {
            preview.classList.remove('hidden');
            uiStateStack.push(hideMediaPreview);
            e.preventDefault();
            e.stopPropagation();
        };
        if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'].includes(ext)) {
            img.src = url;
            img.style.display = '';
            video.style.display = 'none';
            openPreview();
            return;
        }
        if (['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'].includes(ext)) {
            video.src = url;
            video.style.display = '';
            img.style.display = 'none';
            openPreview();
            video.load();
            return;
        }
    }, true);
}

function hideCreateRepoModal() {
    el.createRepoModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateRepoModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateRepoModal() {
    el.createRepoNameInput.value = '';
    el.createRepoDescInput.value = '';
    el.createRepoPrivate.checked = true;
    el.repoNameError.style.display = 'none';
    el.createRepoModal.classList.remove('hidden');
    el.createRepoConfirm.disabled = true;
    function validateRepoName(name) {
        if (/[\u4e00-\u9fa5]/.test(name)) return '仓库名称不能包含中文字符';
        if (name.length > 100) return '仓库名称不能超过100个字符';
        if (name.startsWith('.') || name.endsWith('.')) return '仓库名称不能以点号开头或结尾';
        return null;
    }
    el.createRepoNameInput.oninput = function() {
        this.value = this.value.replace(/[\u4e00-\u9fa5]/g, '');
        const name = el.createRepoNameInput.value.trim();
        const error = validateRepoName(name);
        if (error) {
            el.repoNameError.textContent = error;
            el.repoNameError.style.display = 'block';
            el.createRepoConfirm.disabled = true;
        } else {
            el.repoNameError.style.display = 'none';
            el.createRepoConfirm.disabled = !name;
        }
    };
    el.createRepoConfirm.onclick = async function() {
        const name = el.createRepoNameInput.value.trim();
        const description = el.createRepoDescInput.value.trim();
        const isPrivate = !el.createRepoPrivate.checked;
        const error = validateRepoName(name);
        if (error || !name) return;
        el.createRepoConfirm.disabled = true;
        el.createRepoConfirm.classList.add('btn-processing');
        el.createRepoConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch('https://api.github.com/user/repos', {
                method: 'POST',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                body: JSON.stringify({ name: name, description: description || undefined, private: isPrivate, auto_init: true })
            });
            if (!res.ok) throw new Error((await res.json()).message || '创建仓库失败');
            await res.json();
            showToast(`仓库 "${name}" 创建成功`);
            hideCreateRepoModal();
            fetchRepos(true);
        } catch (e) {
            showToast(`创建失败: ${e.message}`);
        } finally {
            el.createRepoConfirm.disabled = false;
            el.createRepoConfirm.classList.remove('btn-processing');
            el.createRepoConfirm.innerHTML = '创建仓库';
        }
    };
    uiStateStack.push(hideCreateRepoModal);
}

function hideApiStatusPanel() {
    el.apiStatusOverlay.classList.remove('open');
    el.apiStatusPanel.classList.remove('open');
    setTimeout(() => {
        el.apiStatusOverlay.classList.add('hidden');
    }, 300);
    const index = uiStateStack.indexOf(hideApiStatusPanel);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showApiStatusPanel() {
    el.apiStatusOverlay.classList.remove('hidden');
    setTimeout(() => {
        el.apiStatusOverlay.classList.add('open');
        el.apiStatusPanel.classList.add('open');
    }, 10);
    fetchAndRenderApiStatus();
    uiStateStack.push(hideApiStatusPanel);
}

async function fetchAndRenderApiStatus() {
    el.apiStatusContent.innerHTML = `<div class="loading-spinner" style="height: auto; padding: 2rem 0;"><div class="spinner"></div></div>`;
    try {
        const res = await fetch('https://api.github.com/rate_limit', {
            headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
        });
        if (!res.ok) throw new Error(`请求失败: ${res.status}`);
        const scopes = res.headers.get('x-oauth-scopes') || '无特定权限';
        const data = await res.json();
        let contentHTML = '';
        const tokenScopesCardHTML = `
        <div class="api-status-card">
            <h4><i class="fa fa-key"></i>Token 权限 (Scopes)</h4>
            <div class="token-scopes">
                ${scopes.split(', ').map(scope => `<span class="token-scope">${scope}</span>`).join('')}
            </div>
        </div>`;
        const resources = ['core'];
        resources.forEach(key => {
            const resource = data.resources[key];
            if (!resource) return;
            const used = resource.used;
            const limit = resource.limit;
            const remaining = resource.remaining;
            const percentage = limit > 0 ? (used / limit) * 100 : 0;
            let progressClass = 'progress-green';
            if (percentage > 95) progressClass = 'progress-red';
            else if (percentage > 75) progressClass = 'progress-yellow';
            const resetTime = new Date(resource.reset * 1000).toLocaleTimeString();
            contentHTML += `
            <div class="api-status-card">
                <h4><i class="fa fa-cogs"></i>${key.charAt(0).toUpperCase() + key.slice(1)} API</h4>
                <div class="rate-limit-progress-bar">
                    <div class="${progressClass}" style="width: ${percentage}%;"></div>
                </div>
                <div class="rate-limit-details">
                    <p>已用: <span>${used}</span> / ${limit}</p>
                    <p>剩余: <span>${remaining}</span></p>
                    <p>重置时间: <span>${resetTime}</span></p>
                </div>
            </div>`;
        });
        const activeProxy = state.proxies[state.activeProxyIndex];
        contentHTML += `
        <div class="api-status-card">
            <h4><i class="fa fa-info-circle"></i>应用状态</h4>
            <div class="app-status-details">
                <p>文件缓存: <span>${state.fileCache.size} 个目录</span></p>
                <p>代理状态: <span>${state.proxyGlobalEnable && activeProxy ? `开启      ${getDomainFromUrl(activeProxy.url)}` : '关闭'}</span></p>
            </div>
        </div>
        `;
        contentHTML += tokenScopesCardHTML;
        el.apiStatusContent.innerHTML = contentHTML;
    } catch (error) {
        el.apiStatusContent.innerHTML = `<div class="api-status-card"><p style="color: #f87171;">加载失败: ${error.message}</p></div>`;
    }
}

function setupEventListeners() {
    const getTokenBtn = document.getElementById('getTokenBtn');
    if (getTokenBtn) {
        getTokenBtn.addEventListener('click', function() {
            const urlToCopy = 'https://github.com/settings/tokens/new';
            const btn = this;
            const btnText = btn.querySelector('span');
            const icon = btn.querySelector('i');
            
            const originalText = '复制链接'; 
            const originalIconClass = 'fa fa-clipboard';
            const successText = '已复制!';
            const successIconClass = 'fa fa-check';

            btn.disabled = true;
            btnText.textContent = successText;
            if (icon) {
                icon.className = successIconClass;
            }

            navigator.clipboard.writeText(urlToCopy).then(() => {
                showToast('复制成功');
                
                setTimeout(() => {
                    btnText.textContent = originalText;
                    if (icon) {
                        icon.className = originalIconClass;
                    }
                    btn.disabled = false;
                }, 2000);
            }).catch(err => {
                showToast(`复制失败: ${err.message || '请检查浏览器权限'}`);
                btnText.textContent = originalText;
                if (icon) {
                    icon.className = originalIconClass;
                }
                btn.disabled = false;
            });
        });
    }
    
    el.proxyQuickToggle.addEventListener('click', () => {
        setProxyGlobalState(!state.proxyGlobalEnable, true);
    });
    el.proxyGlobalEnableToggle.addEventListener('change', (e) => {
        setProxyGlobalState(e.target.checked, true);
    });
    el.refreshApiStatusBtn.addEventListener('click', handleRefreshApiStatus);
    el.headerGithubIcon.addEventListener('click', showApiStatusPanel);
    el.closeApiStatusPanel.addEventListener('click', hideApiStatusPanel);
    el.apiStatusOverlay.addEventListener('click', hideApiStatusPanel);
    el.avatarContainer.addEventListener('click', () => {
        el.avatarUploadInput.click();
    });
    el.avatarUploadInput.addEventListener('change', handleAvatarChange);
    el.importBtn.addEventListener('click', () => findAndSetBestProxy(true));
    el.newFolderBtn.onclick = function() {
        if (!state.currentRepo) {
            showCreateRepoModal();
        } else {
            showCreateFolderModal();
        }
    };
    el.authBtn.addEventListener('click', async () => {
        const token = el.tokenInput.value.trim();
        const btn = el.authBtn;
        const btnText = btn.querySelector('span');
        const spinner = btn.querySelector('i');
        btn.classList.remove('success', 'error');
        el.tokenInput.classList.remove('error');
        if (!token) {
            showToast('请输入GitHub访问令牌');
            el.tokenInput.classList.add('error');
            btn.classList.add('error');
            return;
        }
        btn.disabled = true;
        btnText.textContent = '正在验证';
        spinner.classList.remove('hidden');
        try {
            const res = await fetch('https://api.github.com/user', {
                headers: { Authorization: `token ${token}` }
            });
            if (!res.ok) {
                if (res.status === 401) {
                    throw new Error('令牌无效或已过期');
                }
                throw new Error(`验证失败: ${res.statusText}`);
            }
            btn.classList.add('success');
            btnText.textContent = '登录成功 ✓';
            spinner.classList.add('hidden');
            localStorage.setItem('gh_token', token);
            state.token = token;
            await Promise.all([
                fetchUserInfo(), 
                fetchRepos(true)
            ]);
            setTimeout(async () => {
                showApp();
                showToast('欢迎回来！');
                await Promise.all([fetchRepos(), fetchUserInfo()]);
                if (state.autoSelectProxy) findAndSetBestProxy();
                btn.disabled = false;
                btnText.textContent = '登录';
                btn.classList.remove('success');
            }, 1000);
        } catch (error) {
            showToast(error.message || '网络连接失败，请重试');
            el.tokenInput.classList.add('error');
            btn.classList.add('error');
            btn.disabled = false;
            btnText.textContent = '登录';
            spinner.classList.add('hidden');
        }
    });
    el.mainMenuBtn.onclick = (e) => {
        e.stopPropagation();
        hideContextMenu();
        if (el.mainMenuPopup.classList.contains('hidden')) {
            showMainMenuPopup();
        } else {
            hideMainMenuPopup();
        }
    };
    el.createBranchCancel.onclick = function() {
        hideCreateBranchModal();
    };
    el.cancelSelectBtn.addEventListener('click', () => toggleMultiSelectMode(false));
    el.selectAllBtn.addEventListener('click', () => {
        const allVisiblePaths = state.displayFiles.map(f => f.path);
        const areAllSelected = allVisiblePaths.length > 0 && allVisiblePaths.every(path => state.selectedItems.has(path));
        allVisiblePaths.forEach(path => {
            if (areAllSelected) {
                state.selectedItems.delete(path);
            } else {
                state.selectedItems.add(path);
            }
        });
        renderFileList();
    });
    el.invertSelectBtn.addEventListener('click', () => {
        const allVisiblePaths = state.displayFiles.map(f => f.path);
        allVisiblePaths.forEach(path => {
            if (state.selectedItems.has(path)) {
                state.selectedItems.delete(path);
            } else {
                state.selectedItems.add(path);
            }
        });
        renderFileList();
    });
    el.downloadBtn.addEventListener('click', downloadSelectedItemsAsZip);
    el.deleteBtn.addEventListener('click', () => {
        if (state.selectedItems.size === 0) return;
        const selectedFiles = state.files.filter(f => state.selectedItems.has(f.path));
        const fileCount = selectedFiles.filter(f => f.type === 'file').length;
        const dirCount = selectedFiles.filter(f => f.type === 'dir').length;
        let desc = `确定要删除这 ${state.selectedItems.size} 个项目吗？`;
        if (fileCount > 0 && dirCount > 0) desc += ` (包含 ${fileCount} 个文件和 ${dirCount} 个文件夹)`;
        else if (fileCount > 0) desc += ` (共 ${fileCount} 个文件)`;
        else if (dirCount > 0) desc += ` (共 ${dirCount} 个文件夹)`;
        showDeleteModal(null, false, '确认批量删除', desc, async function() {
            showToast(`开始删除 ${selectedFiles.length} 个项目...`);
            for (const item of selectedFiles) {
                await deleteSingleItem(item);
            }
            showToast('批量删除完成！');
            toggleMultiSelectMode(false);
            fetchFiles(true);
        });
    });
    function handleInteractionToCloseMenu(e) {
        if (!el.contextMenu.classList.contains('hidden') && !el.contextMenu.contains(e.target)) {
            hideContextMenu();
        }
    }
    document.addEventListener('mousedown', handleInteractionToCloseMenu);
    document.addEventListener('touchstart', handleInteractionToCloseMenu, { passive: true });
    document.addEventListener('click', function(e) {
        if (!el.mainMenuPopup.classList.contains('hidden') && !el.mainMenuPopup.contains(e.target) && !e.target.closest('#mainMenuBtn')) {
            hideMainMenuPopup();
        }
        if (!el.customSortDropdown.classList.contains('hidden') && !el.customSortDropdown.contains(e.target) && !e.target.closest('#sortToggleBtn')) {
            hideSortDropdown();
        }
    });
    el.menuLogout.onclick = () => {
        hideMainMenuPopup();
        localStorage.removeItem('gh_token');
        localStorage.removeItem('user_avatar')
        localStorage.removeItem('cached_repos');
        localStorage.removeItem('repos_cache_time');
        state.token = null;
        state.repos = [];
        state.currentRepo = null;
        state.user = null;
        showAuth();
    };
    el.menuProxySettings.onclick = () => {
        hideMainMenuPopup();
        openProxySettingsModal();
    };
    el.menuClearCache.onclick = () => {
        hideMainMenuPopup();
        clearCache();
    };
    el.saveEdit.addEventListener('click', saveEditedFile);
    el.revertEditBtn.onclick = () => {
    if (el.fileContent.value !== state.originalContent) {
        el.fileContent.value = state.originalContent;
        checkContentChanges();
        showToast('已恢复至原始内容');
    }
};
    el.closeEditModal.onclick = hideEditModal;
    el.cancelEdit.onclick = hideEditModal;
    el.modalOverlay.addEventListener('click', (e) => {
        if (e.target === el.modalOverlay) hideModal();
    });
    el.backBtn.onclick = goUp;
    el.newFileBtn.onclick = showCreateFileModal;
    el.uploadBtn.onclick = handleUploadClick;
    el.fileUploadInput.addEventListener('change', handleFilesSelected);
    el.searchToggleBtn.addEventListener('click', () => {
        el.searchInput.classList.toggle('hidden');
        if (!el.searchInput.classList.contains('hidden')) {
            el.searchInput.focus();
            el.searchInput.style.display = 'block';
        } else {
            el.searchInput.value = '';
            state.searchQuery = '';
            applyFiltersAndSort();
            renderFileList();
            el.searchInput.style.display = 'none';
        }
    });
    if (el.searchInput) {
        el.searchInput.addEventListener('input', () => {
            state.searchQuery = el.searchInput.value || '';
            applyFiltersAndSort();
            renderFileList();
        });
    }
    el.multiSelectToggleBtn.onclick = () => {
        toggleMultiSelectMode(!state.isMultiSelectMode);
    };
    el.sortToggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (el.customSortDropdown.classList.contains('hidden')) {
            showSortDropdown();
        } else {
            hideSortDropdown();
        }
    });
    el.customSortDropdown.addEventListener('click', (e) => {
        const item = e.target.closest('.dropdown-item');
        if (!item) return;
        hideSortDropdown();
        const newSortBy = item.dataset.value;
        const newPriority = item.dataset.priority;
        if (newSortBy) {
            state.sortBy = newSortBy;
            localStorage.setItem('sort_by', state.sortBy);
        }
        if (newPriority) {
            state.directorySortPriority = newPriority;
            localStorage.setItem('directory_sort_priority', state.directorySortPriority);
        }
        updateSortDropdownUI();
        applyFiltersAndSort();
        renderFileList();
    });
    if (el.customSortDropdown) {
        Array.from(el.customSortDropdown.children).forEach(item => {
            if (item.dataset.value === state.sortBy) {
                item.classList.add('selected');
            }
        });
    }
    if (el.viewToggleBtn) {
        updateFileListViewMode();
        el.viewToggleBtn.addEventListener('click', () => {
            state.viewMode = state.viewMode === 'list' ? 'grid' : 'list';
            localStorage.setItem('view_mode', state.viewMode);
            updateFileListViewMode();
        });
    }
    el.proxyCancelSettingsBtn.addEventListener('click', closeProxySettingsModal);
    el.proxyAutoSelectToggle.addEventListener('click', () => {
        state.autoSelectProxy = !state.autoSelectProxy;
        localStorage.setItem('proxy_auto_select', JSON.stringify(state.autoSelectProxy));
        updateProxySettingsUI();
        if (state.autoSelectProxy) {
            showToast('已开启自动选择最优代理，下次进入生效');
        } else {
            showToast('已关闭自动优选代理');
        }
    });
    el.proxyAddBtn.addEventListener('click', () => openAddEditProxyModal());
    el.proxyTestAllBtn.addEventListener('click', testAllProxies);
    el.proxyClearAllBtn.addEventListener('click', showConfirmClearAllProxiesModal);
    el.addEditProxyUrlInput.addEventListener('input', validateAddEditProxyInput);
    el.confirmDeleteProxyCancelBtn.addEventListener('click', hideConfirmDeleteProxyModal);
    el.clearAllProxiesCancelBtn.addEventListener('click', hideConfirmClearAllProxiesModal);
    el.clearAllProxiesConfirmBtn.addEventListener('click', clearAllProxiesConfirmed);
    el.renameInput.oninput = function() {
        el.renameConfirm.disabled = !el.renameInput.value.trim() || el.renameInput.value.trim() === state.selectedFile?.name;
    };
    el.renameCancel.onclick = function() {
        hideRenameModal();
    };
    el.deleteCancel.onclick = function() {
        hideDeleteModal();
    };
    el.createRepoCancel.onclick = function() {
        hideCreateRepoModal();
    };
    el.createFolderInput.oninput = function() {
        el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
    };
    el.createFolderCancel.onclick = function() {
        hideCreateFolderModal();
    };
    el.createFileNameInput.oninput = function() {
        el.createFileConfirm.disabled = !el.createFileNameInput.value.trim() || el.createFileNameInput.value.trim().endsWith('/');
    };
    el.createFileCancel.onclick = function() {
        hideCreateFileModal();
    };
    el.createBranchNameInput.oninput = function() {
        el.createBranchConfirm.disabled = !el.createBranchNameInput.value.trim();
    }
    el.menuContextMenuSettings.onclick = () => {
        hideMainMenuPopup();
        openContextMenuSettingsModal();
    };
    el.contextMenuSettingsCloseBtn.onclick = () => {
        hideContextMenuSettingsModal();
    };
    el.contextMenuSettingsModal.querySelector('.context-menu-settings-tabs').addEventListener('click', e => {
        if (e.target.matches('.tab-btn')) {
            const container = e.target.parentElement;
            container.querySelector('.active').classList.remove('active');
            e.target.classList.add('active');
            renderContextMenuSettings(e.target.dataset.tab);
        }
    });
    el.contextMenuSettingsContent.addEventListener('change', e => {
        if (e.target.matches('input[type="checkbox"]')) {
            const { category, action } = e.target.dataset;
            const isVisible = e.target.checked;
            state.contextMenuVisibility[category][action] = isVisible;
            if (action === 'setAsMainSite') {
                 state.contextMenuVisibility.repo.copyMainSiteLink = isVisible;
            }
            saveContextMenuSettings();
        }
    });
}

(function() {
    const config = {
        minFontSize: 1, maxFontSize: 99, defaultFontSize: 10,
        storageKey: 'editor-font-size', scaleSensitivity: 0.01
    };
    function getSavedFontSize() { return parseInt(localStorage.getItem(config.storageKey)) || config.defaultFontSize; }
    function saveFontSize(size) { localStorage.setItem(config.storageKey, size); }
    function createFontSizeDisplay() {
        const display = document.createElement('div');
        display.style.cssText = `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; padding: 6px 12px; border-radius: 12px; font-size: 12px; font-weight: bold; z-index: 1000; pointer-events: none; opacity: 0; transition: opacity 0.1s; background-color: rgba(0,0,0,0.5);`;
        return display;
    }
    function showFontSizeTooltip(display, size) {
        display.textContent = `${size}px`;
        display.style.opacity = '1';
        clearTimeout(display.hideTimeout);
        display.hideTimeout = setTimeout(() => { display.style.opacity = '0'; }, 1000);
    }
    function initGestureControls() {
        const observer = new MutationObserver(() => {
            const editModal = document.getElementById('editModal');
            const fileContent = document.getElementById('fileContent');
            const editorContainer = document.querySelector('.editor-container');
            if (editModal && fileContent && editorContainer && !fileContent.hasGestureControl) {
                fileContent.hasGestureControl = true;
                let currentSize = getSavedFontSize();
                fileContent.style.fontSize = currentSize + 'px';
                fileContent.style.lineHeight = (currentSize * 1.5) + 'px';
                const fontSizeDisplay = createFontSizeDisplay();
                editorContainer.appendChild(fontSizeDisplay);
                let initialDistance = 0, initialFontSize = currentSize, isPinching = false;
                function getTouchDistance(touches) { const dx = touches[0].clientX - touches[1].clientX, dy = touches[0].clientY - touches[1].clientY; return Math.sqrt(dx * dx + dy * dy); }
                function updateFontSize(newSize) {
                    newSize = Math.max(config.minFontSize, Math.min(config.maxFontSize, Math.round(newSize)));
                    if (newSize === currentSize) return;
                    const textarea = fileContent;
                    const oldScrollHeight = textarea.scrollHeight, oldScrollTop = textarea.scrollTop, viewportHeight = textarea.clientHeight;
                    const centerRatio = oldScrollHeight > viewportHeight ? (oldScrollTop + viewportHeight / 2) / oldScrollHeight : 0.5;
                    currentSize = newSize;
                    textarea.style.fontSize = newSize + 'px';
                    textarea.style.lineHeight = (newSize * 1.5) + 'px';
                    const newScrollHeight = textarea.scrollHeight;
                    const newScrollTop = (newScrollHeight * centerRatio) - (viewportHeight / 2);
                    textarea.scrollTop = newScrollTop;
                    showFontSizeTooltip(fontSizeDisplay, newSize);
                    saveFontSize(newSize);
                }
                fileContent.addEventListener('touchstart', (e) => { if (e.touches.length === 2) { e.preventDefault(); isPinching = true; initialDistance = getTouchDistance(e.touches); initialFontSize = currentSize; } }, { passive: false });
                fileContent.addEventListener('touchmove', (e) => { if (isPinching && e.touches.length === 2) { e.preventDefault(); const currentDistance = getTouchDistance(e.touches); const scale = currentDistance / initialDistance; const newSize = initialFontSize * scale; updateFontSize(newSize); } }, { passive: false });
                fileContent.addEventListener('touchend', () => { if (isPinching) isPinching = false; });
                fileContent.addEventListener('wheel', (e) => { if (e.ctrlKey || e.metaKey) { e.preventDefault(); const delta = e.deltaY > 0 ? -1 : 1; updateFontSize(currentSize + delta); } }, { passive: false });
                fileContent.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) { e.preventDefault(); updateFontSize(currentSize + 1); }
                    else if ((e.ctrlKey || e.metaKey) && e.key === '-') { e.preventDefault(); updateFontSize(currentSize - 1); }
                    else if ((e.ctrlKey || e.metaKey) && e.key === '0') { e.preventDefault(); updateFontSize(config.defaultFontSize); }
                });
                const editModalObserver = new MutationObserver(() => { if (!editModal.classList.contains('hidden')) { currentSize = getSavedFontSize(); fileContent.style.fontSize = currentSize + 'px'; fileContent.style.lineHeight = (currentSize * 1.5) + 'px'; } });
                editModalObserver.observe(editModal, { attributes: true, attributeFilter: ['class'] });
            }
        });
        observer.observe(document.body, { childList: true, subtree: true });
    }
    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initGestureControls); } else { initGestureControls(); }
})();

(function() {
    'use strict';
    const config = { buttonId: 'toggleMaximizeModal', modalId: 'editModal', closeButtonId: 'closeEditModal', maximizedClass: 'maximized', expandIcon: 'fa-expand', compressIcon: 'fa-compress', buttonTitle: { maximize: '最大化', restore: '恢复' } };
    let isMaximized = false, maximizeButton = null, editModal = null, isToggling = false, modalObserver = null;
    function createMaximizeButton() { const button = document.createElement('button'); button.id = config.buttonId; button.title = config.buttonTitle.maximize; button.innerHTML = `<i class="fa ${config.expandIcon}"></i>`; return button; }
    function toggleMaximize() {
        if (!editModal || !maximizeButton || isToggling) return;
        isToggling = true;
        const icon = maximizeButton.querySelector('i');
        if (isMaximized) {
            editModal.classList.remove(config.maximizedClass);
            icon.classList.remove(config.compressIcon); icon.classList.add(config.expandIcon);
            maximizeButton.title = config.buttonTitle.maximize; isMaximized = false;
            try { if (typeof window.adjustEditorDimensions === 'function') setTimeout(window.adjustEditorDimensions, 100); } catch (e) { console.error('调整编辑器尺寸时出错：', e); }
        } else {
            editModal.classList.add(config.maximizedClass);
            icon.classList.remove(config.expandIcon); icon.classList.add(config.compressIcon);
            maximizeButton.title = config.buttonTitle.restore; isMaximized = true;
        }
        try { localStorage.setItem('editor-maximized', isMaximized.toString()); } catch (e) { console.error('保存最大化状态失败：', e); }
        setTimeout(() => { isToggling = false; }, 300);
    }
    function restoreMaximizedState() { if (isToggling) return; try { if (localStorage.getItem('editor-maximized') === 'true' && editModal && !editModal.classList.contains('hidden') && !isMaximized) toggleMaximize(); } catch (e) { console.error('恢复最大化状态失败：', e); } }
    function resetMaximizedState() { if (isToggling) return; if (isMaximized) { isMaximized = true; toggleMaximize(); } }
    function initializeButton() {
        if (maximizeButton) return;
        if (!editModal) { editModal = document.getElementById(config.modalId); if (!editModal) return; }
        const modalHeader = editModal.querySelector('.modal-header'), closeButton = document.getElementById(config.closeButtonId);
        if (!modalHeader || !closeButton) return;
        let buttonContainer = modalHeader.querySelector('div:last-child');
        if (!buttonContainer || buttonContainer.style.display !== 'flex') { buttonContainer = document.createElement('div'); buttonContainer.style.cssText = 'display: flex; gap: 0.4rem;'; if (closeButton.parentNode === modalHeader) modalHeader.removeChild(closeButton); buttonContainer.appendChild(closeButton); modalHeader.appendChild(buttonContainer); }
        if (document.getElementById(config.buttonId)) { maximizeButton = document.getElementById(config.buttonId); } else { maximizeButton = createMaximizeButton(); buttonContainer.insertBefore(maximizeButton, closeButton); }
        maximizeButton.removeEventListener('click', toggleMaximize); maximizeButton.addEventListener('click', toggleMaximize);
        if (!modalObserver) { modalObserver = new MutationObserver((mutations) => { for (let mutation of mutations) { if (mutation.attributeName === 'class') { if (editModal.classList.contains('hidden')) resetMaximizedState(); else setTimeout(restoreMaximizedState, 100); } } }); modalObserver.observe(editModal, { attributes: true, attributeFilter: ['class'] }); }
    }
    function init() {
        const observer = new MutationObserver(() => { if (!maximizeButton || !document.getElementById(config.buttonId) || !document.getElementById(config.modalId)) initializeButton(); });
        observer.observe(document.body, { childList: true, subtree: true });
        initializeButton();
        document.addEventListener('keydown', (e) => { if (editModal && !editModal.classList.contains('hidden')) { if (e.key === 'F11' || (e.ctrlKey && e.shiftKey && e.key === 'M')) { e.preventDefault(); toggleMaximize(); } } });
    }
    init();
})();

async function init() {
    loadLocalAvatar();
    loadContextMenuSettings(); 
    document.getElementById('app').style.visibility = 'visible';
    if (state.token) {
        showApp();
        await fetchRepos();
        fetchUserInfo();
        const hasImportedThisSession = localStorage.getItem('initial_proxy_import_done');
        if (!hasImportedThisSession || state.autoSelectProxy) {
            setTimeout(() => findAndSetBestProxy(), 1000);
            localStorage.setItem('initial_proxy_import_done', 'true');
        } else {
            if (state.proxies.length > 0) {
                state.activeProxyIndex = parseInt(localStorage.getItem('active_proxy_index') || '0');
                state.proxyGlobalEnable = JSON.parse(localStorage.getItem('proxy_global_enable') || 'true');
            } else {
                state.proxyGlobalEnable = false;
            }
            saveProxyConfig();
        }
    } else {
        showAuth();
    }
    setupEventListeners();
    updateSortDropdownUI(); 
}

document.addEventListener('DOMContentLoaded', async function() {
    document.documentElement.style.userSelect = 'none';
    history.replaceState({ repo: null, path: '' }, '', window.location.pathname);
    await init();
    initMediaPreview();
    window.addEventListener('popstate', async (event) => {
        if (handleBackPress()) {
            return;
        }
        const historyState = event.state || {};
        state.currentRepo = historyState.repo;
        state.currentPath = historyState.path;
        if (!state.repos || state.repos.length === 0) {
            await fetchRepos(true);
        }
        if (state.currentRepo) {
            const repoData = state.repos.find(r => r.full_name === state.currentRepo);
            if (repoData) {
                state.currentBranch = historyState.branch || repoData.default_branch;
                const repoNameOnly = state.currentRepo.split('/')[1];
                el.currentRepo.textContent = repoNameOnly;
                renderPathNav();
                await fetchBranches(repoData);
                renderBranchSwitcher();
                await fetchFiles();
                toggleView(false);
            } else {
                showToast('仓库信息未找到，已返回仓库列表');
                showRepoListView();
            }
        } else {
            showRepoListView();
        }
    });
});
</script>
<script>
async function checkForUpdates() {
    const CONFIG_URL = 'https://raw.githubusercontent.com/rjdsq/rjdsq.github.io/main/proxy/version.json';
    const urlWithTimestamp = `${CONFIG_URL}?t=${new Date().getTime()}`;
    try {
        const finalUrl = getProxiedUrl(urlWithTimestamp);
        const response = await fetch(finalUrl);
        if (!response.ok) {
            throw new Error(`Failed to fetch version info: ${response.status}`);
        }
        const updateInfo = await response.json();
        if (isNewerVersion(updateInfo.version, CURRENT_VERSION)) {
            showUpdateDialog(updateInfo);
        }
    } catch (error) {
        console.error('Update check failed:', error);
    }
}

function isNewerVersion(remoteVersion, localVersion) {
    const remoteParts = remoteVersion.split('.').map(Number);
    const localParts = localVersion.split('.').map(Number);
    const len = Math.max(remoteParts.length, localParts.length);
    for (let i = 0; i < len; i++) {
        const remote = remoteParts[i] || 0;
        const local = localParts[i] || 0;
        if (remote > local) return true;
        if (remote < local) return false;
    }
    return false;
}

function showUpdateDialog(updateInfo) {
    if (document.getElementById('updateModal')) {
        return;
    }
    const modal = document.createElement('div');
    modal.id = 'updateModal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `
        z-index: 9;
        opacity: 0;
        transition: opacity 0.3s ease;
    `;
    const isForced = updateInfo.forceUpdate === true;
    const updateLogHTML = (updateInfo.updateLog || '').replace(/\n/g, '<br>');
    modal.innerHTML = `
        <style>
            .update-dialog-container {
                position: relative;
                max-width: 340px;
                width: 90%;
                border-radius: 0.8rem;
                background: linear-gradient(145deg, #1a1a2e, #16213e);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                border: 1px solid rgba(255, 255, 255, 5);
                color: #e0e7ff;
                padding: 1.5rem;
                overflow: hidden;
                transform: scale(0.9);
                opacity: 0;
                animation: zoomIn 0.4s 0.1s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
            }
            .bg-video-container {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                border-radius: 0.8rem;
                overflow: hidden;
                z-index: 0;
                opacity:0.8;
            }
            .bg-video {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }
            .update-dialog-container::before {
                content: '';
                position: absolute;
                top: -50%; left: -50%;
                width: 200%; height: 200%;
                background: conic-gradient(
                    transparent,
                    rgba(168, 85, 247, 0.3), 
                    rgba(79, 70, 229, 0.4), 
                    rgba(59, 130, 246, 0.3),
                    rgba(34, 197, 94, 0.4),
                    transparent 30%
                );
                animation: rotate 6s linear infinite;
            }
            .update-dialog-content {
                position: relative;
                z-index: 1;
                background: rgba(26, 26, 46, 0.1);
                border-radius: 0.7rem;
                padding: 0;
            }
             .update-dialog-header {
                
                align-items: center;
                justify-content: space-between;
                font-size: 1.2rem;
                font-weight: 600;
                padding-bottom: 1rem;
            }
            #closeUpdateModalBtn {
                position: absolute;
                top: 0;
                right: 0;
                left:94%;
            }
            .update-dialog-header i.fa-rocket {
                color: #6366f1;
            }
            .update-log {
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                font-size: 0.85rem;
                color: #d1d5db;
                line-height: 1.6;
                max-height: 200px;
                overflow-y: auto;
                padding: 0.7rem;
                margin-bottom: 1.5rem;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 0.3rem;
            }
            .update-buttons {
                display: flex;
                gap: 1rem;
            }
            .update-btn {
                flex: 1;
                padding: 0.6rem;
                border: none;
                border-radius: 0.4rem;
                font-size: 0.8rem;
                font-weight: 600;
                cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s;
                position: relative;
                overflow: hidden;
                opacity:0.7;
            }
            .update-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            }
            .btn-copy {
                background-color: #374151;
                color: #e0e7ff;
            }
            .btn-download {
                background: linear-gradient(90deg, #a855f7, #6366f1, #3b82f6);
                color: white;
            }
            .bgp {
                color: white;
            }
            @keyframes rotate {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            @keyframes zoomIn {
                to {
                    transform: scale(1);
                    opacity: 1;
                }
            }
        </style>
        <div class="update-dialog-container">
            <div class="bg-video-container">
                <video class="bg-video" autoplay muted loop playsinline>
                    <source src="./vid/bg.mp4" type="video/mp4">
                </video>
            </div>
            
            <div class="update-dialog-content">
                <div class="update-dialog-header">
                   <div class="update-dialog-header">
                        <div style="flex-grow: 1; ">
                            <span><i class="fa fa-rocket"></i>发现新版本 v${escapeHtml(updateInfo.version)}</span>
                            <div style="font-size: 0.8rem; color: #ff0036; font-weight: 400; margin-top: 0.2rem;">(当前 v${CURRENT_VERSION})</div>
                        </div>
                        ${!isForced ? `<button id="closeUpdateModalBtn" class="btn-icon-sm bgp" title="关闭"><i class="fa fa-times"></i></button>` : ''}
                    </div>
                </div>
                <div class="update-log">${updateLogHTML}</div>
                <div class="update-buttons">
                    <button id="copyUpdateLinkBtn" class="update-btn btn-copy">复制链接</button>
                    <button id="downloadUpdateBtn" class="update-btn btn-download">前往下载</button>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
    if (!isForced) {
        const closeBtn = document.getElementById('closeUpdateModalBtn');
        const closeModal = () => {
            modal.style.opacity = '0';
            modal.querySelector('.update-dialog-container').style.animation = 'zoomIn 0.3s reverse forwards';
            setTimeout(() => modal.remove(), 300);
        };
        closeBtn.onclick = closeModal;
        modal.onclick = (e) => {
            if (e.target === modal) {
                closeModal();
            }
        };
    }
    document.getElementById('copyUpdateLinkBtn').onclick = () => {
        navigator.clipboard.writeText(updateInfo.downloadUrl).then(() => {
            showToast('下载链接已复制!');
        }).catch(() => {
            showToast('复制失败');
        });
    };
    document.getElementById('downloadUpdateBtn').onclick = () => {
        window.open(updateInfo.downloadUrl, '_blank');
    };
}

const originalInit = window.init;
window.init = async function() {
    if(originalInit) {
        await originalInit.apply(this, arguments);
    }
    checkForUpdates();
};

let editorScaleHintShownThisLoad = false;

function showEditorScaleHintOnce() {
    if (el.editorScaleHint && !editorScaleHintShownThisLoad) {
        el.editorScaleHint.classList.remove('hidden');
        setTimeout(() => {
            el.editorScaleHint.classList.add('show');
        }, 100);
        setTimeout(() => {
            el.editorScaleHint.classList.remove('show');
            setTimeout(() => {
                el.editorScaleHint.classList.add('hidden');
            }, 300);
        }, 6000);
        editorScaleHintShownThisLoad = true;
    }
}

</script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
