<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GitHub文件管理器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<style>
    /* 去除移动端点击高亮 */
    * {
        -webkit-tap-highlight-color: transparent;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        outline: none;
    }

    /* 恢复焦点可见性，仅在键盘导航时显示 */
    *:focus-visible {
        outline: 2px solid #6366f1;
        /* 使用主题色作为焦点环 */
        outline-offset: 2px;
        border-radius: 0.25rem;
        /* 匹配按钮圆角 */
    }

    /* 基础样式 */
    body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background-color: #030712;
        color: #f3f4f6;
        min-height: 100vh;
        overflow-x: hidden;
    }

    /* 登录界面样式 */
    #authScreen {
        height: 100vh;
        display: flex;
        flex-direction: column;
        padding: 1.5rem;
        justify-content: center;
        gap: 1.5rem;
    }

    .auth-header {
        text-align: center;
        margin-bottom: 2.5rem;
    }

    .auth-header i {
        font-size: 3rem;
        color: #9ca3af;
        margin-bottom: 1rem;
    }

    .auth-header h1 {
        font-size: 1.875rem;
        font-weight: bold;
    }

    .auth-form {
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3), -5px -5px 10px rgba(75, 85, 99, 0.1);
        background-color: #111827;
        border-radius: 0.75rem;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    #tokenInput {
        box-shadow: inset 3px 3px 6px rgba(0, 0, 0, 0.3), inset -3px -3px 6px rgba(75, 85, 99, 0.1);
        background-color: #030712;
        border-radius: 0.5rem;
        padding: 0.75rem;
        outline: none;
        color: #f3f4f6;
        border: none;
    }

    #authBtn {
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3), -5px -5px 10px rgba(75, 85, 99, 0.1);
        background-color: #6b7280;
        border-radius: 0.5rem;
        padding: 0.75rem;
        font-weight: 500;
        border: none;
        color: white;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    #authBtn:hover {
        background-color: #4b5563;
    }

    /* 主应用界面样式 */
    #app {
        flex-direction: column;
        height: 100vh;
    }

    header {
        background-color: rgba(17, 24, 39, 0.8);
        backdrop-filter: blur(10px);
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3), -5px -5px 10px rgba(75, 85, 99, 0.1);
        padding: 0.5rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .header-left {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .header-left i {
        color: #9ca3af;
    }

    .header-right {
        display: flex;
        align-items: center;
        gap: 0.35rem;
    }

    #currentRepo {
        font-weight: bold;
        font-size: 0.875rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    #mainMenuBtn {
        padding: 0.5rem;
        border-radius: 9999px;
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    #mainMenuBtn:hover {
        background-color: rgba(107, 114, 128, 0.2);
    }

    /* 路径导航 */
    #pathNavContainer {
        background-color: rgba(17, 24, 39, 0.8);
        backdrop-filter: blur(10px);
        padding: 0.25rem 0;
        overflow-x: auto;
        white-space: nowrap;
    }

    #pathNav {
        display: flex;
        gap: 0.25rem;
        font-size: 0.75rem;
    }

    #pathNav span {
        cursor: pointer;
    }

    #pathNav span:hover {
        color: #d1d5db;
    }

    /* Toolbar */
    #toolbar {
        background-color: rgba(17, 24, 39, 0.8);
        backdrop-filter: blur(10px);
        border-top: 1px solid #1f2937;
        border-bottom: 1px solid #1f2937;
        padding: 0.5rem 0.75rem;
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    #toolbar .toolbar-left {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    #toolbar .toolbar-right {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    #searchInput {
        flex: 1;
        min-width: 140px;
        padding: 0.5rem 0.75rem;
        background: #030712;
        color: #f3f4f6;
        border: 1px solid #374151;
        border-radius: 0.5rem;
        outline: none;
    }

    #sortSelect {
        padding: 0.45rem 0.6rem;
        background: #030712;
        color: #f3f4f6;
        border: 1px solid #374151;
        border-radius: 0.5rem;
        outline: none;
    }

    #viewToggleBtn {
        padding: 0.5rem;
        background: none;
        border: 1px solid #374151;
        color: #f3f4f6;
        border-radius: 0.5rem;
        cursor: pointer;
    }

    #viewToggleBtn.active {
        background: #1f2937;
    }

    /* 主内容区 */
    main {
        flex: 1;
        overflow-y: auto;
        padding-bottom: 90px;
        /* 或更大，视底部栏高度而定 */
    }

    #repoList,
    #fileList {
        padding: 0.75rem;
    }

    .loading-spinner {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        padding: 2.5rem 0;
    }

    .spinner {
        animation: spin 1s linear infinite;
        border-radius: 9999px;
        height: 2.5rem;
        width: 2.5rem;
        border-top: 2px solid #9ca3af;
        border-bottom: 2px solid #9ca3af;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    /* 底部操作栏 */
    footer {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(17, 24, 39, 0.8);
        backdrop-filter: blur(10px);
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3), -5px -5px 10px rgba(75, 85, 99, 0.1);
        padding: 1.25rem 1rem;
        display: flex;
        justify-content: space-around;
    }

    footer button {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 0.5rem;
        width: 25%;
        background: none;
        border: none;
        color: white;
        cursor: pointer;
    }

    footer button i {
        font-size: 1.25rem;
    }

    /* 编辑文件模态框 */
    #editModal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 50;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1rem;
    }

    .modal-content {
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3), -5px -5px 10px rgba(75, 85, 99, 0.1);
        background-color: #111827;
        border-radius: 0.75rem;
        display: flex;
        flex-direction: column;
        width: 100%;
        max-width: 80rem;
        min-height: 66VH;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-left: 0.75rem;
        height: 2%;
        padding-top: 10px;
        padding-bottom: 10px;
    }

    .modal-header h5 {
        font-size: 0.6rem;
        font-weight: bold;
    }

    #closeEditModal,
    #toggleMaximizeModal {
        padding: 0.5rem;
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        border-radius: 9999px;
    }

    #closeEditModal:hover,
    #toggleMaximizeModal:hover {
        background-color: rgba(107, 114, 128, 0.2);
    }

    #editStatus {
        margin: 0.1rem 0;
        border-radius: 0.375rem;
    }

    .editor-container {
        flex: 1;
        overflow: hidden;
        position: relative;
        display: flex;
        justify-content: center;
    }

    #editorOverlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(17, 24, 39, 0.7);
        z-index: 10;
        border-radius: 0.375rem;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }

    #editorOverlay.show {
        opacity: 1;
        pointer-events: auto;
    }

    #saveNotification {
        position: absolute;
        top: 2.5rem;
        right: 2.5rem;
        background-color: rgba(15, 81, 50, 0.9);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 14px;
        z-index: 5;
        opacity: 0;
        transform: translateY(-20px);
        transition: opacity 0.3s ease, transform 0.3s ease;
    }

    #saveNotification.show {
        opacity: 1;
        transform: translateY(0);
    }

    /* 编辑文件*/
    #fileContent {
        box-shadow: inset 3px 3px 6px rgba(0, 0, 0, 0.3), inset -3px -3px 6px rgba(75, 85, 99, 0.1);
        background-color: #030712;
        width: 99%;
        height: 100%;
        outline: none;
        min-height: 66VH;
        box-sizing: border-box;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        overflow-x: hidden;
        max-width: 1200px;
        border-top: 1px solid #374151;
        border-bottom: 1px solid #374151;
        color: #a2a7c7;
        resize: none;
        border: none;
    }

    /* 编辑文件保存按钮大小 */
    .modal-footer {
        display: flex;
        gap: 0rem;
        height: 40px;
    }

    .modal-footer button {
        flex: 1;
        border-radius: 0.5rem;
        border: none;
        cursor: pointer;
        font-size: 11px;
    }

    #cancelEdit {
        background-color: #111827;
        color: white;
    }

    #saveEdit {
        background-color: #111827;
        color: white;
    }

    /* 文件上传面板 */
    #uploadPanel {
        position: fixed;
        bottom: 5rem;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(17, 24, 39, 0.8);
        backdrop-filter: blur(10px);
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3), -5px -5px 10px rgba(75, 85, 99, 0.1);
        border-radius: 0.5rem;
        padding: 1rem;
        width: 90%;
        max-width: 28rem;
        font-size: 10px;
        z-index: 40;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .upload-percent {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.75rem;
        color: #9ca3af;
        font-weight: 500;
    }

    .upload-progress-container {
        position: relative;
        height: 4px;
        background: #374151;
        border-radius: 4px;
        overflow: hidden;
        margin: 4px 0;
    }

    .upload-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        font-size: 12px;
        min-width: 0;
    }

    .upload-name {
        flex: 1 1 0;
        min-width: 0;
        max-width: 70%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: inline-block;
    }

    .upload-size {
        margin-left: 8px;
        color: #9ca3af;
        flex-shrink: 0;
        font-size: 0.95em;
    }

    #uploadItems {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        max-height: 10rem;
        overflow-y: auto;
    }

    /* 通用模态框 */
    #modalOverlay {
        position: fixed;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 50;
        align-items: center;
        justify-content: center;
    }

    #modalOverlay .modal-content {
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3), -5px -5px 10px rgba(75, 85, 99, 0.1);
        background-color: #111827;
        border-radius: 0.75rem;
        padding: 1.25rem;
        width: 91.666667%;
        max-width: 28rem;
    }

    /* 右键菜单 */
    #contextMenu {
        position: fixed;
        background-color: rgba(17, 24, 39, 0.9);
        /* 略微不透明，增强毛玻璃感 */
        backdrop-filter: blur(12px);
        /* 略微增强模糊 */
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
        /* 更柔和的阴影 */
        border-radius: 0.75rem;
        /* 更大的圆角 */
        z-index: 50;
        min-width: 12rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        /* 更柔和的边框 */
        transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        /* 动画过渡 */
    }

    #contextMenuItems {
        padding: 0.25rem 0;
    }

    /* 菜单项基础样式 */
    #contextMenuItems a,
    #mainMenuPopup button {
        padding: 0.75rem 1rem;
        /* 增加内边距 */
        font-size: 0.9rem;
        /* 略微增大字号，保持可读性 */
        font-weight: 400;
        /* 默认字重 */
        transition: background-color 0.15s ease, color 0.15s ease, transform 0.05s ease;
        /* 添加颜色和变换过渡 */
        display: flex;
        /* 确保图标和文本良好对齐 */
        align-items: center;
        gap: 0.75rem;
        /* 增加图标和文本间距 */
        color: #f3f4f6;
        /* 默认文本颜色 */
        background: none;
        border: none;
        text-align: left;
        cursor: pointer;
        border-radius: 0.375rem;
        /* 略微圆角 */
    }

    /* 菜单项悬停效果 */
    #contextMenuItems a:hover,
    #mainMenuPopup button:hover {
        background-color: rgba(107, 114, 128, 0.2);
        /* 悬停背景略深一点 */
        color: #fff;
        /* 悬停时文本颜色略亮 */
        transform: translateX(3px);
        /* 悬停时向右微移，增加动感 */
    }

    /* 针对带有特定颜色的项（如删除） */
    #contextMenuItems a.text-red-400 {
        color: #f87171 !important;
    }

    #contextMenuItems a.text-red-400:hover {
        background-color: rgba(239, 68, 68, 0.2);
        /* 悬停背景色匹配红色 */
        color: #ef4444 !important;
        /* 悬停时文本颜色更明显 */
    }

    /* 确保图标在菜单项中对齐 */
    #contextMenuItems a i,
    #mainMenuPopup button i {
        font-size: 1.1em;
        /* 调整图标大小，相对于父元素字体大小 */
        width: 1.2em;
        /* 固定图标宽度，确保文本对齐 */
        text-align: center;
        flex-shrink: 0;
        /* 防止图标被压缩 */
    }

    /* Toast提示 */
    #toast {
        position: fixed;
        bottom: 5rem;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(17, 24, 39, 0.8);
        backdrop-filter: blur(10px);
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3), -5px -5px 10px rgba(75, 85, 99, 0.1);
        padding: 0.5rem 1rem;
        border-radius: 9999px;
        z-index: 101;
        /* 提高 z-index 确保在所有弹窗之上 */
    }

    .hidden {
        display: none !important;
    }

    /* 主菜单弹出框 */
    #mainMenuPopup {
        position: fixed;
        top: 4rem;
        right: 1rem;
        z-index: 50;
        background-color: rgba(17, 24, 39, 0.9);
        /* 略微不透明，增强毛玻璃感 */
        backdrop-filter: blur(12px);
        /* 略微增强模糊 */
        border-radius: 0.75rem;
        /* 更大的圆角 */
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.45), 0 4px 10px rgba(0, 0, 0, 0.2);
        /* 更深的阴影 */
        border: 1px solid rgba(255, 255, 255, 0.08);
        min-width: 16rem;
        /* 增加宽度 */
        max-width: 20rem;
        /* 最大宽度 */
        padding: 0.75rem;
        /* 整体内边距 */
        display: flex;
        /* 使用 flex 布局 */
        flex-direction: column;
        /* 垂直排列 */
        transform-origin: top right;
        /* 动画原点从右上角开始 */

        /* 动画效果 */
        transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        opacity: 0;
        transform: scale(0.95);
        pointer-events: none;
        /* 隐藏时不可交互 */
    }

    /* 菜单显示时 */
    #mainMenuPopup:not(.hidden) {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
    }

    /* 菜单内部的个人信息和速率限制区域 */
    .menu-profile {
        display: flex;
        align-items: center;
        padding: 0.75rem 0.5rem;
        gap: 0.75rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        /* 分隔线 */
        margin-bottom: 0.75rem;
    }

    .menu-profile .avatar {
        width: 2.5rem;
        height: 2.5rem;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid #6366f1;
        /* 强调边框 */
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1);
    }

    .menu-profile .user-name {
        font-weight: bold;
        color: #e0e0e0;
        font-size: 1rem;
    }

    .menu-rate-limit {
        padding: 0 0.5rem 0.75rem;
        /* 调整内边距 */
        font-size: 0.8rem;
        color: #9ca3af;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        /* 分隔线 */
        margin-bottom: 0.75rem;
    }

    .rate-limit-bar-container {
        width: 100%;
        height: 6px;
        background-color: #374151;
        border-radius: 3px;
        overflow: hidden;
        margin-top: 0.4rem;
    }

    .rate-limit-bar {
        height: 100%;
        width: 100%;
        /* 默认100%，JS控制实际宽度 */
        background-color: #22c55e;
        /* 默认绿色 */
        border-radius: 3px;
        transition: width 0.3s ease-out, background-color 0.3s ease-out;
    }

    .rate-limit-bar.warning {
        background-color: #fbbf24;
        /* 黄色警告 */
    }

    .rate-limit-bar.critical {
        background-color: #ef4444;
        /* 红色危险 */
    }

    .rate-limit-reset {
        margin-top: 0.4rem;
        font-size: 0.75rem;
        color: #6b7280;
    }

    /* 菜单项分组 */
    .menu-items-group {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        /* 组内间距 */
        margin-bottom: 0.75rem;
        /* 组间距 */
    }

    /* 分隔线 */
    .menu-separator {
        height: 1px;
        background-color: rgba(255, 255, 255, 0.1);
        margin: 0.5rem 0;
    }

    /* 文件列表项样式 */
    .file-item {
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3), -5px -5px 10px rgba(75, 85, 99, 0.1);
        background-color: #111827;
        border-radius: 0.5rem;
        padding: 0.1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .file-item:hover {
        background-color: rgba(107, 114, 128, 0.1);
    }

    .file-icon {
        width: 2.5rem;
        height: 2.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0.5rem;
        background-color: rgba(17, 24, 39, 0.5);
    }

    .file-info {
        flex: 1;
        min-width: 0;
    }

    .file-name {
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 0.765rem;
    }

    .file-meta {
        font-size: 0.75rem;
        color: #9ca3af;
        margin-top: 0.25rem;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* 多选操作栏 */
    #multiActionBar {
        width: 100%;
        position: fixed;
        bottom: 4.5rem;
        padding: 0;
        left: 0;
        right: 0;
        display: flex;
        align-items: center;
        justify-content: space-around;
        background-color: rgba(17, 24, 39, 0.8);
        backdrop-filter: blur(10px);
        padding: 0.5rem 0;
        z-index: 20;
    }

    #multiActionBar button {
        width: 14%;
        height: 2.5rem;
        margin: 0.5rem;
        border: none;
        border-radius: 0.5rem;
        background: linear-gradient(90deg, #0ea5e9, #6366f1);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }

    #selectedCount {
        color: white;
        font-weight: bold;
        font-size: 0.875rem;
        margin: 0 0.5rem;
        text-align: right;
        margin-right: 15%;
    }

    /* 多选复选框 */
    .multi-select-checkbox {
        margin-right: 0.5rem;
    }

    /* 空状态 */
    .empty-state {
        text-align: center;
        padding: 2.5rem 0;
        color: #9ca3af;
    }

    .empty-state i {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
    }

    /* 媒体预览 */
    #mediaPreview {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 60;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
    }

    #mediaPreview img,
    #mediaPreview video {
        max-width: 90%;
        max-height: 90vh;
        object-fit: contain;
        display: block;
        margin: auto;
    }

    /* 网格视图 */
    #fileList.grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
        gap: 0.5rem;
    }

    #fileList.grid .file-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.35rem;
        padding: 0.5rem;
    }

    #fileList.grid .file-icon {
        width: 2.25rem;
        height: 2.25rem;
    }

    #fileList.grid .file-name {
        font-size: 0.85rem;
        max-width: 100%;
    }

    #fileList.grid .file-meta {
        -webkit-line-clamp: 1;
    }

    /* 响应式调整 */
    @media (max-width: 640px) {
        footer button {
            width: 20%;
        }

        #multiActionBar button {
            width: 18%;
        }
    }

    /* 通用按钮样式 */
    .btn {
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        border: none;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s, opacity 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        white-space: nowrap;
    }

    .btn-primary {
        background: #22c55e;
        color: #fff;
    }

    .btn-primary:hover:not(:disabled) {
        background: #16a34a;
    }

    .btn-danger {
        background: #ef4444;
        color: #fff;
    }

    .btn-danger:hover:not(:disabled) {
        background: #dc2626;
    }

    .btn-cancel {
        background: #374151;
        color: #f3f4f6;
    }

    .btn-cancel:hover:not(:disabled) {
        background: #4b5563;
    }

    .btn-secondary {
        background-color: #374151;
        color: #f3f4f6;
        font-size: 0.85rem;
        padding: 0.4rem 0.6rem;
    }

    .btn-secondary:hover:not(:disabled) {
        background-color: #4b5563;
    }

    .btn:disabled,
    .btn.disabled {
        background: #6b7280 !important;
        color: #ccc !important;
        cursor: not-allowed !important;
        opacity: 0.7;
    }

    /* 按钮图标 */
    .btn-icon {
        background: none;
        border: none;
        color: #f3f4f6;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 9999px;
        /* 圆形 */
        width: 40px;
        /* 固定宽度 */
        height: 40px;
        /* 固定高度 */
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s, color 0.2s;
        flex-shrink: 0;
        font-size: 1.2rem;
        /* 图标大小 */
    }

    .btn-icon:hover:not(:disabled) {
        background-color: rgba(107, 114, 128, 0.2);
    }

    .btn-icon.active {
        color: #22c55e;
        /* 启用状态的颜色 */
    }

    .btn-icon.danger {
        color: #ef4444;
    }

    .btn-icon.danger:hover:not(:disabled) {
        background-color: rgba(239, 68, 68, 0.2);
    }

    /* 小尺寸按钮图标 (用于代理列表内部操作) */
    .btn-icon-sm {
        background: none;
        border: none;
        color: #9ca3af;
        cursor: pointer;
        padding: 0.25rem;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s, color 0.2s;
        flex-shrink: 0;
        font-size: 1rem;
    }

    .btn-icon-sm:hover:not(:disabled) {
        background-color: rgba(107, 114, 128, 0.2);
        color: #f3f4f6;
    }

    .btn-icon-sm.active {
        color: #22c55e;
    }

    .btn-icon-sm.danger {
        color: #ef4444;
    }

    /* 弹窗内容容器 */
    .modal-form-container {
        background: #111827;
        border-radius: 0.75rem;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25), 0 1.5px 6px rgba(75, 85, 99, 0.08);
        padding: 1.5rem;
        /* 调整内边距 */
        max-width: 360px;
        /* 调整最大宽度，使其更小巧 */
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        /* 调整元素间距 */
        min-width: 260px;
    }

    .modal-form-container h3 {
        font-size: 1.1rem;
        /* 调整标题大小 */
        font-weight: bold;
        color: #f3f4f6;
        margin-bottom: 0.5rem;
        display: flex;
        /* Ensure h3 is flex for title/button layout */
        justify-content: space-between;
        align-items: center;
    }

    .modal-form-container h3 .modal-title-text {
        flex: 1;
        /* Allow title text to take available space */
    }

    .modal-form-container p {
        color: #9ca3af;
        font-size: 0.9rem;
        /* 调整文字大小 */
        margin-bottom: 0.5rem;
    }

    .modal-form-container input,
    .modal-form-container textarea {
        background: #030712;
        color: #f3f4f6;
        border: 1px solid #374151;
        border-radius: 0.5rem;
        padding: 0.6rem 0.75rem;
        /* 调整输入框内边距 */
        font-size: 0.95rem;
        /* 调整输入框字体大小 */
        outline: none;
        margin-bottom: 0.5rem;
        transition: border 0.2s;
    }

    .modal-form-container input:focus,
    .modal-form-container textarea:focus {
        border-color: #6366f1;
    }

    .modal-form-container textarea {
        min-height: 80px;
        resize: vertical;
    }

    .modal-buttons {
        display: flex;
        gap: 0.75rem;
        /* 调整按钮间距 */
        margin-top: 0.75rem;
        flex-wrap: wrap;
        /* 允许按钮换行 */
        justify-content: flex-end;
        /* 靠右对齐 */
    }

    .modal-buttons button {
        flex: 1;
        min-width: 80px;
        /* 最小宽度 */
    }

    .checkbox-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }

    @media (max-width: 480px) {
        .modal-form-container {
            max-width: 95vw;
            padding: 1rem 0.75rem;
        }
    }

    .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .hidden {
        display: none !important;
    }

    /* 上传进度条 */
    .upload-progress-container {
        height: 4px;
        background: #374151;
        border-radius: 4px;
        overflow: hidden;
        margin: 4px 0;
    }

    .upload-progress {
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, #22c55e, #0ea5e9, #6366f1, #f472b6, #f59e42, #22c55e);
        background-size: 200% 100%;
        animation: rainbow-bar 2s linear infinite;
        transition: width 0.3s;
        border-radius: 4px;
    }

    @keyframes rainbow-bar {
        0% {
            background-position: 0% 50%;
        }

        100% {
            background-position: 100% 50%;
        }
    }

    .upload-status {
        text-align: right;
        margin-top: 7px;
    }

    .upload-status.success {
        color: #22c55e;
    }

    .upload-status.error {
        color: #ef4444;
    }

    /* 文本颜色 */
    .text-red-400 {
        color: #f87171 !important;
    }

    .text-green-500 {
        color: #22c55e !important;
    }

    .text-orange-400 {
        color: #fb923c !important;
    }

    .text-gray-400 {
        color: #9ca3af !important;
    }

    /* 代理快速开关 */
    #proxyQuickToggle {
        padding: 0.5rem;
        background: none;
        border: none;
        color: #9ca3af;
        cursor: pointer;
        border-radius: 9999px;
        transition: background-color 0.2s, color 0.2s;
    }

    #proxyQuickToggle:hover {
        background-color: rgba(107, 114, 128, 0.2);
    }

    #proxyQuickToggle.active {
        color: #22c55e;
    }

    /* 代理设置面板 */
    #proxySettingsModal .modal-form-container {
        position: fixed; /* 从flex item变为可绝对定位 */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        cursor: default; /* 默认光标 */
        max-width: 420px;
        /* 更精致的宽度 */
        padding: 1rem;
        gap: 0.75rem;
    }

    #proxySettingsModal .proxy-list {
        max-height: 250px;
        /* 调整列表最大高度 */
        overflow-y: auto;
        border: 1px solid #374151;
        border-radius: 0.5rem;
        background-color: #030712;
        padding: 0.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .proxy-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        background-color: #111827;
        padding: 0.5rem;
        border: 2px solid transparent;
        border-radius: 0.5rem;
        font-size: 0.9rem;
        min-height: 40px;
        position: relative;
        transition: border-color 0.2s;
        flex-wrap: wrap;
        /* 允许内部元素换行 */
    }

    .proxy-item.active {
        border-color: #22c55e;
    }

    .proxy-item .proxy-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        /* 确保内容不溢出 */
    }

    .proxy-item .proxy-url {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-weight: 500;
        line-height: 1.2;
    }

    .proxy-item .proxy-latency {
        flex-shrink: 0;
        font-weight: bold;
        min-width: 90px;
        text-align: left;
        /* 延迟文字左对齐 */
        font-size: 0.8rem;
        /* 延迟文字更小 */
        margin-top: 0.2rem;
    }

    .proxy-item .proxy-actions {
        display: flex;
        gap: 0.25rem;
        flex-shrink: 0;
        flex-wrap: nowrap;
        /* 不换行，保持一行 */
        justify-content: flex-end;
        align-items: center;
        margin-left: auto;
        /* 靠右 */
    }

    /* 代理设置面板顶部的启用开关 */
    #proxyGlobalEnableToggle {
        font-size: 1.4rem;
        /* 图标稍大 */
        padding: 0.4rem;
    }

    #proxyGlobalEnableToggle.active {
        color: #22c55e;
    }

    #proxyGlobalEnableToggle.disabled {
        color: #9ca3af;
        cursor: not-allowed;
    }

    /* 代理添加/编辑弹窗 */
    #addEditProxyModal .modal-form-container {
        max-width: 380px;
        gap: 0.75rem;
    }

    #addEditProxyModal .modal-buttons {
        margin-top: 0;
        flex-wrap: nowrap;
        /* Prevent wrap for main buttons */
    }

    /* 代理添加/编辑弹窗中的测试按钮 */
    #addEditProxyTestBtn {
        flex: 0 0 auto;
        /* Keep content size */
        min-width: 100px;
        padding: 0.5rem 0.75rem;
        font-size: 0.9rem;
        height: 38px;
        /* Fixed height for visual consistency */
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }

    /* 代理添加/编辑弹窗中的测试结果显示 */
    #addEditProxyTestResult {
        flex: 1;
        text-align: right;
        font-size: 0.9rem;
        min-height: 1.1rem;
        /* Ensure consistent height */
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding: 0 0.5rem;
        /* Add padding to prevent text touching edge */
    }

    /* Maximize editor styles */
    #toggleMaximizeModal {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #editModal.maximized {
        padding: 0 !important;
    }

    #editModal.maximized .modal-content {
        width: 100vw !important;
        height: 100vh !important;
        max-width: 100vw !important;
        min-height: 100vh !important;
        border-radius: 0 !important;
        margin: 0 !important;
        display: flex;
        flex-direction: column;
    }

    #editModal.maximized .editor-container {
        height: calc(100vh - 120px) !important;
        flex: 1;
        overflow: hidden;
    }

    #editModal.maximized #fileContent {
        height: 100% !important;
        min-height: unset !important;
    }

    #editModal.maximized .modal-header,
    #editModal.maximized .modal-footer {
        flex-shrink: 0;
    }

    .spinner-small {
        animation: spin 1s linear infinite;
        border-radius: 9999px;
        height: 1em;
        width: 1em;
        border-top: 1px solid currentColor;
        border-bottom: 1px solid currentColor;
        vertical-align: middle;
        margin-left: 0.3em;
    }

    /* Confirm Delete Proxy Modal */
    #confirmDeleteProxyModal .modal-form-container {
        max-width: 300px;
        /* 更小巧 */
        padding: 1.25rem;
        gap: 0.75rem;
    }

    #confirmDeleteProxyModal h3 {
        font-size: 1rem;
    }

    #confirmDeleteProxyModal p {
        font-size: 0.85rem;
        line-height: 1.4;
    }

    #confirmDeleteProxyModal .modal-buttons button {
        height: 38px;
        font-size: 0.9rem;
    }

    /* Confirm Clear All Proxies Modal (新) */
    #confirmClearAllProxiesModal .modal-form-container {
        max-width: 340px;
        padding: 1.25rem;
        gap: 0.75rem;
    }

    #confirmClearAllProxiesModal h3 {
        font-size: 1rem;
    }

    #confirmClearAllProxiesModal p {
        font-size: 0.85rem;
        line-height: 1.4;
    }

    #confirmClearAllProxiesModal .modal-buttons button {
        height: 38px;
        font-size: 0.9rem;
    }

    /* 音乐播放器悬浮窗样式 */
    #audioPlayer {
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        background-color: rgba(17, 24, 39, 0.9);
        /* 与header和footer背景一致 */
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
        border-radius: 0.75rem;
        padding: 0.75rem;
        width: 250px;
        /* 小巧尺寸 */
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        resize: horizontal;
        /* 允许用户调整宽度 */
        min-width: 200px;
        max-width: 400px;
    }

    #audioPlayer.hidden {
        display: none !important;
    }

    .player-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
        font-weight: bold;
        color: #f3f4f6;
        cursor: grab;
        /* 指示可拖拽 */
        padding-bottom: 0.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
    }

    .player-header i {
        color: #9ca3af;
    }

    #playerCurrentSong {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    #closeAudioPlayer {
        font-size: 1rem;
        width: 24px;
        height: 24px;
        padding: 0;
    }

    .player-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.75rem;
        margin-top: 0.5rem;
    }

    .player-controls .btn-icon {
        font-size: 1.5rem;
        /* 播放/暂停按钮大一些 */
        width: 48px;
        height: 48px;
        background-color: #6366f1;
        /* 强调色 */
        color: white;
        border-radius: 50%;
    }

    .player-controls .btn-icon:hover {
        background-color: #4f46e5;
    }

    .player-controls .btn-icon-sm {
        font-size: 1.1rem;
        width: 36px;
        height: 36px;
    }

    .progress-container {
        margin-top: 0.75rem;
    }

    #audioProgress {
        width: 100%;
        height: 4px;
        -webkit-appearance: none;
        appearance: none;
        background: #374151;
        border-radius: 2px;
        outline: none;
        cursor: pointer;
        margin-bottom: 0.25rem;
    }

    #audioProgress::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 12px;
        height: 12px;
        background: #6366f1;
        border-radius: 50%;
        cursor: grab;
        box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.3);
    }

    #audioProgress::-moz-range-thumb {
        width: 12px;
        height: 12px;
        background: #6366f1;
        border-radius: 50%;
        cursor: grab;
        box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.3);
    }

    .time-display {
        display: flex;
        justify-content: space-between;
        font-size: 0.75rem;
        color: #9ca3af;
    }

    /* 代理设置模态框的拖拽把手（即header） */
    #proxySettingsModal .modal-form-container h3 {
        cursor: grab;
        /* 拖拽把手光标 */
        -webkit-user-select: none;
        /* 防止拖拽时选择文本 */
        -moz-user-select: none;
        user-select: none;
    }
</style>

<body>
    <!-- 登录界面 -->
    <div id="authScreen">
        <div class="auth-header">
            <i class="fa fa-github"></i>
            <h1>GitHub文件管理器</h1>
        </div>
        <div class="auth-form">
            <input type="text" id="tokenInput" placeholder="输入GitHub访问令牌">
            <button id="authBtn">登录</button>
        </div>
    </div>

    <!-- 主应用界面 -->
    <div id="app" class="hidden">
        <header>
            <div class="header-left">
                <i class="fa fa-github"></i>
                <h1 id="currentRepo">选择仓库</h1>
            </div>
            <div class="header-right">
                <button id="proxyQuickToggle" title="代理已开启">
                    <i class="fa fa-plug"></i>
                </button>
                <button id="mainMenuBtn" title="菜单">
                    <i class="fa fa-ellipsis-v"></i>
                </button>
            </div>
        </header>

        <!-- 路径导航 -->
        <div id="pathNavContainer">
            <div id="pathNav"></div>
        </div>

        <!-- 文件工具栏（仅文件视图显示） -->
        <div id="toolbar" class="hidden">
            <div class="toolbar-left">
                <input id="searchInput" placeholder="搜索文件/文件夹...">
            </div>
            <div class="toolbar-right">
                <select id="sortSelect" title="排序">
                    <option value="name_asc">名称 A→Z</option>
                    <option value="name_desc">名称 Z→A</option>
                    <option value="time_desc">时间 最新优先</option>
                    <option value="time_asc">时间 最旧优先</option>
                    <option value="size_desc">大小 大→小</option>
                    <option value="size_asc">大小 小→大</option>
                </select>
                <button id="viewToggleBtn" title="切换为网格视图">
                    <i class="fa fa-th-large"></i>
                </button>
            </div>
        </div>

        <!-- 主内容区 -->
        <main>
            <div id="repoList">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
            <div id="fileList" class="hidden">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
        </main>

        <!-- 重命名弹窗 -->
        <div id="renameModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3 id="renameTitle"><span class="modal-title-text">重命名</span><button class="btn-icon-sm" onclick="el.renameModal.classList.add('hidden')" title="关闭"><i class="fa fa-times"></i></button></h3>
                <input type="text" id="renameInput" value="" autocomplete="off">
                <div id="renameWarn" class="text-red-400" style="font-size: 0.875rem; margin-top: -0.5rem; margin-bottom: 0.5rem; display: none;"></div>
                <div class="modal-buttons">
                    <button id="renameCancel" class="btn btn-cancel">取消</button>
                    <button id="renameConfirm" class="btn btn-primary" disabled>确认</button>
                </div>
            </div>
        </div>

        <!-- 删除弹窗 -->
        <div id="deleteModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3 id="deleteTitle"><span class="modal-title-text">确认删除</span><button class="btn-icon-sm" onclick="el.deleteModal.classList.add('hidden')" title="关闭"><i class="fa fa-times"></i></button></h3>
                <p id="deleteDesc"></p>
                <div class="modal-buttons">
                    <button id="deleteCancel" class="btn btn-cancel">取消</button>
                    <button id="deleteConfirm" class="btn btn-danger">确认删除</button>
                </div>
            </div>
        </div>

        <!-- 编辑文件模态框 -->
        <div id="editModal" class="hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 id="editFileName">编辑文件</h5>
                    <div style="display:flex; gap:0.5rem;">
                        <button id="toggleMaximizeModal" title="最大化">
                            <i class="fa fa-expand"></i>
                        </button>
                        <button id="closeEditModal">
                            <i class="fa fa-times"></i>
                        </button>
                    </div>
                </div>
                <div id="editStatus"></div>
                <div class="editor-container">
                    <div id="editorOverlay">
                        <div class="spinner-container">
                            <i class="fa fa-spinner fa-spin"></i>
                        </div>
                    </div>
                    <div id="saveNotification">
                        <i class="fa fa-check"></i> 保存成功
                    </div>
                    <textarea id="fileContent"></textarea>
                </div>
                <div class="modal-footer">
                    <button id="cancelEdit">取消</button>
                    <button id="saveEdit">保存修改</button>
                </div>
            </div>
        </div>

        <!-- 通用模态框 -->
        <div id="modalOverlay" class="hidden">
            <div class="modal-content">
                <div id="modalContent"></div>
            </div>
        </div>

        <!-- 右键菜单 -->
        <div id="contextMenu" class="hidden">
            <div id="contextMenuItems"></div>
        </div>

        <!-- Toast提示 -->
        <div id="toast" class="hidden">
            <span id="toastMessage"></span>
        </div>

        <!-- 隐藏的文件上传input -->
        <input type="file" id="fileUploadInput" multiple class="hidden">

        <!-- 主菜单弹出框 -->
        <div id="mainMenuPopup" class="hidden">
            <div class="menu-profile">
                <img id="userAvatar" src="" alt="用户头像" class="avatar hidden">
                <span id="userName" class="user-name"></span>
            </div>
            <div class="menu-rate-limit">
                <div class="rate-limit-text">
                    API 限制: <span id="rateLimitUsed">0</span>/<span id="rateLimitTotal">0</span> (<span id="rateLimitRemaining">0</span>)
                </div>
                <div class="rate-limit-bar-container">
                    <div id="rateLimitProgressBar" class="rate-limit-bar"></div>
                </div>
                <div id="rateLimitReset" class="rate-limit-reset"></div>
            </div>
            <div class="menu-items-group">
                <button id="menuRepoList">
                    <i class="fa fa-list"></i> 仓库列表
                </button>
                <button id="menuProxySettings">
                    <i class="fa fa-plug"></i> 代理设置
                </button>
                <button id="menuRefresh">
                    <i class="fa fa-refresh"></i> 刷新页面
                </button>
            </div>
            <div class="menu-separator"></div>
            <!-- 添加分隔线 -->
            <div class="menu-items-group">
                <button id="menuLogout">
                    <i class="fa fa-sign-out"></i> 退出登录
                </button>
            </div>
        </div>

        <!-- 底部操作栏 -->
        <footer>
            <button id="backBtn" title="返回上级">
                <i class="fa fa-arrow-up"></i>
            </button>
            <button id="newFolderBtn" title="新建仓库">
                <i class="fa fa-plus"></i>
            </button>
            <button id="newFileBtn" title="新建文件">
                <i class="fa fa-file-o"></i>
            </button>
            <button id="uploadBtn" title="上传文件">
                <i class="fa fa-upload"></i>
            </button>
        </footer>

        <!-- 媒体预览 -->
        <div id="mediaPreview" class="hidden">
            <img id="mediaPreviewImg" style="display:none;" alt="预览图片">
            <video id="mediaPreviewVideo" style="display:none;" controls></video>
        </div>

        <!-- 音乐播放器悬浮窗 -->
        <div id="audioPlayer" class="hidden">
            <div class="player-header" id="audioPlayerHandle">
                <i class="fa fa-music"></i>
                <span id="playerCurrentSong">未播放</span>
                <button id="closeAudioPlayer" class="btn-icon-sm" title="关闭播放器">
                    <i class="fa fa-times"></i>
                </button>
            </div>
            <div class="player-controls">
                <button id="prevAudio" class="btn-icon-sm"><i class="fa fa-backward"></i></button>
                <button id="togglePlayPause" class="btn-icon"><i class="fa fa-play"></i></button>
                <button id="nextAudio" class="btn-icon-sm"><i class="fa fa-forward"></i></button>
            </div>
            <div class="progress-container">
                <input type="range" id="audioProgress" value="0" max="100" step="0.1">
                <div class="time-display">
                    <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
                </div>
            </div>
        </div>


        <!-- 新建仓库弹窗 -->
        <div id="createRepoModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3><span class="modal-title-text">新建仓库</span><button class="btn-icon-sm" onclick="el.createRepoModal.classList.add('hidden')" title="关闭"><i class="fa fa-times"></i></button></h3>
                <input id="createRepoNameInput" placeholder="输入仓库名称（仅支持英文、数字、连字符）">
                <div id="repoNameError" class="text-red-400" style="font-size: 0.875rem; margin-top: -0.5rem; margin-bottom: 0.5rem; display: none;"></div>
                <textarea id="createRepoDescInput" placeholder="仓库描述（可选）"></textarea>
                <div class="checkbox-container">
                    <input type="checkbox" id="createRepoPrivate">
                    <label for="createRepoPrivate">公开仓库</label>
                </div>
                <div class="modal-buttons">
                    <button id="createRepoCancel" class="btn btn-cancel">取消</button>
                    <button id="createRepoConfirm" class="btn btn-primary" disabled>创建仓库</button>
                </div>
            </div>
        </div>

        <!-- 新建文件夹弹窗 -->
        <div id="createFolderModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3><span class="modal-title-text">新建文件夹</span><button class="btn-icon-sm" onclick="el.createFolderModal.classList.add('hidden')" title="关闭"><i class="fa fa-times"></i></button></h3>
                <input id="createFolderInput" placeholder="输入文件夹名称">
                <div class="modal-buttons">
                    <button id="createFolderCancel" class="btn btn-cancel">取消</button>
                    <button id="createFolderConfirm" class="btn btn-primary" disabled>确认</button>
                </div>
            </div>
        </div>

        <!-- 新建文件弹窗 -->
        <div id="createFileModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3><span class="modal-title-text">新建文件</span><button class="btn-icon-sm" onclick="el.createFileModal.classList.add('hidden')" title="关闭"><i class="fa fa-times"></i></button></h3>
                <input id="createFileNameInput" placeholder="输入文件名，如 example.txt">
                <textarea id="createFileContentInput" placeholder="文件内容（可选）"></textarea>
                <div class="modal-buttons">
                    <button id="createFileCancel" class="btn btn-cancel">取消</button>
                    <button id="createFileConfirm" class="btn btn-primary" disabled>确认</button>
                </div>
            </div>
        </div>

        <!-- 文件上传面板 -->
        <div id="uploadPanel" class="hidden">
            <div id="uploadItems" class="scmz"></div>
        </div>

        <!-- 代理设置主弹窗 (重新设计) -->
        <div id="proxySettingsModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3>
                    <span class="modal-title-text">代理设置</span>
                    <button id="proxyGlobalEnableToggle" class="btn-icon" title="点击切换全局代理状态">
                        <i class="fa fa-power-off"></i>
                    </button>
                </h3>

                <div class="proxy-list" id="proxyListContainer">
                    <!-- Proxy items will be rendered here by JS -->
                    <div class="empty-state" id="proxyListEmpty" style="padding:1rem;">
                        <i class="fa fa-plug"></i>
                        <p>暂无代理</p>
                    </div>
                </div>

                <div class="modal-buttons">
                    <!-- 按钮排序：删除全部，延迟检测，添加代理，关闭按钮 -->
                    <button id="proxyClearAllBtn" class="btn-icon danger" title="清空所有代理(保留默认)">
                        <i class="fa fa-trash"></i>
                    </button>
                    <button id="proxyTestAllBtn" class="btn-icon" title="全部测试延迟">
                        <i class="fa fa-flash"></i>
                        <span class="spinner-small hidden" id="proxyTestAllSpinner"></span>
                    </button>
                    <button id="proxyAddBtn" class="btn-icon" title="添加代理">
                        <i class="fa fa-plus"></i>
                    </button>
                    <button id="proxyCancelSettingsBtn" class="btn-icon" title="关闭设置">
                        <i class="fa fa-times"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- 代理添加/编辑弹窗 (优化) -->
        <div id="addEditProxyModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3 id="addEditProxyTitle">
                    <span class="modal-title-text">添加代理</span>
                    <button class="btn-icon-sm" onclick="closeAddEditProxyModal()" title="关闭">
                        <i class="fa fa-times"></i>
                    </button>
                </h3>
                <input id="addEditProxyUrlInput" type="url" placeholder="代理URL，例如：https://gh-proxy.com/" autocomplete="off">
                <div id="addEditProxyError" class="text-red-400" style="font-size: 0.875rem; margin-top: -0.5rem; margin-bottom: 0.5rem; display: none;"></div>

                <div class="modal-buttons" style="margin-top:0; flex-wrap: nowrap;">
                    <button id="addEditProxyTestBtn" class="btn btn-secondary">
                        测试 <span class="spinner-small hidden" id="addEditProxyTestSpinner"></span>
                    </button>
                    <!-- 测试结果直接显示在按钮旁边 -->
                    <div id="addEditProxyTestResult" style="flex:1; text-align:right; font-size:0.9rem; min-height:1.1rem; display:flex; align-items:center; justify-content:flex-end;"></div>
                </div>

                <div class="modal-buttons" style="margin-top:1rem;">
                    <button id="addEditProxySaveBtn" class="btn btn-primary" disabled>保存</button>
                </div>
            </div>
        </div>

        <!-- 确认删除代理弹窗 (新增和优化) -->
        <div id="confirmDeleteProxyModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3 id="confirmDeleteProxyTitle">
                    <span class="modal-title-text">确认删除</span>
                    <button class="btn-icon-sm" onclick="hideConfirmDeleteProxyModal()" title="取消">
                        <i class="fa fa-times"></i>
                    </button>
                </h3>
                <p id="confirmDeleteProxyMessage"></p>
                <div class="modal-buttons">
                    <button id="confirmDeleteProxyCancelBtn" class="btn btn-cancel">取消</button>
                    <button id="confirmDeleteProxyConfirmBtn" class="btn btn-danger">确认删除</button>
                </div>
            </div>
        </div>

        <!-- 确认清空所有代理弹窗 (新增) -->
        <div id="confirmClearAllProxiesModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3>
                    <span class="modal-title-text">确认清空所有代理</span>
                    <button class="btn-icon-sm" onclick="hideConfirmClearAllProxiesModal()" title="取消">
                        <i class="fa fa-times"></i>
                    </button>
                </h3>
                <p>确定要清空所有自定义代理吗？这将只保留从外部链接获取的默认代理。此操作不可撤销。</p>
                <div class="modal-buttons">
                    <button id="clearAllProxiesCancelBtn" class="btn btn-cancel">取消</button>
                    <button id="clearAllProxiesConfirmBtn" class="btn btn-danger">确认清空</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 状态管理
        const state = {
            token: localStorage.getItem('gh_token') || null,
            currentRepo: null,
            currentPath: '',
            files: [],
            displayFiles: [],
            repos: [],
            selectedFile: null,
            selectedRepo: null,
            uploadQueue: [],
            editingFile: null,
            fileSha: '',
            originalContent: '',
            // 代理相关新增/修改
            proxies: JSON.parse(localStorage.getItem('proxies') || '[]'), // 初始为空，由外部链接填充
            activeProxyIndex: parseInt(localStorage.getItem('active_proxy_index') || '0'), // 当前活动代理的索引
            proxyGlobalEnable: JSON.parse(localStorage.getItem('proxy_global_enable') || 'true'), // 全局代理开关
            editingProxyIndex: null, // 正在编辑的代理索引，null表示添加新代理
            lastTestResult: null, // 记录 addEditProxyModal 中上次测试结果
            lastTestUrl: null, // 记录 addEditProxyModal 中上次测试的URL
            defaultProxyFromExternal: null, // 存储从外部获取的默认代理URL

            navHistory: ['root'],
            fileCache: new Map(),
            viewMode: localStorage.getItem('view_mode') || 'list', // 'list' | 'grid'
            sortBy: localStorage.getItem('sort_by') || 'name_asc',
            searchQuery: '',

            // 音乐播放器相关新增
            audioPlayer: new Audio(),
            audioPlaylist: [], // 当前目录下的可播放音频文件
            currentAudioIndex: -1, // 当前播放歌曲在播放列表中的索引
            isAudioPlaying: false,
            audioLooping: true, // 默认循环播放
        };


        // DOM元素引用
        const el = {
            authScreen: document.getElementById('authScreen'),
            app: document.getElementById('app'),
            tokenInput: document.getElementById('tokenInput'),
            authBtn: document.getElementById('authBtn'),
            fileList: document.getElementById('fileList'),
            repoList: document.getElementById('repoList'),
            pathNav: document.getElementById('pathNav'),
            pathNavContainer: document.getElementById('pathNavContainer'),
            currentRepo: document.getElementById('currentRepo'),
            backBtn: document.getElementById('backBtn'),
            newFolderBtn: document.getElementById('newFolderBtn'),
            uploadBtn: document.getElementById('uploadBtn'),
            modalOverlay: document.getElementById('modalOverlay'), // 通用模态框
            modalContent: document.getElementById('modalContent'), // 通用模态框内容
            contextMenu: document.getElementById('contextMenu'),
            contextMenuItems: document.getElementById('contextMenuItems'),
            toast: document.getElementById('toast'),
            toastMessage: document.getElementById('toastMessage'),
            uploadPanel: document.getElementById('uploadPanel'),
            uploadItems: document.getElementById('uploadItems'),
            editModal: document.getElementById('editModal'),
            editFileName: document.getElementById('editFileName'),
            fileContent: document.getElementById('fileContent'),
            closeEditModal: document.getElementById('closeEditModal'),
            cancelEdit: document.getElementById('cancelEdit'),
            saveEdit: document.getElementById('saveEdit'),
            editStatus: document.getElementById('editStatus'),
            editorOverlay: document.getElementById('editorOverlay'),
            saveNotification: document.getElementById('saveNotification'),
            fileUploadInput: document.getElementById('fileUploadInput'),
            mainMenuPopup: document.getElementById('mainMenuPopup'),
            menuLogout: document.getElementById('menuLogout'),
            menuRepoList: document.getElementById('menuRepoList'),
            menuRefresh: document.getElementById('menuRefresh'),
            newFileBtn: document.getElementById('newFileBtn'),
            mainMenuBtn: document.getElementById('mainMenuBtn'),
            toolbar: document.getElementById('toolbar'),
            searchInput: document.getElementById('searchInput'),
            sortSelect: document.getElementById('sortSelect'),
            viewToggleBtn: document.getElementById('viewToggleBtn'),
            proxyQuickToggle: document.getElementById('proxyQuickToggle'),
            menuProxySettings: document.getElementById('menuProxySettings'),

            // 新增菜单相关DOM
            userAvatar: document.getElementById('userAvatar'),
            userName: document.getElementById('userName'),
            rateLimitUsed: document.getElementById('rateLimitUsed'),
            rateLimitTotal: document.getElementById('rateLimitTotal'),
            rateLimitRemaining: document.getElementById('rateLimitRemaining'),
            rateLimitProgressBar: document.getElementById('rateLimitProgressBar'),
            rateLimitReset: document.getElementById('rateLimitReset'),

            // 代理设置主弹窗相关DOM
            proxySettingsModal: document.getElementById('proxySettingsModal'),
            proxyGlobalEnableToggle: document.getElementById('proxyGlobalEnableToggle'), // 切换为图标按钮
            proxyAddBtn: document.getElementById('proxyAddBtn'), // 触发 addEditProxyModal 的按钮
            proxyListContainer: document.getElementById('proxyListContainer'),
            proxyListEmpty: document.getElementById('proxyListEmpty'),
            proxyTestAllBtn: document.getElementById('proxyTestAllBtn'),
            proxyTestAllSpinner: document.getElementById('proxyTestAllSpinner'),
            proxyClearAllBtn: document.getElementById('proxyClearAllBtn'),
            proxyCancelSettingsBtn: document.getElementById('proxyCancelSettingsBtn'),

            // 代理添加/编辑弹窗相关DOM
            addEditProxyModal: document.getElementById('addEditProxyModal'),
            addEditProxyTitle: document.getElementById('addEditProxyTitle'),
            addEditProxyUrlInput: document.getElementById('addEditProxyUrlInput'),
            addEditProxyError: document.getElementById('addEditProxyError'),
            addEditProxyTestBtn: document.getElementById('addEditProxyTestBtn'),
            addEditProxyTestSpinner: document.getElementById('addEditProxyTestSpinner'),
            addEditProxyTestResult: document.getElementById('addEditProxyTestResult'),
            addEditProxySaveBtn: document.getElementById('addEditProxySaveBtn'),

            // 确认删除代理弹窗 (新增)
            confirmDeleteProxyModal: document.getElementById('confirmDeleteProxyModal'),
            confirmDeleteProxyTitle: document.getElementById('confirmDeleteProxyTitle'),
            confirmDeleteProxyMessage: document.getElementById('confirmDeleteProxyMessage'),
            confirmDeleteProxyCancelBtn: document.getElementById('confirmDeleteProxyCancelBtn'),
            confirmDeleteProxyConfirmBtn: document.getElementById('confirmDeleteProxyConfirmBtn'),

            // 确认清空所有代理弹窗 (新增)
            confirmClearAllProxiesModal: document.getElementById('confirmClearAllProxiesModal'),
            clearAllProxiesCancelBtn: document.getElementById('clearAllProxiesCancelBtn'),
            clearAllProxiesConfirmBtn: document.getElementById('clearAllProxiesConfirmBtn'),

            // 其他弹窗DOM
            renameModal: document.getElementById('renameModal'),
            renameTitle: document.getElementById('renameTitle'),
            renameInput: document.getElementById('renameInput'),
            renameWarn: document.getElementById('renameWarn'),
            renameCancel: document.getElementById('renameCancel'),
            renameConfirm: document.getElementById('renameConfirm'),
            deleteModal: document.getElementById('deleteModal'),
            deleteTitle: document.getElementById('deleteTitle'),
            deleteDesc: document.getElementById('deleteDesc'),
            deleteCancel: document.getElementById('deleteCancel'),
            deleteConfirm: document.getElementById('deleteConfirm'),
            createRepoModal: document.getElementById('createRepoModal'),
            createRepoNameInput: document.getElementById('createRepoNameInput'),
            createRepoDescInput: document.getElementById('createRepoDescInput'),
            createRepoPrivate: document.getElementById('createRepoPrivate'),
            repoNameError: document.getElementById('repoNameError'),
            createRepoCancel: document.getElementById('createRepoCancel'),
            createRepoConfirm: document.getElementById('createRepoConfirm'),
            createFolderModal: document.getElementById('createFolderModal'),
            createFolderInput: document.getElementById('createFolderInput'),
            createFolderCancel: document.getElementById('createFolderCancel'),
            createFolderConfirm: document.getElementById('createFolderConfirm'),
            createFileModal: document.getElementById('createFileModal'),
            createFileNameInput: document.getElementById('createFileNameInput'),
            createFileContentInput: document.getElementById('createFileContentInput'),
            createFileCancel: document.getElementById('createFileCancel'),
            createFileConfirm: document.getElementById('createFileConfirm'),

            // 音乐播放器相关DOM引用
            audioPlayer: document.getElementById('audioPlayer'),
            audioPlayerHandle: document.getElementById('audioPlayerHandle'),
            playerCurrentSong: document.getElementById('playerCurrentSong'),
            closeAudioPlayer: document.getElementById('closeAudioPlayer'),
            prevAudio: document.getElementById('prevAudio'),
            togglePlayPause: document.getElementById('togglePlayPause'),
            nextAudio: document.getElementById('nextAudio'),
            audioProgress: document.getElementById('audioProgress'),
            currentTime: document.getElementById('currentTime'),
            totalTime: document.getElementById('totalTime'),
        };

        // 工具函数
        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const icons = {
                js: 'fa-code',
                html: 'fa-html5',
                css: 'fa-css3',
                json: 'fa-file-code-o',
                md: 'fa-file-text-o',
                png: 'fa-file-image-o',
                jpg: 'fa-file-image-o',
                jpeg: 'fa-file-image-o',
                gif: 'fa-file-image-o',
                pdf: 'fa-file-pdf-o',
                zip: 'fa-file-zip-o',
                git: 'fa-git',
                mp3: 'fa-music',
                wav: 'fa-music',
                ogg: 'fa-music',
                flac: 'fa-music',
                m4a: 'fa-music',
                mp4: 'fa-film',
                webm: 'fa-film',
                mov: 'fa-film',
                mkv: 'fa-film',
                avi: 'fa-film'
            };
            return icons[ext] || 'fa-file-o';
        }

        function formatSize(bytes) {
            if (!bytes && bytes !== 0) return '';
            const k = 1024,
                sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.max(0, Math.log(bytes || 1) / Math.log(k)));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatRelativeTime(date) {
            const diffMs = new Date() - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);
            if (diffMins < 1) return '刚刚';
            if (diffMins < 60) return `${diffMins}分钟前`;
            if (diffHours < 24) return `${diffHours}小时前`;
            if (diffDays < 30) return `${diffDays}天前`;
            return date.toLocaleDateString();
        }

        function escapeHtml(unsafe) {
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;")
                .replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        /**
         * 根据当前代理设置获取代理后的URL
         * @param {string} url 原始URL
         * @returns {string} 代理后的URL或原始URL
         */
        function getProxiedUrl(url) {
            if (!state.proxyGlobalEnable || state.proxies.length === 0 || state.activeProxyIndex === -1) {
                return url; // 全局代理未启用，或没有可用代理
            }
            const activeProxy = state.proxies[state.activeProxyIndex];
            if (!activeProxy || !activeProxy.url || activeProxy.status === 'fail') {
                return url; // 活动代理无效或测试失败，使用原始URL
            }
            let base = (activeProxy.url || '').trim();
            if (!base.endsWith('/')) base += '/';
            // 确保只代理 github.com 或 raw.githubusercontent.com 的链接
            if (url.startsWith('https://github.com/') || url.startsWith('https://raw.githubusercontent.com/')) {
                return base + url.replace(/^https?:\/\//, ''); // 移除协议头，防止双重协议
            }
            return url; // 其他链接不代理
        }


        function applyFiltersAndSort() {
            let arr = Array.isArray(state.files) ? [...state.files] : [];
            const q = (state.searchQuery || '').toLowerCase();
            if (q) {
                arr = arr.filter(f => (f.name || '').toLowerCase().includes(q));
            }
            const by = state.sortBy;
            const sorters = {
                name_asc: (a, b) => a.type === b.type ? a.name.localeCompare(b.name) : a.type === 'dir' ? -1 : 1,
                name_desc: (a, b) => a.type === b.type ? b.name.localeCompare(a.name) : a.type === 'dir' ? -1 : 1,
                time_desc: (a, b) => {
                    const ta = a.last_modified ? +new Date(a.last_modified) : 0;
                    const tb = b.last_modified ? +new Date(b.last_modified) : 0;
                    if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                    return tb - ta;
                },
                time_asc: (a, b) => {
                    const ta = a.last_modified ? +new Date(a.last_modified) : 0;
                    const tb = b.last_modified ? +new Date(b.last_modified) : 0;
                    if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                    return ta - tb;
                },
                size_desc: (a, b) => {
                    if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                    return (b.size || 0) - (a.size || 0);
                },
                size_asc: (a, b) => {
                    if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                    return (a.size || 0) - (b.size || 0);
                }
            };
            (sorters[by] || sorters.name_asc) && arr.sort(sorters[by]);
            state.displayFiles = arr;
        }

        function updateFileListViewMode() {
            if (!el.fileList) return;
            if (state.viewMode === 'grid') {
                el.fileList.classList.add('grid');
                el.viewToggleBtn && el.viewToggleBtn.classList.add('active');
                if (el.viewToggleBtn) {
                    el.viewToggleBtn.title = '切换为列表视图';
                    el.viewToggleBtn.innerHTML = '<i class="fa fa-list"></i>';
                }
            } else {
                el.fileList.classList.remove('grid');
                el.viewToggleBtn && el.viewToggleBtn.classList.remove('active');
                if (el.viewToggleBtn) {
                    el.viewToggleBtn.title = '切换为网格视图';
                    el.viewToggleBtn.innerHTML = '<i class="fa fa-th-large"></i>';
                }
            }
        }

        /**
         * 更新代理快速切换开关的UI状态
         */
        function updateProxyUI() {
            const on = !!state.proxyGlobalEnable && state.proxies.length > 0 && state.activeProxyIndex !== -1 && state.proxies[state.activeProxyIndex]?.status !== 'fail';
            if (el.proxyQuickToggle) {
                el.proxyQuickToggle.classList.toggle('active', on);
                const currentProxy = state.proxies[state.activeProxyIndex];
                el.proxyQuickToggle.title = on && currentProxy ? `代理已开启 (${currentProxy.url})` : '代理已关闭';
            }
        }

        /* 视图控制 */
        function toggleView(showRepoList) {
            if (showRepoList) {
                el.repoList.classList.remove('hidden');
                el.fileList.classList.add('hidden');
                el.pathNavContainer.classList.add('hidden');
                el.currentRepo.textContent = '选择仓库';
                el.newFolderBtn.title = '新建仓库';
                el.newFolderBtn.innerHTML = '<i class="fa fa-plus"></i>';
                el.toolbar && el.toolbar.classList.add('hidden');
            } else {
                el.repoList.classList.add('hidden');
                el.fileList.classList.remove('hidden');
                el.pathNavContainer.classList.remove('hidden');
                el.newFolderBtn.title = '新建文件夹';
                el.newFolderBtn.innerHTML = '<i class="fa fa-folder"></i>';
                el.toolbar && el.toolbar.classList.remove('hidden');
                updateFileListViewMode();
            }
        }

        function showAuth() {
            el.authScreen.classList.remove('hidden');
            el.app.classList.add('hidden');
        }

        function showApp() {
            el.authScreen.classList.add('hidden');
            el.app.classList.remove('hidden');
        }

        // 通用模态框，用于提示、确认等
        function showModal(content) {
            el.modalContent.innerHTML = content;
            el.modalOverlay.classList.remove('hidden');
            el.modalOverlay.classList.add('flex'); // 确保显示
        }

        function hideModal() {
            el.modalOverlay.classList.add('hidden');
            el.modalOverlay.classList.remove('flex');
            el.modalContent.innerHTML = ''; // 清空内容
        }

        function showToast(message) {
            el.toastMessage.textContent = message;
            el.toast.classList.remove('hidden');
            setTimeout(() => el.toast.classList.add('hidden'), 3000);
        }

        function showSaveNotification() {
            el.saveNotification.classList.add('show');
            setTimeout(() => el.saveNotification.classList.remove('show'), 3000);
        }

        let rateLimitResetInterval = null; // 用于存储计时器

        // 控制主菜单显示/隐藏
        function toggleMainMenuPopup() {
            const isCurrentlyHidden = el.mainMenuPopup.classList.contains('hidden');
            if (isCurrentlyHidden) {
                showMainMenuPopup();
            } else {
                hideMainMenuPopup();
            }
        }

        async function showMainMenuPopup() {
            el.mainMenuPopup.classList.remove('hidden');
            // 强制回流以确保动画从初始状态开始
            el.mainMenuPopup.offsetWidth;
            el.mainMenuPopup.style.opacity = '1';
            el.mainMenuPopup.style.transform = 'scale(1)';

            // 首次显示时或需要时，获取并显示用户信息和速率限制
            await fetchUserInfoAndRateLimit();
            // 启动定时更新速率限制剩余时间的计时器
            if (rateLimitResetInterval) clearInterval(rateLimitResetInterval);
            rateLimitResetInterval = setInterval(updateRateLimitResetTime, 1000);
        }

        function hideMainMenuPopup() {
            el.mainMenuPopup.style.opacity = '0';
            el.mainMenuPopup.style.transform = 'scale(0.95)';
            el.mainMenuPopup.addEventListener('transitionend', function handler() {
                el.mainMenuPopup.classList.add('hidden');
                el.mainMenuPopup.removeEventListener('transitionend', handler);
            }, {
                once: true
            });

            // 停止定时更新速率限制剩余时间的计时器
            if (rateLimitResetInterval) {
                clearInterval(rateLimitResetInterval);
                rateLimitResetInterval = null;
            }
        }

        /**
         * 获取 GitHub 用户信息和 API 速率限制
         */
        async function fetchUserInfoAndRateLimit() {
            if (!state.token) {
                el.userName.textContent = '未登录';
                el.userAvatar.classList.add('hidden');
                el.rateLimitUsed.textContent = 'N/A';
                el.rateLimitTotal.textContent = 'N/A';
                el.rateLimitRemaining.textContent = 'N/A';
                el.rateLimitProgressBar.style.width = '0%';
                el.rateLimitProgressBar.className = 'rate-limit-bar';
                el.rateLimitReset.textContent = '';
                return;
            }

            try {
                // 获取用户信息
                const userRes = await fetch('https://api.github.com/user', {
                    headers: {
                        Authorization: `token ${state.token}`,
                        'User-Agent': 'Mozilla/5.0'
                    }
                });
                const userData = await userRes.json();
                if (userRes.ok) {
                    el.userName.textContent = userData.login;
                    el.userAvatar.src = userData.avatar_url;
                    el.userAvatar.classList.remove('hidden');
                } else {
                    el.userName.textContent = '获取用户失败';
                    el.userAvatar.classList.add('hidden');
                }

                // 获取速率限制信息
                const limitRes = await fetch('https://api.github.com/rate_limit', {
                    headers: {
                        Authorization: `token ${state.token}`,
                        'User-Agent': 'Mozilla/5.0'
                    }
                });
                const limitData = await limitRes.json();
                if (limitRes.ok) {
                    const {
                        core
                    } = limitData.resources;
                    updateRateLimitDisplay(core.used, core.limit, core.remaining, core.reset);
                } else {
                    el.rateLimitUsed.textContent = 'N/A';
                    el.rateLimitTotal.textContent = 'N/A';
                    el.rateLimitRemaining.textContent = 'N/A';
                    el.rateLimitProgressBar.style.width = '0%';
                    el.rateLimitProgressBar.className = 'rate-limit-bar';
                    el.rateLimitReset.textContent = '获取限制失败';
                }

            } catch (error) {
                console.error('获取用户信息或速率限制失败:', error);
                el.userName.textContent = '加载失败';
                el.userAvatar.classList.add('hidden');
                el.rateLimitUsed.textContent = 'N/A';
                el.rateLimitTotal.textContent = 'N/A';
                el.rateLimitRemaining.textContent = 'N/A';
                el.rateLimitProgressBar.style.width = '0%';
                el.rateLimitProgressBar.className = 'rate-limit-bar';
                el.rateLimitReset.textContent = '加载失败';
            }
        }

        /**
         * 更新速率限制显示
         * @param {number} used 已用配额
         * @param {number} limit 总配额
         * @param {number} remaining 剩余配额
         * @param {number} resetTime 重置时间戳 (UTC 秒)
         */
        function updateRateLimitDisplay(used, limit, remaining, resetTime) {
            el.rateLimitUsed.textContent = used;
            el.rateLimitTotal.textContent = limit;
            el.rateLimitRemaining.textContent = remaining;

            const percentage = (used / limit) * 100;
            el.rateLimitProgressBar.style.width = `${percentage}%`;

            el.rateLimitProgressBar.className = 'rate-limit-bar'; // Reset class
            if (percentage > 80) {
                el.rateLimitProgressBar.classList.add('critical');
            } else if (percentage > 50) {
                el.rateLimitProgressBar.classList.add('warning');
            }

            // 存储重置时间以供定时器更新
            el.rateLimitProgressBar.dataset.resetTime = resetTime;
            updateRateLimitResetTime(); // 立即更新一次
        }

        /**
         * 更新速率限制重置倒计时
         */
        function updateRateLimitResetTime() {
            const resetTimestamp = el.rateLimitProgressBar.dataset.resetTime;
            if (!resetTimestamp) {
                el.rateLimitReset.textContent = '';
                return;
            }

            const now = Date.now() / 1000; // 当前时间戳 (秒)
            const secondsLeft = Math.max(0, Math.floor(parseInt(resetTimestamp) - now));

            if (secondsLeft <= 0) {
                el.rateLimitReset.textContent = '已重置';
                // 此时可以考虑再次调用 fetchUserInfoAndRateLimit 刷新数据
                // 或者等待用户手动刷新
                if (rateLimitResetInterval) clearInterval(rateLimitResetInterval);
                setTimeout(() => fetchUserInfoAndRateLimit(), 1000); // 延迟1秒刷新以确保API更新
                return;
            }

            const minutes = Math.floor(secondsLeft / 60);
            const seconds = secondsLeft % 60;
            el.rateLimitReset.textContent = `重置于 ${minutes}分 ${seconds}秒 后`;
        }

        // 在 fetchRepos 函数前添加
        function loadReposFromCache() {
            const cachedRepos = localStorage.getItem('cached_repos');
            const cacheTime = localStorage.getItem('repos_cache_time');
            if (cachedRepos && cacheTime) {
                try {
                    state.repos = JSON.parse(cachedRepos);
                    renderRepoList();
                    showRepoListView();
                    setTimeout(() => {
                        fetchReposInBackground();
                    }, 1000);
                    return;
                } catch (e) {
                    console.error('缓存数据解析失败:', e);
                }
            }
            fetchRepos();
        }

        // 后台静默更新仓库列表
        async function fetchReposInBackground() {
            try {
                const res = await fetch('https://api.github.com/user/repos?timestamp=' + Date.now(), {
                    headers: {
                        Authorization: `token ${state.token}`,
                        'User-Agent': 'Mozilla/5.0'
                    }
                });
                if (res.ok) {
                    const repos = await res.json();
                    localStorage.setItem('cached_repos', JSON.stringify(repos));
                    localStorage.setItem('repos_cache_time', Date.now().toString());
                }
            } catch (err) {
                console.log('后台更新失败:', err);
            }
        }

        // 仓库管理
        async function fetchRepos() {
            try {
                state.repos = [];
                el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
                const res = await fetch('https://api.github.com/user/repos?timestamp=' + Date.now(), {
                    headers: {
                        Authorization: `token ${state.token}`,
                        'User-Agent': 'Mozilla/5.0'
                    }
                });
                if (!res.ok) throw new Error('获取仓库失败');
                state.repos = await res.json();
                localStorage.setItem('cached_repos', JSON.stringify(state.repos));
                localStorage.setItem('repos_cache_time', Date.now().toString());
                renderRepoList();
                showRepoListView();
            } catch (err) {
                showToast('加载仓库失败');
                console.error(err);
            }
        }

        function renderRepoList() {
            state.repos.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
            el.repoList.innerHTML = state.repos.length === 0 ? '<div class="empty-state"><i class="fa fa-github"></i><p>没有找到仓库</p></div>' : '';
            state.repos.forEach(repo => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                <div class="file-icon"><i class="fa fa-github"></i></div>
                <div class="file-info">
                    <p class="file-name">${repo.name}</p>
                    <p class="file-meta">
                        ${repo.private ? '私有仓库' : '公开仓库'} ${repo.size || repo.updated_at ? ' · ' : ''}
                        ${repo.size ? formatSize(repo.size * 1024) : ''}
                        ${repo.size && repo.updated_at ? ' · ' : ''}
                        ${formatRelativeTime(new Date(repo.updated_at))}
                    </p>
                    <p class="file-meta">${repo.description || ''}</p>
                </div>
            `;
                item.addEventListener('click', () => {
                    state.currentRepo = repo.full_name;
                    state.currentPath = '';
                    el.currentRepo.textContent = repo.name;
                    renderPathNav();
                    fetchFiles();
                    toggleView(false);
                });

                // **修改开始：鼠标右键和长按事件处理**
                let pressTimer = null; // 为每个item单独定义计时器

                // 监听 touchstart (触屏长按)
                item.addEventListener('touchstart', (e) => {
                    // 仅在单指触摸时启动长按计时，避免与双指缩放等手势冲突
                    if (e.touches.length === 1) {
                        pressTimer = setTimeout(() => {
                            e.preventDefault(); // 阻止默认的触摸行为，如滚动
                            state.selectedRepo = repo;
                            showRepoContextMenu(e, repo);
                            pressTimer = null; // 动作完成后重置计时器
                        }, 500); // 仓库列表长按时间
                    }
                }, {
                    passive: false
                }); // 使用 { passive: false } 允许 preventDefault

                // 监听 mousedown (鼠标左键长按)
                item.addEventListener('mousedown', (e) => {
                    // 仅在鼠标左键按下时启动长按计时
                    if (e.button === 0) { // 0 代表鼠标左键
                        pressTimer = setTimeout(() => {
                            e.preventDefault(); // 阻止默认的鼠标选择文本等行为
                            state.selectedRepo = repo;
                            showRepoContextMenu(e, repo);
                            pressTimer = null; // 动作完成后重置计时器
                        }, 500); // 仓库列表长按时间
                    }
                });

                // 清除计时器：在按压结束（touchend, mouseup）或移出元素（mouseleave, touchcancel）时
                ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(event => {
                    item.addEventListener(event, () => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                });

                // 监听 contextmenu (鼠标右键，直接触发)
                item.addEventListener('contextmenu', (e) => {
                    e.preventDefault(); // 核心：阻止浏览器默认的右键菜单
                    if (pressTimer) { // 如果有长按计时器正在运行，清除它
                        clearTimeout(pressTimer);
                        pressTimer = null;
                    }
                    state.selectedRepo = repo;
                    showRepoContextMenu(e, repo);
                });
                // **修改结束**

                el.repoList.appendChild(item);
            });
        }

        function showRepoListView() {
            el.repoList.classList.remove('hidden');
            el.fileList.classList.add('hidden');
            el.pathNavContainer.classList.add('hidden');
            el.currentRepo.textContent = '选择仓库';
            toggleView(true);
            state.currentRepo = null;
            state.currentPath = '';
        }

        // 文件管理
        async function fetchFiles(forceRefresh = false) {
            if (!state.currentRepo) return;
            const cacheKey = `${state.currentRepo}:${state.currentPath}`;
            if (!forceRefresh && state.fileCache.has(cacheKey)) {
                state.files = state.fileCache.get(cacheKey);
                applyFiltersAndSort();
                renderFileList();
                setTimeout(() => {
                    fetchFilesInBackground(cacheKey);
                }, 2000);
                return;
            }
            await fetchFilesFromNetwork(cacheKey);
        }

        async function fetchFilesFromNetwork(cacheKey) {
            el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
            try {
                const timestamp = Date.now();
                const res = await fetch(`https://api.github.com/repos/${state.currentRepo}/contents/${state.currentPath}?t=${timestamp}`, {
                    headers: {
                        Authorization: `token ${state.token}`,
                        'User-Agent': 'Mozilla/5.0'
                    },
                    cache: 'no-store'
                });
                if (!res.ok) {
                    if (res.status === 404) {
                        state.files = [];
                        applyFiltersAndSort();
                        renderFileList();
                        return;
                    }
                    throw new Error('加载文件失败');
                }
                const data = await res.json();
                if (data.message) throw new Error(data.message);
                state.files = Array.isArray(data) ? data : [];
                state.files.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));
                state.fileCache.set(cacheKey, [...state.files]);

                await Promise.all(state.files.map(async (file) => {
                    try {
                        const [owner, repo] = state.currentRepo.split('/');
                        const r = await fetch(`https://api.github.com/repos/${owner}/${repo}/commits?path=${file.path}&per_page=1`, {
                            headers: {
                                Authorization: `token ${state.token}`,
                                'User-Agent': 'Mozilla/5.0'
                            }
                        });
                        const commits = await r.json();
                        if (Array.isArray(commits) && commits.length > 0) {
                            file.last_modified = commits[0].commit.committer.date;
                        }
                    } catch (e) {
                        file.last_modified = null;
                    }
                }));
                state.fileCache.set(cacheKey, [...state.files]);
                applyFiltersAndSort();
                renderFileList();
            } catch (err) {
                if (err.message.includes('404')) {
                    state.files = [];
                    applyFiltersAndSort();
                    renderFileList();
                    return;
                }
                showToast('加载文件失败: ' + err.message);
                console.error(err);
            }
        }

        async function fetchFilesInBackground(cacheKey) {
            try {
                const timestamp = Date.now();
                const res = await fetch(`https://api.github.com/repos/${state.currentRepo}/contents/${state.currentPath}?t=${timestamp}`, {
                    headers: {
                        Authorization: `token ${state.token}`,
                        'User-Agent': 'Mozilla/5.0'
                    },
                    cache: 'no-store'
                });
                if (res.ok) {
                    const data = await res.json();
                    if (!data.message && Array.isArray(data)) {
                        const files = data.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));
                        state.fileCache.set(cacheKey, [...files]);
                    }
                }
            } catch (err) {
                console.log('后台文件更新失败:', err);
            }
        }

        function renderFileList() {
            const list = (state.displayFiles && state.displayFiles.length >= 0) ? state.displayFiles : state.files;
            el.fileList.innerHTML = (!list || list.length === 0) ? '<div class="empty-state"><i class="fa fa-github"></i><p>仓库为空</p></div>' : '';
            (list || []).forEach((file) => {
                const isDir = file.type === 'dir';
                const icon = isDir ? 'fa-folder' : getFileIcon(file.name);
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                <div class="file-icon"><i class="fa ${icon}"></i></div>
                <div class="file-info">
                    <p class="file-name">${file.name}</p>
                    <p class="file-meta">
                        ${isDir ? '文件夹' : formatSize(file.size)} · ${file.last_modified ? formatRelativeTime(new Date(file.last_modified)) : '加载中'}
                    </p>
                </div>
            `;
                item.addEventListener('click', (e) => {
                    if (e.imagePreviewAction) return;
                    isDir ? navigateToDir(file.name) : editFile(file);
                });

                // **修改开始：鼠标右键和长按事件处理**
                let pressTimer = null; // 为每个item单独定义计时器

                // 监听 touchstart (触屏长按)
                item.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        pressTimer = setTimeout(() => {
                            e.preventDefault();
                            showContextMenu(e, file);
                            pressTimer = null; // 动作完成后重置计时器
                        }, 700); // 文件列表长按时间
                    }
                }, {
                    passive: false
                }); // 使用 { passive: false } 允许 preventDefault

                // 监听 mousedown (鼠标左键长按)
                item.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 0 代表鼠标左键
                        pressTimer = setTimeout(() => {
                            e.preventDefault();
                            showContextMenu(e, file);
                            pressTimer = null; // 动作完成后重置计时器
                        }, 700); // 文件列表长按时间
                    }
                });

                // 清除计时器：在按压结束（touchend, mouseup）或移出元素（mouseleave, touchcancel）时
                ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(event => {
                    item.addEventListener(event, () => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                });

                // 监听 contextmenu (鼠标右键，直接触发)
                item.addEventListener('contextmenu', (e) => {
                    e.preventDefault(); // 核心：阻止浏览器默认的右键菜单
                    if (pressTimer) { // 如果有长按计时器正在运行，清除它
                        clearTimeout(pressTimer);
                        pressTimer = null;
                    }
                    showContextMenu(e, file);
                });
                // **修改结束**

                el.fileList.appendChild(item);
            });
        }

        // 路径导航
        function renderPathNav() {
            el.pathNav.innerHTML = '';
            const parts = state.currentPath.split('/').filter(p => p);
            let currentPath = '';
            addPathItem('/', '');
            parts.forEach((part) => {
                currentPath += part + '/';
                addPathItem(part, currentPath);
            });
        }

        function addPathItem(name, path) {
            const item = document.createElement('span');
            item.className = 'path-item';
            item.textContent = name;
            item.dataset.path = path;
            item.addEventListener('click', () => {
                el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
                navigateToPath(path);
            });
            el.pathNav.appendChild(item);
            if (name !== '/') el.pathNav.appendChild(document.createTextNode(' / '));
        }

        function navigateToDir(dirName) {
            const newPath = state.currentPath ? `${state.currentPath}${dirName}/` : `${dirName}/`;
            state.navHistory.push(newPath);
            state.currentPath = newPath;
            renderPathNav();
            fetchFiles();
        }

        function navigateToPath(path) {
            state.navHistory.push(path);
            state.currentPath = path;
            renderPathNav();
            fetchFiles();
        }

        // 事件监听
        function setupEventListeners() {
            // 新建文件夹/仓库按钮
            el.newFolderBtn.onclick = function() {
                if (!state.currentRepo) {
                    showCreateRepoModal();
                } else {
                    showCreateFolderModal();
                }
            };

            // 认证相关
            el.authBtn.addEventListener('click', () => {
                const token = el.tokenInput.value.trim();
                if (token) {
                    localStorage.setItem('gh_token', token);
                    state.token = token;
                    showApp();
                    fetchRepos();
                    updateProxyUI();
                } else {
                    showToast('请输入令牌');
                }
            });

            // 主菜单按钮
            el.mainMenuBtn.onclick = (e) => {
                e.stopPropagation();
                hideContextMenu();
                toggleMainMenuPopup(); // 调用新函数
            };

            // 点击别处关闭主菜单
            document.addEventListener('click', function(e) {
                // 修改此处逻辑以适应新的动画控制
                if (!el.mainMenuPopup.classList.contains('hidden')) {
                    if (!el.mainMenuPopup.contains(e.target) && e.target !== el.mainMenuBtn) {
                        hideMainMenuPopup(); // 调用新函数
                    }
                }
            });

            // 菜单项事件
            el.menuRepoList.onclick = () => {
                hideMainMenuPopup(); // 关闭菜单
                showRepoListView();
            };

            el.menuRefresh.onclick = () => {
                hideMainMenuPopup(); // 关闭菜单
                if (!state.currentRepo) {
                    fetchRepos();
                } else {
                    fetchFiles(true);
                }
            };

            el.menuLogout.onclick = () => {
                hideMainMenuPopup(); // 关闭菜单
                localStorage.removeItem('gh_token');
                state.token = null;
                state.repos = [];
                state.currentRepo = null;
                showAuth();
            };

            // 代理快速开关
            el.proxyQuickToggle.addEventListener('click', () => {
                if (state.proxies.length === 0 || state.activeProxyIndex === -1) {
                    showToast('无可用代理，无法启用。');
                    state.proxyGlobalEnable = false; // 确保关闭
                } else {
                    state.proxyGlobalEnable = !state.proxyGlobalEnable;
                    showToast(state.proxyGlobalEnable ? '代理已开启' : '代理已关闭');
                }
                localStorage.setItem('proxy_global_enable', JSON.stringify(state.proxyGlobalEnable));
                updateProxyUI();
            });

            // 主菜单 -> 代理设置
            el.menuProxySettings.addEventListener('click', () => {
                hideMainMenuPopup(); // 关闭菜单
                openProxySettingsModal();
            });

            // 编辑相关
            el.saveEdit.addEventListener('click', saveEditedFile);
            el.closeEditModal.onclick = hideEditModal;
            el.cancelEdit.onclick = hideEditModal;

            // 点击或滑动任意位置关闭上下文菜单
            document.addEventListener('click', hideContextMenu);
            document.addEventListener('touchstart', (e) => {
                if (!el.contextMenu.contains(e.target)) hideContextMenu();
            });
            document.addEventListener('touchmove', (e) => {
                if (!el.contextMenu.contains(e.target)) hideContextMenu();
            });

            // 点击空白处关闭通用模态框
            el.modalOverlay.addEventListener('click', (e) => {
                if (e.target === el.modalOverlay) hideModal();
            });

            // 返回按钮
            el.backBtn.onclick = goUp;

            // 新建文件
            el.newFileBtn.onclick = showCreateFileModal;

            // 上传文件
            el.uploadBtn.onclick = handleUploadClick;
            el.fileUploadInput.addEventListener('change', handleFilesSelected);

            // Toolbar: 搜索/排序/视图
            if (el.sortSelect) el.sortSelect.value = state.sortBy;
            if (el.searchInput) {
                el.searchInput.addEventListener('input', () => {
                    state.searchQuery = el.searchInput.value || '';
                    applyFiltersAndSort();
                    renderFileList();
                });
            }
            if (el.sortSelect) {
                el.sortSelect.addEventListener('change', () => {
                    state.sortBy = el.sortSelect.value;
                    localStorage.setItem('sort_by', state.sortBy);
                    applyFiltersAndSort();
                    renderFileList();
                });
            }
            if (el.viewToggleBtn) {
                updateFileListViewMode();
                el.viewToggleBtn.addEventListener('click', () => {
                    state.viewMode = state.viewMode === 'list' ? 'grid' : 'list';
                    localStorage.setItem('view_mode', state.viewMode);
                    updateFileListViewMode();
                });
            }

            // 代理设置主弹窗按钮
            el.proxyCancelSettingsBtn.addEventListener('click', closeProxySettingsModal);
            el.proxyGlobalEnableToggle.addEventListener('click', () => { // 修改为图标按钮点击事件
                if (state.proxies.length === 0 || state.activeProxyIndex === -1 || state.proxies[state.activeProxyIndex]?.status === 'fail') {
                    showToast('无可用代理，无法启用。');
                    state.proxyGlobalEnable = false; // 确保关闭
                } else {
                    state.proxyGlobalEnable = !state.proxyGlobalEnable;
                    showToast(state.proxyGlobalEnable ? '代理全局已启用' : '代理全局已禁用');
                }
                localStorage.setItem('proxy_global_enable', JSON.stringify(state.proxyGlobalEnable));
                updateProxySettingsUI(); // 更新代理设置面板的UI
                updateProxyUI(); // 更新主界面的快速开关UI
            });
            el.proxyAddBtn.addEventListener('click', () => openAddEditProxyModal()); // 点击添加按钮打开新弹窗
            el.proxyTestAllBtn.addEventListener('click', testAllProxies);
            el.proxyClearAllBtn.addEventListener('click', showConfirmClearAllProxiesModal); // 修改为调用确认弹窗

            // 代理添加/编辑弹窗按钮
            el.addEditProxyUrlInput.addEventListener('input', validateAddEditProxyInput);
            el.addEditProxyTestBtn.addEventListener('click', testCurrentProxyInModal);
            el.addEditProxySaveBtn.addEventListener('click', saveProxyFromModal);

            // 确认删除代理弹窗按钮
            el.confirmDeleteProxyCancelBtn.addEventListener('click', hideConfirmDeleteProxyModal);

            // 确认清空所有代理弹窗按钮 (新增)
            el.clearAllProxiesCancelBtn.addEventListener('click', hideConfirmClearAllProxiesModal);
            el.clearAllProxiesConfirmBtn.addEventListener('click', clearAllProxiesConfirmed);


            // 重命名弹窗事件
            el.renameInput.oninput = function() {
                el.renameConfirm.disabled = !el.renameInput.value.trim() || el.renameInput.value.trim() === state.selectedFile?.name;
            };
            el.renameCancel.onclick = function() {
                el.renameModal.classList.add('hidden');
            };

            // 删除弹窗事件
            el.deleteCancel.onclick = function() {
                el.deleteModal.classList.add('hidden');
            };

            // 新建仓库弹窗事件
            el.createRepoCancel.onclick = function() {
                el.createRepoModal.classList.add('hidden');
            };

            // 新建文件夹弹窗事件
            el.createFolderInput.oninput = function() {
                el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
            };
            el.createFolderCancel.onclick = function() {
                el.createFolderModal.classList.add('hidden');
            };

            // 新建文件弹窗事件
            el.createFileNameInput.oninput = function() {
                el.createFileConfirm.disabled = !el.createFileNameInput.value.trim() || el.createFileNameInput.value.trim().endsWith('/');
            };
            el.createFileCancel.onclick = function() {
                el.createFileModal.classList.add('hidden');
            };

            // 音频播放器事件监听
            el.closeAudioPlayer.onclick = () => {
                state.audioPlayer.pause();
                state.audioPlayer.src = ''; // 清空src，停止加载
                el.audioPlayer.classList.add('hidden');
                state.isAudioPlaying = false;
                state.currentAudioIndex = -1;
                state.audioPlaylist = [];
                el.playerCurrentSong.textContent = '未播放';
            };
            el.togglePlayPause.onclick = () => {
                if (state.audioPlayer.paused) {
                    if (state.audioPlayer.src) { // 如果有歌曲，直接播放
                        state.audioPlayer.play().catch(e => showToast('播放失败'));
                    } else if (state.audioPlaylist.length > 0 && state.currentAudioIndex === -1) { // 没有歌曲但有列表，且未选择歌曲，播放第一首
                        loadAndPlayAudio(0);
                    }
                } else {
                    state.audioPlayer.pause();
                }
            };
            el.prevAudio.onclick = playPrevAudio;
            el.nextAudio.onclick = playNextAudio;
            el.audioProgress.oninput = () => {
                const seekTime = (el.audioProgress.value / 100) * state.audioPlayer.duration;
                state.audioPlayer.currentTime = seekTime;
            };
        }

        // 编辑器功能
        function showEditModal() {
            el.editModal.classList.remove('hidden');
            el.editModal.classList.add('flex');
            el.editorOverlay.classList.add('show');
            setTimeout(adjustEditorDimensions, 10);
        }

        function hideEditModal() {
            el.editModal.classList.add('hidden');
            el.editModal.classList.remove('flex');
            state.editingFile = state.fileSha = state.originalContent = '';
            el.saveEdit.className = 'save-btn';
        }

        function showEditStatus(text, type) {
            el.editStatus.textContent = text;
            el.editStatus.className = `edit-status ${type}`;
        }

        function adjustEditorDimensions() {
            const viewportHeight = window.innerHeight;
            const targetEditorHeight = viewportHeight * 0.6;
            const modal = el.editModal.querySelector('.modal-content');
            const otherElementsHeight = modal.querySelector('.modal-header').offsetHeight + el.editStatus.offsetHeight + modal.querySelector('.modal-footer').offsetHeight + 30;
            modal.style.height = `${targetEditorHeight + otherElementsHeight}px`;
            el.fileContent.style.height = `${targetEditorHeight}px`;
        }

        async function editFile(file) {
            state.editingFile = file;
            el.editFileName.textContent = `${file.name}`;
            el.fileContent.value = '';
            showEditStatus('', '');
            showEditModal();
            try {
                const [owner, repo] = state.currentRepo.split('/');
                const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${file.path}`, {
                    headers: {
                        'Authorization': `token ${state.token}`,
                        'User-Agent': 'Mozilla/5.0'
                    }
                });
                if (!res.ok) {
                    const err = await res.json();
                    el.editorOverlay.classList.remove('show');
                    showEditStatus(`加载失败：${err.message}`, 'error');
                    return;
                }
                const data = await res.json();
                const content = decodeURIComponent(escape(atob(data.content)));
                el.fileContent.value = content;
                state.originalContent = content;
                state.fileSha = data.sha;
                el.editorOverlay.classList.remove('show');
                el.fileContent.oninput = checkContentChanges;
            } catch (e) {
                el.editorOverlay.classList.remove('show');
                showEditStatus(`错误：${e.message}`, 'error');
                console.error(e);
            }
        }

        function checkContentChanges() {
            const isModified = el.fileContent.value !== state.originalContent;
            el.saveEdit.className = isModified ? 'save-btn modified' : 'save-btn';
        }

        async function saveEditedFile() {
            if (!state.editingFile || !state.fileSha) return;
            const currentContent = el.fileContent.value;
            if (currentContent === state.originalContent) {
                showToast('未检测到修改');
                return;
            }
            el.editorOverlay.classList.add('show');
            try {
                const [owner, repo] = state.currentRepo.split('/');
                const encodedContent = btoa(unescape(encodeURIComponent(currentContent)));
                const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${state.editingFile.path}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${state.token}`,
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0'
                    },
                    body: JSON.stringify({
                        message: `Update ${state.editingFile.name} via web editor`,
                        content: encodedContent,
                        sha: state.fileSha
                    })
                });
                if (!res.ok) {
                    const err = await res.json();
                    el.editorOverlay.classList.remove('show');
                    showEditStatus(`保存失败：${err.message}`, 'error');
                    return;
                }
                const result = await res.json();
                state.fileSha = result.content.sha;
                state.originalContent = currentContent;
                el.editorOverlay.classList.remove('show');
                showToast('文件已保存');
                showSaveNotification();
                fetchFiles(true);
                el.saveEdit.className = 'save-btn';
            } catch (e) {
                el.editorOverlay.classList.remove('show');
                showEditStatus(`错误：${e.message}`, 'error');
                console.error(e);
            }
        }

        // 文件下载/复制/重命名/删除
        async function downloadFile(item) {
            if (item.type === 'dir') return;
            try {
                showToast(`准备下载 ${item.name}`);
                const rawUrl = (item.download_url) ? item.download_url : item.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                const url = getProxiedUrl(rawUrl);
                const response = await fetch(url);
                if (!response.ok) throw new Error(`下载失败 (${response.status})`);
                const blob = await response.blob();
                const objectUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = objectUrl;
                a.download = item.name;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(objectUrl);
                }, 500);
                showToast(`开始下载 ${item.name}`);
            } catch (e) {
                showToast(`下载出错: ${e.message}`);
                console.error(e);
            }
        }

        function copyLink(file) {
            const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            navigator.clipboard.writeText(rawUrl).then(() => {
                showToast('Raw 链接已复制');
            }).catch(e => {
                showToast('复制失败');
                console.error(e);
            });
        }

        function copyProxyLink(file) {
            const raw = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            if (!state.proxyGlobalEnable || state.proxies.length === 0 || state.activeProxyIndex === -1) {
                navigator.clipboard.writeText(raw)
                    .then(() => showToast('未启用代理或无有效代理，已复制直连 Raw'))
                    .catch(() => showToast('复制失败'));
                return;
            }
            const proxyUrl = getProxiedUrl(raw);
            navigator.clipboard.writeText(proxyUrl).then(() => {
                showToast('代理链接已复制');
            }).catch(e => {
                showToast('复制失败');
                console.error(e);
            });
        }

        // 上下文菜单
        function positionContextMenu(e) {
            const rect = e.target.closest('.file-item').getBoundingClientRect();
            const menuWidth = 192,
                windowWidth = window.innerWidth,
                windowHeight = window.innerHeight;
            let leftPos = rect.right + menuWidth + 10 <= windowWidth ? rect.right + 10 : rect.left - menuWidth - 10 >= 0 ? rect.left - menuWidth - 10 : Math.max(10, Math.min(windowWidth - menuWidth - 10, (rect.left + rect.right - menuWidth) / 2));
            let topPos = rect.top;
            const estimatedMenuHeight = 40 * 8; // 估算菜单高度，实际应动态测量或计算
            if (topPos + estimatedMenuHeight > windowHeight) {
                topPos = Math.max(20, windowHeight - estimatedMenuHeight - 40);
            }
            return {
                top: topPos,
                left: leftPos
            };
        }

        function showContextMenu(e, file) {
            state.selectedFile = file;
            const position = positionContextMenu(e);
            const menu = el.contextMenu;
            menu.style.top = `${position.top}px`;
            menu.style.left = `${position.left}px`;
            menu.style.opacity = '0';
            menu.style.transform = 'scale(0.8)';
            menu.classList.remove('hidden');

            let start = null,
                duration = 150;

            function animate(timestamp) {
                if (!start) start = timestamp;
                const progress = Math.min((timestamp - start) / duration, 1);
                menu.style.opacity = progress.toString();
                menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
                if (progress < 1) requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
            renderContextMenuItems(file);
        }

        function showRepoContextMenu(e, repo) {
            state.selectedRepo = repo;
            const position = positionContextMenu(e);
            const menu = el.contextMenu;
            menu.style.top = `${position.top}px`;
            menu.style.left = `${position.left}px`;
            menu.style.opacity = '0';
            menu.style.transform = 'scale(0.8)';
            menu.classList.remove('hidden');

            let start = null,
                duration = 150;

            function animate(timestamp) {
                if (!start) start = timestamp;
                const progress = Math.min((timestamp - start) / duration, 1);
                menu.style.opacity = progress.toString();
                menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
                if (progress < 1) requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
            renderRepoContextMenuItems(repo);
        }

        function renderRepoContextMenuItems(repo) {
            el.contextMenuItems.innerHTML = '';
            [
                ['downloadRepo', 'fa-download', '下载ZIP (代理)'],
                ['renameRepo', 'fa-pencil', '重命名'],
                ['deleteRepo', 'fa-trash', '删除', 'text-red-400']
            ].forEach(([action, icon, text, className = '']) => {
                const item = document.createElement('a');
                item.className = `context-menu-item ${className}`;
                item.dataset.action = action;
                item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
                item.addEventListener('click', () => {
                    handleRepoContextMenuAction(action, state.selectedRepo);
                    hideContextMenu();
                });
                el.contextMenuItems.appendChild(item);
            });
        }

        function renderContextMenuItems(file) {
            el.contextMenuItems.innerHTML = '';
            const isDir = file.type === 'dir';
            const items = isDir ? [
                ['rename', 'fa-pencil', '重命名'],
                ['delete', 'fa-trash', '删除', 'text-red-400']
            ] : [
                ['download', 'fa-download', '下载'],
                ['copyLink', 'fa-link', '复制链接'],
                ['copyProxy', 'fa-share', '代理链接'],
                ['edit', 'fa-edit', '编辑'],
                ['rename', 'fa-pencil', '重命名'],
                ['delete', 'fa-trash', '删除', 'text-red-400']
            ];

            items.forEach(([action, icon, text, className = '']) => {
                const item = document.createElement('a');
                item.className = `context-menu-item ${className}`;
                item.dataset.action = action;
                item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
                item.addEventListener('click', () => {
                    handleContextMenuAction(action, state.selectedFile);
                    hideContextMenu();
                });
                el.contextMenuItems.appendChild(item);
            });
        }

        const hideContextMenu = () => {
            const menu = el.contextMenu;
            if (menu.classList.contains('hidden') && menu.style.display === 'none') return;

            let start = null,
                duration = 150;

            function animate(timestamp) {
                if (!start) start = timestamp;
                const progress = Math.min((timestamp - start) / duration, 1);
                menu.style.opacity = (1 - progress).toString();
                menu.style.transform = `scale(${1 - 0.2 * progress})`;
                if (progress < 1) requestAnimationFrame(animate);
                else {
                    menu.classList.add('hidden');
                    state.selectedFile = null;
                    state.selectedRepo = null;
                }
            }
            requestAnimationFrame(animate);
        };

        function handleContextMenuAction(action, file) {
            switch (action) {
                case 'download':
                    downloadFile(file);
                    break;
                case 'copyLink':
                    copyLink(file);
                    break;
                case 'copyProxy':
                    copyProxyLink(file);
                    break;
                case 'edit':
                    editFile(file);
                    break;
                case 'rename':
                    showRenameModal(file, file.type === 'dir');
                    break;
                case 'delete':
                    showDeleteModal(file, file.type === 'dir');
                    break;
            }
        }

        function handleRepoContextMenuAction(action, repo) {
            switch (action) {
                case 'downloadRepo':
                    downloadRepoAsZip(repo);
                    break;
                case 'renameRepo':
                    showRenameRepoModal(repo);
                    break;
                case 'deleteRepo':
                    showDeleteRepoModal(repo);
                    break;
            }
        }

        function downloadRepoAsZip(repo) {
            const zipRaw = `https://github.com/${repo.full_name}/archive/refs/heads/${repo.default_branch || 'main'}.zip`;
            const zipUrl = getProxiedUrl(zipRaw);
            const a = document.createElement('a');
            a.href = zipUrl;
            a.download = `${repo.name}.zip`;
            a.classList.add('hidden');
            document.body.appendChild(a);
            a.click();
            setTimeout(() => document.body.removeChild(a), 500);
            showToast(`正在下载 ${repo.name}.zip`);
        }

        // 上传功能
        function handleUploadClick() {
            if (!state.currentRepo) {
                showToast('请先选择仓库');
                return;
            }
            el.fileUploadInput.click();
        }

        el.fileUploadInput.addEventListener('change', function(e) {
            const files = Array.from(e.target.files || []);
            if (files.length === 0) return;
            files.forEach((file, index) => uploadSingleFile(file, index));
        });

        function handleFilesSelected(e) {
            const files = Array.from(e.target.files || []);
            if (files.length === 0) return;

            el.uploadPanel.classList.remove('hidden');
            el.uploadItems.innerHTML = '';

            files.forEach((file, index) => {
                let displayName = file.name;
                if (displayName.length > 25) {
                    displayName = displayName.slice(0, 22) + '...';
                }
                const uploadItem = document.createElement('div');
                uploadItem.className = 'upload-item';
                uploadItem.innerHTML = `
                <div class="upload-info">
                    <span class="upload-name" title="${file.name}">${displayName}</span>
                    <span class="upload-size">${formatSize(file.size)}</span>
                </div>
                <div class="upload-progress-container" style="position:relative;">
                    <div class="upload-progress" data-index="${index}"></div>
                    <span class="upload-percent" data-index="${index}">0%</span>
                </div>
                <div class="upload-status" data-index="${index}">等待上传...</div>
            `;
                el.uploadItems.appendChild(uploadItem);
            });

            uploadFilesInSequence(files, 0);
            e.target.value = ''; // 清空input，以便再次选择相同文件
        }

        function uploadFilesInSequence(files, index) {
            if (index >= files.length) {
                setTimeout(() => {
                    el.uploadPanel.classList.add('hidden');
                    fetchFiles(true);
                }, 2000); // 2秒后隐藏上传面板并刷新文件列表
                return;
            }

            const file = files[index];
            const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
            if (statusElement) statusElement.textContent = '准备上传...';

            uploadSingleFile(file, index)
                .then(() => uploadFilesInSequence(files, index + 1))
                .catch(() => uploadFilesInSequence(files, index + 1)); // 即使失败也继续下一个
        }

        async function uploadSingleFile(file, index) {
            return new Promise((resolve, reject) => {
                const progressBar = document.querySelector(`.upload-progress[data-index="${index}"]`);
                const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
                const percentEl = document.querySelector(`.upload-percent[data-index="${index}"]`);

                if (progressBar) progressBar.style.width = '5%';
                if (statusElement) statusElement.textContent = '正在处理文件...';
                if (percentEl) percentEl.textContent = '5%';

                const reader = new FileReader();
                reader.readAsArrayBuffer(file);

                reader.onload = async (e) => {
                    try {
                        if (statusElement) statusElement.textContent = '正在编码内容...';
                        const base64String = arrayBufferToBase64(e.target.result);

                        if (progressBar) progressBar.style.width = '30%';
                        if (percentEl) percentEl.textContent = '30%';

                        if (!state || !state.currentRepo) throw new Error('未选择仓库');

                        const fileName = file.name;
                        const filePath = state.currentPath ? `${state.currentPath}${fileName}` : fileName;
                        const [owner, repo] = state.currentRepo.split('/');

                        if (statusElement) statusElement.textContent = '正在上传...';

                        const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                            method: 'PUT',
                            headers: {
                                'Authorization': `token ${state.token}`,
                                'Content-Type': 'application/json',
                                'User-Agent': 'Mozilla/5.0'
                            },
                            body: JSON.stringify({
                                message: `Upload ${fileName}`,
                                content: base64String
                            }),
                            signal: AbortSignal.timeout(60000) // 60秒超时
                        });

                        if (progressBar) progressBar.style.width = '100%';
                        if (percentEl) percentEl.textContent = '100%';

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            throw new Error(errorData.message || `上传失败: HTTP ${response.status}`);
                        }

                        if (statusElement) {
                            statusElement.textContent = '上传成功';
                            statusElement.className = 'upload-status success';
                        }
                        resolve();
                    } catch (error) {
                        if (statusElement) {
                            statusElement.textContent = '上传失败';
                            statusElement.className = 'upload-status error';
                        }
                        reject(new Error(`上传失败: ${error.message}`));
                    }
                };

                reader.onerror = () => {
                    if (statusElement) {
                        statusElement.textContent = '文件读取失败';
                        statusElement.className = 'upload-status error';
                    }
                    showToast(`无法读取文件: ${file.name}`);
                    reject(new Error('文件读取失败'));
                };
            });
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function showRenameModal(item, isDir) {
            el.renameTitle.querySelector('.modal-title-text').textContent = `重命名${isDir ? '文件夹' : '文件'}: ${item.name}`;
            el.renameInput.value = item.name;
            el.renameWarn.innerHTML = '';
            el.renameModal.classList.remove('hidden');

            el.renameConfirm.disabled = true; // 初始禁用
            el.renameInput.oninput = function() {
                el.renameConfirm.disabled = !el.renameInput.value.trim() || el.renameInput.value.trim() === item.name;
            };

            el.renameConfirm.onclick = async function() {
                const v = el.renameInput.value.trim();
                if (!v || v === item.name) return;

                el.renameConfirm.disabled = true;
                el.renameConfirm.innerHTML = '保存中 <i class="fa fa-spinner fa-spin"></i>';

                try {
                    const [owner, repo] = state.currentRepo.split('/');
                    const oldPath = item.path;
                    const base = oldPath.slice(0, -item.name.length);
                    const newPath = base + v;

                    if (isDir) {
                        // GitHub API 不直接支持文件夹重命名，需要递归移动文件
                        const getAll = async p => {
                            const r = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${p}`, {
                                headers: {
                                    Authorization: `token ${state.token}`
                                }
                            });
                            if (!r.ok) return [];
                            let a = [];
                            for (const i of await r.json()) a.push(...(i.type === 'dir' ? await getAll(i.path) : [i]));
                            return a;
                        };
                        const files = await getAll(oldPath);

                        // 1. 移动所有子文件到新路径
                        for (const f of files) {
                            const to = f.path.replace(oldPath, newPath);
                            const d = await (await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${f.path}`, {
                                headers: {
                                    Authorization: `token ${state.token}`
                                }
                            })).json();
                            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${to}`, {
                                method: 'PUT',
                                headers: {
                                    Authorization: `token ${state.token}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    message: `Move ${f.name} to ${newPath}`,
                                    content: d.content || '',
                                    sha: d.sha
                                })
                            });
                        }

                        // 2. 删除旧路径下的所有文件和文件夹（包括 .gitkeep 文件，如果存在）
                        // 从最深层开始删除，以防止删除父目录时子文件不存在
                        const filesToDelete = [...files].sort((a, b) => b.path.length - a.path.length); // 确保从子文件夹开始删除
                        for (const f of filesToDelete) {
                            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${f.path}`, {
                                method: 'DELETE',
                                headers: {
                                    Authorization: `token ${state.token}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    message: `Delete old file ${f.name}`,
                                    sha: f.sha
                                })
                            });
                        }
                        // 如果原文件夹是空的或只包含 .gitkeep，可能需要额外删除 .gitkeep
                        // 但通常移动文件后，如果文件夹为空会自动消失
                        // 如果只是一个空文件夹，可能直接删除一个 .gitkeep 文件
                        const resOldFolder = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}`, {
                            headers: {
                                Authorization: `token ${state.token}`
                            }
                        });
                        if (resOldFolder.ok) {
                            const oldFolderContent = await resOldFolder.json();
                            if (Array.isArray(oldFolderContent) && oldFolderContent.length > 0) {
                                // 删除 .gitkeep 或其他可能留下的文件
                                for (const f of oldFolderContent) {
                                    if (f.type === 'file') { // 只删除文件，因为文件夹应该在递归移动时处理
                                        await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${f.path}`, {
                                            method: 'DELETE',
                                            headers: {
                                                Authorization: `token ${state.token}`,
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({
                                                message: `Delete old folder stub ${f.name}`,
                                                sha: f.sha
                                            })
                                        });
                                    }
                                }
                            }
                        }

                    } else {
                        const d = await (await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}`, {
                            headers: {
                                Authorization: `token ${state.token}`
                            }
                        })).json();
                        await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${newPath}`, {
                            method: 'PUT',
                            headers: {
                                Authorization: `token ${state.token}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: `Rename to ${v}`,
                                content: d.content,
                                sha: d.sha
                            })
                        });
                        await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}`, {
                            method: 'DELETE',
                            headers: {
                                Authorization: `token ${state.token}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: `Delete old file`,
                                sha: d.sha
                            })
                        });
                    }
                    showToast(`重命名成功: ${v}`);
                    el.renameModal.classList.add('hidden');
                    fetchFiles(true);
                } catch (e) {
                    showToast(`失败: ${e.message}`);
                    el.renameConfirm.disabled = false;
                    el.renameConfirm.innerHTML = '确认';
                }
            };
        }

        //文件夹绑定
        function showCreateFolderModal() {
            el.createFolderInput.value = '';
            el.createFolderModal.classList.remove('hidden');
            el.createFolderConfirm.disabled = true;

            el.createFolderConfirm.onclick = async function() {
                const name = el.createFolderInput.value.trim();
                if (!name) return;

                el.createFolderConfirm.disabled = true;
                el.createFolderConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';

                try {
                    const [owner, repo] = state.currentRepo.split('/');
                    const path = state.currentPath ? `${state.currentPath}${name}` : name;
                    await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}/.gitkeep`, {
                        method: 'PUT',
                        headers: {
                            Authorization: `token ${state.token}`,
                            'Content-Type': 'application/json',
                            'User-Agent': 'Mozilla/5.0'
                        },
                        body: JSON.stringify({
                            message: `create folder ${name}`,
                            content: '' // .gitkeep 文件内容可以为空
                        })
                    });
                    el.createFolderConfirm.disabled = false;
                    el.createFolderConfirm.innerHTML = '确认';
                    showToast(`已创建文件夹: ${name}`);
                    el.createFolderModal.classList.add('hidden');
                    fetchFiles(true);
                } catch (e) {
                    showToast(`失败: ${e.message}`);
                    el.createFolderConfirm.disabled = false;
                    el.createFolderConfirm.innerHTML = '确认';
                }
            };
        }

        // 新建文件
        function showCreateFileModal() {
            if (!state.currentRepo) {
                showToast('请先选择仓库');
                return;
            }
            el.createFileNameInput.value = '';
            el.createFileContentInput.value = '';
            el.createFileModal.classList.remove('hidden');
            el.createFileConfirm.disabled = true;

            el.createFileConfirm.onclick = async function() {
                const name = el.createFileNameInput.value.trim();
                const content = el.createFileContentInput.value;
                if (!name) return;

                el.createFileConfirm.disabled = true;
                el.createFileConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';

                try {
                    const [owner, repo] = state.currentRepo.split('/');
                    const path = state.currentPath ? `${state.currentPath}${name}` : name;
                    const encodedContent = btoa(unescape(encodeURIComponent(content)));
                    const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                        method: 'PUT',
                        headers: {
                            Authorization: `token ${state.token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `create file ${name}`,
                            content: encodedContent
                        })
                    });
                    if (!res.ok) throw new Error('创建失败');
                    showToast(`已创建文件: ${name}`);
                    el.createFileModal.classList.add('hidden');
                    fetchFiles(true);
                } catch (e) {
                    showToast(`失败: ${e.message}`);
                    el.createFileConfirm.disabled = false;
                    el.createFileConfirm.innerHTML = '确认';
                }
            };
        }

        // 重命名仓库
        function showRenameRepoModal(repo) {
            showModal(`
            <div class="modal-form-container">
                <h3><span class="modal-title-text">重命名仓库: ${repo.name}</span><button class="btn-icon-sm" onclick="hideModal()" title="关闭"><i class="fa fa-times"></i></button></h3>
                <input id="newRepoName" value="${repo.name}">
                <textarea id="newRepoDesc">${repo.description || ''}</textarea>
                <div class="modal-buttons">
                    <button id="cancelRenameRepo" class="btn btn-cancel">取消</button>
                    <button id="confirmRenameRepo" class="btn btn-primary" disabled>确认</button>
                </div>
            </div>
        `);
            const nameInput = document.getElementById('newRepoName');
            const descInput = document.getElementById('newRepoDesc');
            const confirmBtn = document.getElementById('confirmRenameRepo');

            const updateButtonState = () => {
                const newName = nameInput.value.trim();
                const newDesc = descInput.value.trim();
                const nameChanged = newName !== repo.name;
                const descChanged = newDesc !== (repo.description || '');
                const isModified = nameChanged || descChanged;
                confirmBtn.disabled = !isModified;
                confirmBtn.classList.toggle('disabled', !isModified);
            };
            nameInput.oninput = updateButtonState;
            descInput.oninput = updateButtonState;

            confirmBtn.onclick = async () => {
                const newName = nameInput.value.trim();
                const newDesc = descInput.value.trim();
                if (newName === repo.name && newDesc === (repo.description || '')) return;

                confirmBtn.disabled = true;
                confirmBtn.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';

                try {
                    const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `token ${state.token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            name: newName,
                            description: newDesc
                        })
                    });
                    if (!res.ok) throw new Error((await res.json()).message || '修改失败');

                    showToast(`保存成功`);
                    hideModal();
                    // 强制刷新仓库列表
                    state.repos = [];
                    el.repoList.innerHTML = '';
                    fetchRepos();
                } catch (e) {
                    showToast(`修改失败: ${e.message}`);
                    confirmBtn.disabled = false;
                    confirmBtn.innerHTML = '确认';
                }
            };
            document.getElementById('cancelRenameRepo').onclick = hideModal;
        }

        // 删除仓库
        function showDeleteRepoModal(repo) {
            showModal(`
            <div class="modal-form-container">
                <h3><span class="modal-title-text">确认删除仓库</span><button class="btn-icon-sm" onclick="hideModal()" title="关闭"><i class="fa fa-times"></i></button></h3>
                <p>确定要删除仓库 "${repo.name}" 吗？此操作不可撤销！</p>
                <div class="modal-buttons">
                    <button id="cancelDeleteRepo" class="btn btn-cancel">取消</button>
                    <button id="confirmDeleteRepo" class="btn btn-danger">确认删除</button>
                </div>
            </div>
        `);
            const confirmBtn = document.getElementById('confirmDeleteRepo');
            confirmBtn.onclick = async () => {
                confirmBtn.disabled = true;
                confirmBtn.innerHTML = '删除中 <i class="fa fa-spinner fa-spin"></i>';

                try {
                    const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `token ${state.token}`
                        }
                    });
                    if (!res.ok) throw new Error((await res.json()).message || '删除失败');
                    showToast(`仓库 "${repo.name}" 已删除`);
                    hideModal();
                    fetchRepos();
                } catch (e) {
                    showToast(`删除失败: ${e.message}`);
                    confirmBtn.disabled = false;
                    confirmBtn.innerHTML = '确认删除';
                }
            };
            document.getElementById('cancelDeleteRepo').onclick = hideModal;
        }

        // 删除文件/文件夹
        function showDeleteModal(item, isDir) {
            el.deleteTitle.querySelector('.modal-title-text').textContent = '确认删除';
            el.deleteDesc.textContent = isDir ?
                `确定要删除文件夹 "${item.name}" 吗？这将删除该文件夹及其所有内容。` :
                `确定要删除文件 "${item.name}" 吗？此操作不可撤销。`;
            el.deleteModal.classList.remove('hidden');

            el.deleteConfirm.onclick = async function() {
                const confirmBtn = this;
                confirmBtn.disabled = true;
                confirmBtn.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';

                const deleteFile = async (path, sha, name) => {
                    const [owner, repo] = state.currentRepo.split('/');
                    const res = await fetch(
                        `https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                            method: 'DELETE',
                            headers: {
                                Authorization: `token ${state.token}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: `Delete ${name}`,
                                sha: sha
                            })
                        }
                    );
                    if (!res.ok) {
                        const errorData = await res.json();
                        if (res.status === 409) {
                            throw new Error(`操作冲突：${errorData.message || '请刷新后重试'}`);
                        } else {
                            throw new Error(errorData.message || `删除失败 (HTTP ${res.status})`);
                        }
                    }
                };

                const getAllFiles = async (path) => {
                    const [owner, repo] = state.currentRepo.split('/');
                    let allFiles = [];
                    let page = 1;
                    let hasMore = true;
                    while (hasMore) {
                        const res = await fetch(
                            `https://api.github.com/repos/${owner}/${repo}/contents/${path}?page=${page}&per_page=100`, {
                                headers: {
                                    Authorization: `token ${state.token}`
                                }
                            }
                        );
                        if (!res.ok) return [];
                        const items = await res.json();
                        if (!Array.isArray(items)) return []; // 404 for empty dir might return an object
                        if (items.message && res.status === 404) return []; // Empty directory
                        for (const i of items) {
                            if (i.type === 'dir') {
                                const subFiles = await getAllFiles(i.path);
                                allFiles = [...allFiles, ...subFiles];
                            } else {
                                allFiles.push(i);
                            }
                        }
                        const linkHeader = res.headers.get('Link');
                        hasMore = linkHeader && linkHeader.includes('rel="next"');
                        page++;
                    }
                    return allFiles;
                };

                try {
                    const targetPath = item.path;
                    const safeName = escapeHtml(item.name);
                    if (isDir) {
                        const allFiles = await getAllFiles(targetPath);
                        for (const f of allFiles) {
                            await deleteFile(f.path, f.sha, f.name);
                        }
                        showToast(`文件夹"${safeName}"已删除`);
                    } else {
                        await deleteFile(targetPath, item.sha, item.name);
                        showToast(`文件"${safeName}"已删除`);
                    }
                    el.deleteModal.classList.add('hidden');
                    fetchFiles(true);
                } catch (error) {
                    showToast(`删除失败: ${error.message}`);
                    confirmBtn.disabled = false;
                    confirmBtn.innerHTML = '确认删除';
                }
            };
        }

        // 返回上级
        function goUp() {
            if (!state.currentRepo) {
                history.pushState(null, '', window.location.href);
                return;
            }
            if (!state.currentPath || state.currentPath === '' || state.currentPath === '/') {
                showRepoListView();
                return;
            }
            let parts = state.currentPath.split('/').filter(Boolean);
            parts.pop();
            state.currentPath = parts.length ? parts.join('/') + '/' : '';
            fetchFiles();
        }

        // 初始化
        function init() {
            if (state.token) {
                showApp();
                loadReposFromCache();
                fetchExternalProxies(); // 新增：在应用启动时获取外部代理
            } else {
                showAuth();
            }
            setupEventListeners();
        }

        document.addEventListener('DOMContentLoaded', init);

        // 使元素可拖拽
        function makeDraggable(element, handle = element) {
            let pos1 = 0,
                pos2 = 0,
                pos3 = 0,
                pos4 = 0;
            let isDragging = false;

            handle.onmousedown = dragMouseDown;
            handle.ontouchstart = dragTouchStart;

            function dragMouseDown(e) {
                // 避免拖拽时触发内部元素点击
                if (e.target.closest('button, input, select, textarea')) return;
                e.preventDefault();
                isDragging = true;
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                element.style.cursor = 'grabbing';
                handle.style.cursor = 'grabbing';
            }

            function dragTouchStart(e) {
                if (e.touches.length !== 1 || e.target.closest('button, input, select, textarea')) return;
                isDragging = true;
                pos3 = e.touches[0].clientX;
                pos4 = e.touches[0].clientY;
                handle.ontouchend = closeDragElement;
                handle.ontouchcancel = closeDragElement;
                handle.ontouchmove = elementDragTouch;
                element.style.cursor = 'grabbing';
                handle.style.cursor = 'grabbing';
            }

            function elementDrag(e) {
                if (!isDragging) return;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;

                // 计算新的位置，并确保元素在视口内
                let newTop = element.offsetTop - pos2;
                let newLeft = element.offsetLeft - pos1;

                // 限制在视口内
                const maxX = window.innerWidth - element.offsetWidth;
                const maxY = window.innerHeight - element.offsetHeight;

                newLeft = Math.max(0, Math.min(newLeft, maxX));
                newTop = Math.max(0, Math.min(newTop, maxY));

                element.style.top = newTop + 'px';
                element.style.left = newLeft + 'px';
            }

            function elementDragTouch(e) {
                if (!isDragging || e.touches.length !== 1) return;
                pos1 = pos3 - e.touches[0].clientX;
                pos2 = pos4 - e.touches[0].clientY;
                pos3 = e.touches[0].clientX;
                pos4 = e.touches[0].clientY;

                let newTop = element.offsetTop - pos2;
                let newLeft = element.offsetLeft - pos1;

                const maxX = window.innerWidth - element.offsetWidth;
                const maxY = window.innerHeight - element.offsetHeight;

                newLeft = Math.max(0, Math.min(newLeft, maxX));
                newTop = Math.max(0, Math.min(newTop, maxY));

                element.style.top = newTop + 'px';
                element.style.left = newLeft + 'px';
            }

            function closeDragElement() {
                isDragging = false;
                document.onmouseup = null;
                document.onmousemove = null;
                handle.ontouchend = null;
                handle.ontouchcancel = null;
                handle.ontouchmove = null;
                element.style.cursor = 'default';
                handle.style.cursor = 'grab';
            }
        }


        // 媒体预览
        function initMediaAndAudioPlayer() {
            const preview = document.getElementById('mediaPreview');
            const img = document.getElementById('mediaPreviewImg');
            const video = document.getElementById('mediaPreviewVideo');

            const imageExts = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'];
            const videoExts = ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'];
            const audioExts = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];

            // 音频管理器，现在包含播放列表逻辑
            state.audioPlayer.crossOrigin = 'anonymous'; // 解决CORS问题
            state.audioPlayer.preload = 'auto'; // 预加载

            // 音频事件监听
            state.audioPlayer.addEventListener('play', () => {
                state.isAudioPlaying = true;
                el.togglePlayPause.innerHTML = '<i class="fa fa-pause"></i>';
                el.audioPlayer.classList.remove('hidden'); // 确保播放器显示
            });
            state.audioPlayer.addEventListener('pause', () => {
                state.isAudioPlaying = false;
                el.togglePlayPause.innerHTML = '<i class="fa fa-play"></i>';
            });
            state.audioPlayer.addEventListener('ended', () => {
                playNextAudio(); // 播放结束后自动播放下一首
            });
            state.audioPlayer.addEventListener('timeupdate', () => {
                const percent = (state.audioPlayer.currentTime / state.audioPlayer.duration) * 100;
                el.audioProgress.value = percent;
                el.currentTime.textContent = formatAudioTime(state.audioPlayer.currentTime);
            });
            state.audioPlayer.addEventListener('loadedmetadata', () => {
                el.totalTime.textContent = formatAudioTime(state.audioPlayer.duration);
                el.audioProgress.value = 0;
            });
            state.audioPlayer.addEventListener('error', (e) => {
                state.isAudioPlaying = false;
                showToast('音频播放出错');
                console.error('Audio error:', e);
                playNextAudio(); // 出错也尝试播放下一首
            });

            // 格式化时间
            function formatAudioTime(seconds) {
                if (isNaN(seconds)) return '0:00';
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.floor(seconds % 60);
                return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
            }

            // 加载并播放指定索引的歌曲
            async function loadAndPlayAudio(index) {
                if (state.audioPlaylist.length === 0) {
                    showToast('当前目录没有可播放的音频文件');
                    el.audioPlayer.classList.add('hidden');
                    return;
                }

                let newIndex = index;
                if (newIndex >= state.audioPlaylist.length) {
                    newIndex = state.audioLooping ? 0 : -1; // 循环或停止
                } else if (newIndex < 0) {
                    newIndex = state.audioLooping ? state.audioPlaylist.length - 1 : -1; // 循环或停止
                }

                if (newIndex === -1) { // 停止播放
                    state.audioPlayer.pause();
                    state.audioPlayer.src = '';
                    state.currentAudioIndex = -1;
                    el.playerCurrentSong.textContent = '播放完毕';
                    el.togglePlayPause.innerHTML = '<i class="fa fa-play"></i>';
                    showToast('播放列表已结束');
                    el.audioPlayer.classList.add('hidden');
                    return;
                }

                state.currentAudioIndex = newIndex;
                const file = state.audioPlaylist[state.currentAudioIndex];
                const rawUrl = file.download_url ? file.download_url : file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                const url = getProxiedUrl(rawUrl);

                el.playerCurrentSong.textContent = file.name.replace(/\.[^/.]+$/, ""); // 显示不带扩展名的文件名
                state.audioPlayer.src = url;
                state.audioPlayer.load(); // 加载歌曲
                // 移除了自动播放，现在由用户点击 el.togglePlayPause 触发 play()
            }

            // 播放下一首
            function playNextAudio() {
                loadAndPlayAudio(state.currentAudioIndex + 1);
            }

            // 播放上一首
            function playPrevAudio() {
                loadAndPlayAudio(state.currentAudioIndex - 1);
            }

            // 图像/视频预览点击逻辑
            preview.onclick = function() {
                preview.classList.add('hidden');
                img.src = '';
                video.src = '';
                img.style.display = 'none';
                video.style.display = 'none';
                video.pause();
            };

            // 文件列表点击事件监听
            document.getElementById('fileList').addEventListener('click', function(e) {
                // 如果点击的是多选框或其他控件，则不触发预览/播放
                if (e.target.classList.contains('multi-select-checkbox') || e.target.closest('.flex.gap-1,button')) {
                    return;
                }

                const item = e.target.closest('.file-item');
                if (!item) return;

                const name = item.querySelector('.file-name') ? item.querySelector('.file-name').textContent : '';
                const ext = name.split('.').pop()?.toLowerCase();
                const file = state.files.find(f => f.name === name);

                if (!file || file.type !== 'file') return;

                const raw = file.download_url ? file.download_url : file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                const url = getProxiedUrl(raw);

                if (audioExts.includes(ext)) {
                    // 构建当前目录的音频播放列表
                    state.audioPlaylist = state.files.filter(f => f.type === 'file' && audioExts.includes(f.name.split('.').pop()?.toLowerCase()));
                    state.audioPlaylist.sort((a, b) => a.name.localeCompare(b.name)); // 按文件名排序

                    const clickedIndex = state.audioPlaylist.findIndex(f => f.name === name);
                    if (clickedIndex !== -1) {
                        loadAndPlayAudio(clickedIndex); // 只加载，不自动播放
                        showToast(`已加载歌曲: ${file.name.replace(/\.[^/.]+$/, "")}`);
                        el.audioPlayer.classList.remove('hidden'); // 显示播放器
                        // 如果当前是暂停状态且加载了新歌，保持暂停状态
                        if (!state.isAudioPlaying) {
                            el.togglePlayPause.innerHTML = '<i class="fa fa-play"></i>';
                        }
                    } else {
                        showToast('无法找到该歌曲在播放列表中的位置。');
                    }
                    e.preventDefault(); // 阻止默认的链接行为
                    e.stopPropagation();
                    return;
                }

                if (imageExts.includes(ext)) {
                    img.src = url;
                    img.style.display = '';
                    video.style.display = 'none';
                    preview.classList.remove('hidden');
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                if (videoExts.includes(ext)) {
                    video.src = url;
                    video.style.display = '';
                    img.style.display = 'none';
                    preview.classList.remove('hidden');
                    e.preventDefault();
                    e.stopPropagation();
                    video.load(); // 加载视频
                    return;
                }
            }, true); // 使用捕获阶段
        }
        document.addEventListener('DOMContentLoaded', initMediaAndAudioPlayer); // 确保在 DOM 加载后初始化


        // 新建仓库功能
        function showCreateRepoModal() {
            el.createRepoNameInput.value = '';
            el.createRepoDescInput.value = '';
            el.createRepoPrivate.checked = true; // 默认公开
            el.repoNameError.style.display = 'none';
            el.createRepoModal.classList.remove('hidden');
            el.createRepoConfirm.disabled = true;

            function validateRepoName(name) {
                const chineseRegex = /[\u4e00-\u9fa5]/;
                if (chineseRegex.test(name)) {
                    return '仓库名称不能包含中文字符';
                }
                const validNameRegex = /^[a-zA-Z0-9._-]+$/;
                if (!validNameRegex.test(name)) {
                    return '仓库名称只能包含英文字母、数字、点号、下划线和连字符';
                }
                if (name.length < 1) {
                    return '仓库名称不能为空';
                }
                if (name.length > 100) {
                    return '仓库名称不能超过100个字符';
                }
                if (name.startsWith('.') || name.endsWith('.')) {
                    return '仓库名称不能以点号开头或结尾';
                }
                return null;
            }

            el.createRepoNameInput.oninput = function() {
                const name = el.createRepoNameInput.value.trim();
                const error = validateRepoName(name);
                if (error) {
                    el.repoNameError.textContent = error;
                    el.repoNameError.style.display = 'block';
                    el.createRepoConfirm.disabled = true;
                } else {
                    el.repoNameError.style.display = 'none';
                    el.createRepoConfirm.disabled = !name;
                }
            };

            el.createRepoConfirm.onclick = async function() {
                const name = el.createRepoNameInput.value.trim();
                const description = el.createRepoDescInput.value.trim();
                const isPrivate = !el.createRepoPrivate.checked; // 注意这里是私有 vs 公开
                const error = validateRepoName(name);
                if (error || !name) return;

                el.createRepoConfirm.disabled = true;
                el.createRepoConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';

                try {
                    const res = await fetch('https://api.github.com/user/repos', {
                        method: 'POST',
                        headers: {
                            'Authorization': `token ${state.token}`,
                            'Content-Type': 'application/json',
                            'User-Agent': 'Mozilla/5.0'
                        },
                        body: JSON.stringify({
                            name: name,
                            description: description || undefined,
                            private: isPrivate,
                            auto_init: true
                        })
                    });

                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(errorData.message || '创建仓库失败');
                    }

                    await res.json();
                    showToast(`仓库 "${name}" 创建成功`);
                    el.createRepoModal.classList.add('hidden');
                    fetchRepos();
                } catch (e) {
                    showToast(`创建失败: ${e.message}`);
                    el.createRepoConfirm.disabled = false;
                    el.createRepoConfirm.innerHTML = '创建仓库';
                }
            };
        }

        document.addEventListener('DOMContentLoaded', function() {
            history.pushState(null, '', location.href);
            window.addEventListener('popstate', function() {
                goUp();
                history.pushState(null, '', location.href);
            });

            // 使代理设置弹窗可拖拽
            const proxyModalContent = el.proxySettingsModal.querySelector('.modal-form-container');
            const proxyModalHandle = el.proxySettingsModal.querySelector('h3');
            if (proxyModalContent && proxyModalHandle) {
                makeDraggable(proxyModalContent, proxyModalHandle);
            }

            // 使音频播放器可拖拽
            if (el.audioPlayer && el.audioPlayerHandle) {
                 makeDraggable(el.audioPlayer, el.audioPlayerHandle);
            }
        });

        // 手势缩放字体大小功能
        (function() {
            const config = {
                minFontSize: 3,
                maxFontSize: 40,
                defaultFontSize: 12,
                storageKey: 'editor-font-size',
                scaleSensitivity: 0.01
            };

            function getSavedFontSize() {
                const saved = localStorage.getItem(config.storageKey);
                return saved ? parseInt(saved) : config.defaultFontSize;
            }

            function saveFontSize(size) {
                localStorage.setItem(config.storageKey, size);
            }

            function createFontSizeDisplay() {
                const display = document.createElement('div');
                display.style.cssText = `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; z-index: 1000; pointer-events: none; opacity: 0; transition: opacity 0.1s;`;
                return display;
            }

            function showFontSizeTooltip(display, size) {
                display.textContent = `${size}px`;
                display.style.opacity = '1';
                clearTimeout(display.hideTimeout);
                display.hideTimeout = setTimeout(() => {
                    display.style.opacity = '0';
                }, 1000);
            }

            function initGestureControls() {
                const observer = new MutationObserver((mutations) => {
                    const editModal = document.getElementById('editModal');
                    const fileContent = document.getElementById('fileContent');
                    const editorContainer = document.querySelector('.editor-container');

                    if (editModal && fileContent && editorContainer && !fileContent.hasGestureControl) {
                        fileContent.hasGestureControl = true; // 标记已初始化，防止重复绑定

                        let currentSize = getSavedFontSize();
                        fileContent.style.fontSize = currentSize + 'px';
                        fileContent.style.lineHeight = (currentSize * 1.5) + 'px';

                        const fontSizeDisplay = createFontSizeDisplay();
                        editorContainer.appendChild(fontSizeDisplay);

                        let initialDistance = 0;
                        let initialFontSize = currentSize;
                        let isPinching = false;

                        function getTouchDistance(touches) {
                            const dx = touches[0].clientX - touches[1].clientX;
                            const dy = touches[0].clientY - touches[1].clientY;
                            return Math.sqrt(dx * dx + dy * dy);
                        }

                        function updateFontSize(size) {
                            size = Math.max(config.minFontSize, Math.min(config.maxFontSize, Math.round(size)));
                            currentSize = size;
                            fileContent.style.fontSize = size + 'px';
                            fileContent.style.lineHeight = (size * 1.5) + 'px';
                            showFontSizeTooltip(fontSizeDisplay, size);
                            saveFontSize(size);
                        }

                        // 触摸事件（双指缩放）
                        fileContent.addEventListener('touchstart', (e) => {
                            if (e.touches.length === 2) {
                                e.preventDefault();
                                isPinching = true;
                                initialDistance = getTouchDistance(e.touches);
                                initialFontSize = currentSize;
                            }
                        }, {
                            passive: false
                        });

                        fileContent.addEventListener('touchmove', (e) => {
                            if (isPinching && e.touches.length === 2) {
                                e.preventDefault();
                                const currentDistance = getTouchDistance(e.touches);
                                const scale = currentDistance / initialDistance;
                                const newSize = initialFontSize * scale;
                                updateFontSize(newSize);
                            }
                        }, {
                            passive: false
                        });

                        fileContent.addEventListener('touchend', (e) => {
                            if (isPinching) {
                                isPinching = false;
                            }
                        });

                        // 滚轮事件（Ctrl + 滚轮缩放）
                        fileContent.addEventListener('wheel', (e) => {
                            if (e.ctrlKey || e.metaKey) { // Ctrl for Windows, Cmd for Mac
                                e.preventDefault();
                                const delta = e.deltaY > 0 ? -1 : 1; // 向上滚是正值
                                const newSize = currentSize + delta;
                                updateFontSize(newSize);
                            }
                        }, {
                            passive: false
                        });

                        // 键盘快捷键 (Ctrl/Cmd + '+', '-', '0')
                        fileContent.addEventListener('keydown', (e) => {
                            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) {
                                e.preventDefault();
                                updateFontSize(currentSize + 1);
                            } else if ((e.ctrlKey || e.metaKey) && e.key === '-') {
                                e.preventDefault();
                                updateFontSize(currentSize - 1);
                            } else if ((e.ctrlKey || e.metaKey) && e.key === '0') {
                                e.preventDefault();
                                updateFontSize(config.defaultFontSize);
                            }
                        });

                        // 监听editModal显示状态，每次显示时恢复字体大小
                        const editModalObserver = new MutationObserver(() => {
                            if (!editModal.classList.contains('hidden')) {
                                currentSize = getSavedFontSize();
                                fileContent.style.fontSize = currentSize + 'px';
                                fileContent.style.lineHeight = (currentSize * 1.5) + 'px';
                            }
                        });
                        editModalObserver.observe(editModal, {
                            attributes: true,
                            attributeFilter: ['class']
                        });

                        // 显示操作提示
                        const helpText = document.createElement('div');
                        helpText.style.cssText = `position: absolute; bottom: 10px; right: 30px; color: white; font-size: 12px; opacity: 0.6; z-index: 100;`;
                        helpText.innerHTML = '双指缩放调整字体 | Ctrl+滚轮缩放';
                        editorContainer.appendChild(helpText);

                        setTimeout(() => {
                            helpText.style.transition = 'opacity 0.6s';
                            helpText.style.opacity = '0';
                            setTimeout(() => helpText.remove(), 500);
                        }, 8000); // 8秒后渐隐并移除
                    }
                });

                // 观察整个body，当editModal被添加到DOM时触发
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initGestureControls);
            } else {
                initGestureControls();
            }
        })();

        // 最大化编辑页
        (function() {
            'use strict';
            const config = {
                buttonId: 'toggleMaximizeModal',
                modalId: 'editModal',
                closeButtonId: 'closeEditModal',
                maximizedClass: 'maximized',
                expandIcon: 'fa-expand',
                compressIcon: 'fa-compress',
                buttonTitle: {
                    maximize: '最大化',
                    restore: '恢复',
                },
            };

            let isMaximized = false;
            let maximizeButton = null;
            let editModal = null;
            let isToggling = false; // 防止快速重复点击
            let modalObserver = null;

            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.error(`进入全屏失败: ${err.message} (${err.name})`);
                    });
                } else {
                    document.exitFullscreen().catch(err => {
                        console.error(`退出全屏失败: ${err.message} (${err.name})`);
                    });
                }
            }

            function createMaximizeButton() {
                const button = document.createElement('button');
                button.id = config.buttonId;
                button.title = config.buttonTitle.maximize;
                button.innerHTML = `<i class="fa ${config.expandIcon}"></i>`;
                return button;
            }

            function toggleMaximize() {
                if (!editModal || !maximizeButton || isToggling) return;
                isToggling = true;
                const icon = maximizeButton.querySelector('i');

                if (isMaximized) {
                    // 恢复
                    editModal.classList.remove(config.maximizedClass);
                    icon.classList.remove(config.compressIcon);
                    icon.classList.add(config.expandIcon);
                    maximizeButton.title = config.buttonTitle.maximize;
                    isMaximized = false;
                    if (document.fullscreenElement) {
                        document.exitFullscreen().catch(err => {
                            console.error(`退出全屏失败: ${err.message}`);
                        });
                    }
                    // 尝试恢复编辑器尺寸
                    try {
                        if (typeof window.adjustEditorDimensions === 'function') {
                            setTimeout(window.adjustEditorDimensions, 100);
                        }
                    } catch (e) {
                        console.error('调整编辑器尺寸时出错：', e);
                    }
                } else {
                    // 最大化
                    editModal.classList.add(config.maximizedClass);
                    icon.classList.remove(config.expandIcon);
                    icon.classList.add(config.compressIcon);
                    maximizeButton.title = config.buttonTitle.restore;
                    isMaximized = true;
                    toggleFullscreen(); // 尝试进入全屏
                }

                try {
                    localStorage.setItem('editor-maximized', isMaximized.toString());
                } catch (e) {
                    console.error('保存最大化状态失败：', e);
                }

                setTimeout(() => {
                    isToggling = false;
                }, 300); // 300ms 冷却时间
            }

            function restoreMaximizedState() {
                if (isToggling) return; // 正在切换中则跳过
                try {
                    const savedState = localStorage.getItem('editor-maximized') === 'true';
                    // 只有当modal显示且保存状态为最大化时才尝试最大化
                    if (savedState && editModal && !editModal.classList.contains('hidden') && !isMaximized) {
                        // isMaximized = false; // 确保是未最大化状态才调用
                        toggleMaximize();
                    }
                } catch (e) {
                    console.error('恢复最大化状态失败：', e);
                }
            }

            function resetMaximizedState() {
                if (isToggling) return; // 正在切换中则跳过
                if (isMaximized) {
                    isMaximized = true; // 假装是最大化状态，然后调用toggleMaximize来恢复
                    toggleMaximize();
                }
            }

            function initializeButton() {
                if (maximizeButton) return; // 已经初始化过则跳过

                if (!editModal) {
                    editModal = document.getElementById(config.modalId);
                    if (!editModal) return; // modal还不存在
                }

                const modalHeader = editModal.querySelector('.modal-header');
                const closeButton = document.getElementById(config.closeButtonId);
                if (!modalHeader || !closeButton) return;

                // 确保按钮容器存在并添加到header
                let buttonContainer = modalHeader.querySelector('div:last-child');
                if (!buttonContainer || buttonContainer.style.display !== 'flex') { // 创建或更新容器
                    buttonContainer = document.createElement('div');
                    buttonContainer.style.cssText = 'display: flex; gap: 0.5rem;';
                    if (closeButton.parentNode === modalHeader) { // 如果closeButton直接是header的子元素，移除它
                        modalHeader.removeChild(closeButton);
                    }
                    buttonContainer.appendChild(closeButton);
                    modalHeader.appendChild(buttonContainer);
                }

                // 获取或创建最大化按钮
                if (document.getElementById(config.buttonId)) {
                    maximizeButton = document.getElementById(config.buttonId);
                } else {
                    maximizeButton = createMaximizeButton();
                    buttonContainer.insertBefore(maximizeButton, closeButton); // 插入到关闭按钮前面
                }

                // 绑定事件
                maximizeButton.removeEventListener('click', toggleMaximize); // 避免重复绑定
                maximizeButton.addEventListener('click', toggleMaximize);

                // 监听modal的显示/隐藏状态
                if (!modalObserver) {
                    modalObserver = new MutationObserver((mutations) => {
                        for (let mutation of mutations) {
                            if (mutation.attributeName === 'class') {
                                if (editModal.classList.contains('hidden')) {
                                    resetMaximizedState(); // 隐藏时恢复初始状态
                                } else {
                                    // 延时执行，确保CSS动画完成
                                    setTimeout(restoreMaximizedState, 100);
                                }
                            }
                        }
                    });
                    modalObserver.observe(editModal, {
                        attributes: true,
                        attributeFilter: ['class'],
                    });
                }
            }

            function init() {
                const observer = new MutationObserver(() => {
                    // 如果按钮或modal不存在，尝试重新初始化
                    if (!maximizeButton || !document.getElementById(config.buttonId) || !document.getElementById(config.modalId)) {
                        initializeButton();
                    }
                });
                // 观察body的子节点变化，当editModal被添加到DOM时触发
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
                initializeButton(); // 首次尝试初始化

                // 全局快捷键 F11 或 Ctrl+Shift+M 切换最大化
                document.addEventListener('keydown', (e) => {
                    if (editModal && !editModal.classList.contains('hidden')) {
                        if (e.key === 'F11' || (e.ctrlKey && e.shiftKey && e.key === 'M')) {
                            e.preventDefault();
                            toggleMaximize();
                        }
                    }
                });
            }

            init();
        })();

        // 代理设置主弹窗控制
        function openProxySettingsModal() {
            // 更新全局启用代理图标状态
            updateProxySettingsUI();
            renderProxyList(); // 渲染代理列表
            el.proxySettingsModal.classList.remove('hidden');
        }

        function closeProxySettingsModal() {
            el.proxySettingsModal.classList.add('hidden');
        }

        // 更新代理设置面板内部的全局启用开关图标状态
        function updateProxySettingsUI() {
            el.proxyGlobalEnableToggle.classList.toggle('active', state.proxyGlobalEnable);
            el.proxyGlobalEnableToggle.title = state.proxyGlobalEnable ? '全局代理已启用' : '全局代理已禁用';
        }

        /**
         * 从外部链接获取代理列表并合并到现有代理中
         */
        async function fetchExternalProxies() {
            const externalProxyListUrl = 'https://raw.githubusercontent.com/rjdsq/rjdsq.github.io/main/proxy/proxy.txt';
            let newProxies = [];
            state.defaultProxyFromExternal = null; // 重置外部默认代理

            try {
                const response = await fetch(externalProxyListUrl, {
                    cache: 'no-store', // 强制不使用缓存
                    signal: AbortSignal.timeout(5000) // 5秒超时
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                const lines = text.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.startsWith('http://') || line.startsWith('https://'));

                if (lines.length > 0) {
                    state.defaultProxyFromExternal = lines[0]; // 第一行为新的默认代理

                    // 添加默认代理
                    newProxies.push({
                        url: state.defaultProxyFromExternal,
                        latency: null,
                        status: null,
                        err: null,
                        isSourceDefault: true
                    });

                    // 添加其余代理，去重
                    const existingUrls = new Set(newProxies.map(p => p.url));
                    for (let i = 1; i < lines.length; i++) {
                        const url = lines[i];
                        if (!existingUrls.has(url)) {
                            newProxies.push({
                                url: url,
                                latency: null,
                                status: null,
                                err: null
                            });
                            existingUrls.add(url);
                        }
                    }

                    // 合并旧的自定义代理（如果它们不在新获取的列表中）
                    const currentCustomProxies = JSON.parse(localStorage.getItem('proxies') || '[]').filter(p => !p.isSourceDefault);
                    currentCustomProxies.forEach(p => {
                        if (!existingUrls.has(p.url)) {
                            newProxies.push(p);
                            existingUrls.add(p.url);
                        }
                    });

                    state.proxies = newProxies;
                    state.activeProxyIndex = 0; // 默认使用第一行为活动代理
                    state.proxyGlobalEnable = true; // 成功获取到代理，启用全局代理
                    showToast(`已从外部加载 ${lines.length} 个代理。`);

                } else {
                    // 文件内容为空或无有效代理
                    state.proxies = [{
                        url: "无可用代理",
                        latency: null,
                        status: "fail",
                        err: "无法获取代理列表",
                        isSourceDefault: true
                    }];
                    state.activeProxyIndex = 0;
                    state.proxyGlobalEnable = false; // 关闭代理
                    showToast('外部代理列表为空或无有效代理，代理功能已关闭。');
                }
            } catch (error) {
                console.warn('获取外部代理失败:', error);
                state.proxies = [{
                    url: "无法获取代理",
                    latency: null,
                    status: "fail",
                    err: "网络或文件错误",
                    isSourceDefault: true
                }];
                state.activeProxyIndex = 0;
                state.proxyGlobalEnable = false; // 获取失败则关闭全局代理
                showToast('无法加载外部代理列表，代理功能已关闭。');
            } finally {
                saveProxyConfig();
                renderProxyList();
                updateProxyUI();
                // 自动测试第一个代理，无论它是什么
                if (state.proxies.length > 0) {
                    testSingleProxy(0);
                }
            }
        }

        /**
         * 测试代理连通性
         * @param {string} urlPrefix 代理前缀
         * @returns {Promise<{ok: boolean, ms: number|null, err: string|null}>}
         */
        async function testProxyConnectivity(urlPrefix) {
            let base = (urlPrefix || '').trim();
            if (!base.startsWith('http://') && !base.startsWith('https://')) {
                base = 'https://' + base; // 默认添加 https
            }
            if (!base.endsWith('/')) base += '/';

            // 使用一个稳定的GitHub Raw文件进行测试
            const testRawUrl = 'https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore';
            const proxiedTestUrl = base + testRawUrl.replace(/^https?:\/\//, ''); // 移除协议头，防止双重协议

            const start = performance.now();
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8秒超时

                const r = await fetch(proxiedTestUrl, {
                    method: 'GET',
                    cache: 'no-store',
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!r.ok) {
                    const errorText = await r.text().catch(() => null); // 尝试获取错误响应体
                    console.error(`Proxy test failed for ${urlPrefix}: HTTP ${r.status}, Body: ${errorText}`);
                    // 统一返回连接失败 (404)
                    return {
                        ok: false,
                        ms: null,
                        err: '连接失败 (404)'
                    };
                }
                await r.text(); // 读取内容确保连接完整
                return {
                    ok: true,
                    ms: Math.round(performance.now() - start),
                    err: null
                };
            } catch (e) {
                let errorMsg = '连接失败 (404)'; // 统一显示为连接失败 (404)
                if (e.name === 'AbortError') {
                    errorMsg = '连接失败 (超时)';
                } else if (e.message.includes('Failed to fetch')) {
                    errorMsg = '连接失败 (网络错误)';
                }
                console.error(`Proxy test exception for ${urlPrefix}: ${e.message}`, e);
                return {
                    ok: false,
                    ms: null,
                    err: errorMsg
                };
            }
        }

        /**
         * 渲染代理列表
         */
        function renderProxyList() {
            el.proxyListContainer.innerHTML = '';
            // 检查是否有除了默认代理以外的代理存在
            const hasUserOrExternalProxies = state.proxies.length > 1;

            if (state.proxies.length === 0 || (state.proxies.length === 1 && state.proxies[0].isSourceDefault && state.proxies[0].status === 'fail')) {
                el.proxyListEmpty.classList.remove('hidden');
                el.proxyTestAllBtn.disabled = true;
                el.proxyClearAllBtn.disabled = true;
                el.proxyTestAllBtn.classList.add('disabled');
                el.proxyClearAllBtn.classList.add('disabled');
            } else {
                el.proxyListEmpty.classList.add('hidden');
                el.proxyTestAllBtn.disabled = false;
                el.proxyClearAllBtn.disabled = false;
                el.proxyTestAllBtn.classList.remove('disabled');
                el.proxyClearAllBtn.classList.remove('disabled');
            }

            state.proxies.forEach((proxy, index) => {
                const proxyItem = document.createElement('div');
                proxyItem.className = `proxy-item ${index === state.activeProxyIndex ? 'active' : ''}`;

                let latencyClass = 'text-gray-400';
                let latencyText = '未测试';
                if (proxy.status === 'testing') {
                    latencyText = '测试中';
                    latencyClass = '';
                } else if (proxy.status === 'ok') {
                    if (proxy.latency <= 500) {
                        latencyClass = 'text-green-500';
                        latencyText = `${proxy.latency} ms (优)`;
                    } else if (proxy.latency <= 2000) {
                        latencyClass = 'text-orange-400';
                        latencyText = `${proxy.latency} ms (中)`;
                    } else {
                        latencyClass = 'text-red-400';
                        latencyText = `${proxy.latency} ms (差)`;
                    }
                } else if (proxy.status === 'fail') {
                    latencyClass = 'text-red-400';
                    latencyText = proxy.err || `连接失败 (404)`;
                }

                // 确定删除按钮的禁用状态：索引为0的默认代理不可删除
                const deleteButtonDisabled = (index === 0) ? 'disabled' : '';

                proxyItem.innerHTML = `
                    <div class="proxy-info">
                        <div class="proxy-url" title="${proxy.url}">${proxy.url}</div>
                        <div class="proxy-latency ${latencyClass}">${latencyText} ${proxy.status === 'testing' ? '<span class="spinner-small"></span>' : ''}</div>
                    </div>
                    <div class="proxy-actions">
                        <button class="btn-icon-sm set-active-btn" data-index="${index}" title="设为活动" ${index === state.activeProxyIndex ? 'disabled' : ''}>
                            <i class="fa fa-check"></i>
                        </button>
                        <button class="btn-icon-sm edit-proxy-btn" data-index="${index}" title="编辑">
                            <i class="fa fa-pencil"></i>
                        </button>
                        <button class="btn-icon-sm delete-proxy-btn danger" data-index="${index}" title="删除" ${deleteButtonDisabled}>
                            <i class="fa fa-trash"></i>
                        </button>
                    </div>
                `;
                el.proxyListContainer.appendChild(proxyItem);
            });

            // 绑定代理列表中的按钮事件
            el.proxyListContainer.querySelectorAll('.set-active-btn').forEach(button => {
                button.onclick = (e) => setActiveProxy(parseInt(e.currentTarget.dataset.index));
            });
            el.proxyListContainer.querySelectorAll('.edit-proxy-btn').forEach(button => {
                button.onclick = (e) => openAddEditProxyModal(parseInt(e.currentTarget.dataset.index));
            });
            el.proxyListContainer.querySelectorAll('.delete-proxy-btn').forEach(button => {
                // 仅为未禁用的按钮绑定事件
                if (!button.disabled) {
                    button.onclick = (e) => showConfirmDeleteProxyModal(parseInt(e.currentTarget.dataset.index));
                }
            });

            saveProxyConfig();
        }

        /**
         * 保存代理配置到 localStorage
         */
        function saveProxyConfig() {
            localStorage.setItem('proxies', JSON.stringify(state.proxies));
            localStorage.setItem('active_proxy_index', JSON.stringify(state.activeProxyIndex));
            localStorage.setItem('proxy_global_enable', JSON.stringify(state.proxyGlobalEnable));
            updateProxyUI(); // 更新主界面的快速开关
        }

        // --- 代理添加/编辑弹窗相关逻辑 ---
        /**
         * 打开添加/编辑代理弹窗
         * @param {number|null} index 如果是编辑，传入代理在数组中的索引；null表示添加新代理
         */
        function openAddEditProxyModal(index = null) {
            state.editingProxyIndex = index;
            state.lastTestResult = null; // 重置上次测试结果
            state.lastTestUrl = null; // 重置上次测试URL

            el.addEditProxyModal.classList.remove('hidden');
            el.addEditProxyUrlInput.value = '';
            el.addEditProxyError.style.display = 'none';
            el.addEditProxyTestResult.textContent = '';
            el.addEditProxyTestResult.className = '';
            el.addEditProxySaveBtn.disabled = true;
            el.addEditProxySaveBtn.innerHTML = '保存'; // Reset text
            el.addEditProxyTestBtn.disabled = false; // Enable test button

            const titleTextSpan = el.addEditProxyTitle.querySelector('.modal-title-text');
            if (index !== null && state.proxies[index]) {
                titleTextSpan.textContent = '编辑代理';
                el.addEditProxyUrlInput.value = state.proxies[index].url;
                // If editing, and URL hasn't been changed from original, allow save without re-testing initially
                if (validateAddEditProxyInput()) {
                    el.addEditProxySaveBtn.disabled = false;
                } else {
                    el.addEditProxySaveBtn.disabled = true; // Still disabled if initial URL is invalid
                }

            } else {
                titleTextSpan.textContent = '添加代理';
            }
        }

        function closeAddEditProxyModal() {
            el.addEditProxyModal.classList.add('hidden');
            state.editingProxyIndex = null;
            state.lastTestResult = null;
            state.lastTestUrl = null;
        }

        function validateAddEditProxyInput() {
            const url = el.addEditProxyUrlInput.value.trim();
            const isValidProtocol = url.startsWith('http://') || url.startsWith('https://');
            const isDuplicate = state.proxies.some((p, idx) => p.url === url && idx !== state.editingProxyIndex);

            el.addEditProxyError.style.display = 'none';
            el.addEditProxySaveBtn.disabled = true; // Default to disabled

            if (!url) {
                return false;
            }
            if (!isValidProtocol) {
                el.addEditProxyError.textContent = 'URL必须以http://或https://开头';
                el.addEditProxyError.style.display = 'block';
                return false;
            }
            if (isDuplicate) {
                el.addEditProxyError.textContent = '该代理URL已存在';
                el.addEditProxyError.style.display = 'block';
                return false;
            }

            // Save button enabled conditions:
            // 1. If it's an existing proxy and the URL hasn't changed.
            // 2. If a test has been performed for the current URL (regardless of success/failure).
            const isOriginalUrl = state.editingProxyIndex !== null && state.proxies[state.editingProxyIndex].url === url;
            const hasBeenTested = state.lastTestUrl === url && state.lastTestResult !== null;

            if (isOriginalUrl || hasBeenTested) {
                el.addEditProxySaveBtn.disabled = false;
            }
            return true; // Input format is valid, but save might be disabled due to test requirement
        }

        async function testCurrentProxyInModal() {
            const url = el.addEditProxyUrlInput.value.trim();
            if (!validateAddEditProxyInput()) { // Validate input format only
                return;
            }

            el.addEditProxyTestBtn.disabled = true;
            el.addEditProxyTestSpinner.classList.remove('hidden');
            el.addEditProxyTestResult.textContent = '测试中...';
            el.addEditProxyTestResult.className = 'text-gray-400';
            el.addEditProxySaveBtn.disabled = true; // Disable save during test

            const result = await testProxyConnectivity(url);

            el.addEditProxyTestSpinner.classList.add('hidden');
            el.addEditProxyTestBtn.disabled = false;

            state.lastTestResult = result; // Store test result
            state.lastTestUrl = url; // Store tested URL

            if (result.ok) {
                let statusText = `${result.ms} ms`;
                let statusClass = 'text-green-500';
                if (result.ms > 2000) {
                    statusText += ' (差)';
                    statusClass = 'text-red-400';
                } else if (result.ms > 500) {
                    statusText += ' (中)';
                    statusClass = 'text-orange-400';
                } else {
                    statusText += ' (优)';
                }
                el.addEditProxyTestResult.textContent = `可用 ✓ ${statusText}`;
                el.addEditProxyTestResult.className = statusClass;
            } else {
                el.addEditProxyTestResult.textContent = result.err; // Directly display the unified error message
                el.addEditProxyTestResult.className = 'text-red-400';
            }
            validateAddEditProxyInput(); // Re-validate to enable save button
        }

        async function saveProxyFromModal() {
            // Only allow saving if the button is enabled by validateAddEditProxyInput
            if (el.addEditProxySaveBtn.disabled) {
                return;
            }

            const url = el.addEditProxyUrlInput.value.trim();
            el.addEditProxySaveBtn.disabled = true;
            el.addEditProxySaveBtn.innerHTML = `保存中 <i class="fa fa-spinner fa-spin"></i>`;

            let proxyObj;
            let newlyAdded = false;

            if (state.editingProxyIndex !== null && state.proxies[state.editingProxyIndex]) {
                // 编辑现有代理
                proxyObj = state.proxies[state.editingProxyIndex];
                proxyObj.url = url;
            } else {
                // 添加新代理
                proxyObj = {
                    url: url,
                    latency: null,
                    status: null,
                    err: null
                };
                // 新增：手动插入的默认在默认代理下一行 (即索引 1)
                state.proxies.splice(1, 0, proxyObj); // 插入到指定位置
                // 调整activeProxyIndex
                if (state.activeProxyIndex >= 1) {
                    state.activeProxyIndex++;
                }
                newlyAdded = true;
            }

            if (state.lastTestUrl === url && state.lastTestResult) {
                proxyObj.latency = state.lastTestResult.ms;
                proxyObj.status = state.lastTestResult.ok ? (state.lastTestResult.ms <= 2000 ? 'ok' : 'warn') : 'fail';
                proxyObj.err = state.lastTestResult.err;
            } else {
                proxyObj.latency = null;
                proxyObj.status = null;
                proxyObj.err = null;
            }


            renderProxyList(); // Update main list
            closeAddEditProxyModal(); // Close edit modal

            // If it was newly added or its status is unknown, run a test in background
            if (newlyAdded || proxyObj.status === null) {
                // Find the index of the newly added/updated proxy to test it
                const indexToTest = state.proxies.findIndex(p => p.url === url);
                if (indexToTest !== -1) {
                    await testSingleProxy(indexToTest); // Re-test to update its final status
                    showToast(newlyAdded ? '代理已添加并测试完成。' : '代理已更新并测试完成。');
                }
            } else {
                showToast(newlyAdded ? '代理已添加。' : '代理已更新。');
            }
        }
        // --- 代理添加/编辑弹窗相关逻辑 END ---


        /**
         * 显示确认删除代理弹窗
         * @param {number} index 要删除的代理索引
         */
        function showConfirmDeleteProxyModal(index) {
            const proxy = state.proxies[index];
            // 阻止删除默认代理
            if (index === 0) {
                showToast('默认代理不可删除！');
                return;
            }

            el.confirmDeleteProxyTitle.querySelector('.modal-title-text').textContent = '确认删除代理';
            el.confirmDeleteProxyMessage.innerHTML = `确定要删除代理 <strong>"${escapeHtml(proxy.url)}"</strong> 吗？此操作不可撤销。`;
            el.confirmDeleteProxyModal.classList.remove('hidden');

            // 移除旧的事件监听，防止多次绑定
            el.confirmDeleteProxyConfirmBtn.onclick = null;
            el.confirmDeleteProxyCancelBtn.onclick = null;

            el.confirmDeleteProxyConfirmBtn.onclick = async () => {
                el.confirmDeleteProxyConfirmBtn.disabled = true;
                el.confirmDeleteProxyConfirmBtn.innerHTML = `删除中 <span class="spinner-small"></span>`;
                try {
                    await deleteProxy(index); // 调用实际删除逻辑
                    hideConfirmDeleteProxyModal();
                } finally {
                    el.confirmDeleteProxyConfirmBtn.disabled = false;
                    el.confirmDeleteProxyConfirmBtn.innerHTML = '确认删除';
                }
            };
            el.confirmDeleteProxyCancelBtn.onclick = hideConfirmDeleteProxyModal;
        }

        /**
         * 隐藏确认删除代理弹窗
         */
        function hideConfirmDeleteProxyModal() {
            el.confirmDeleteProxyModal.classList.add('hidden');
        }

        /**
         * 显示确认清空所有代理弹窗
         */
        function showConfirmClearAllProxiesModal() {
            el.confirmClearAllProxiesModal.classList.remove('hidden');
            // 确保按钮是可点击的，并重置文本
            el.clearAllProxiesConfirmBtn.disabled = false;
            el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
        }
        /**
         * 隐藏确认清空所有代理弹窗
         */
        function hideConfirmClearAllProxiesModal() {
            el.confirmClearAllProxiesModal.classList.add('hidden');
        }
        /**
         * 确认清空所有代理（实际执行清空操作）
         */
        async function clearAllProxiesConfirmed() {
            el.clearAllProxiesConfirmBtn.disabled = true;
            el.clearAllProxiesConfirmBtn.innerHTML = `清空中 <span class="spinner-small"></span>`;
            // 清空除第一个默认代理之外的所有代理，并重新获取外部代理列表
            await fetchExternalProxies(); // 这会重新从外部URL获取，并重新设置state.proxies
            showToast('所有自定义代理已清空，列表已刷新。');
            hideConfirmClearAllProxiesModal();
        }


        /**
         * 删除代理
         * @param {number} index 要删除的代理索引
         */
        async function deleteProxy(index) {
            // 阻止删除默认代理
            if (index === 0) {
                showToast('默认代理不可删除！');
                return;
            }

            state.proxies.splice(index, 1);
            if (state.activeProxyIndex === index) {
                state.activeProxyIndex = state.proxies.length > 0 ? 0 : -1;
            } else if (state.activeProxyIndex > index) {
                state.activeProxyIndex--;
            }
            showToast('代理已删除');
            renderProxyList();
        }

        /**
         * 设置活动代理
         * @param {number} index 要设置为活动代理的索引
         */
        function setActiveProxy(index) {
            if (index < 0 || index >= state.proxies.length) return;
            state.activeProxyIndex = index;
            showToast(`已设置 "${state.proxies[index].url}" 为活动代理`);
            renderProxyList();
        }

        /**
         * 测试单个代理延迟
         * @param {number} index 要测试的代理索引
         */
        async function testSingleProxy(index) {
            if (index < 0 || index >= state.proxies.length) return;

            const proxy = state.proxies[index];
            proxy.status = 'testing';
            proxy.latency = null;
            proxy.err = null;
            renderProxyList(); // 更新UI显示“测试中...”

            const result = await testProxyConnectivity(proxy.url);
            proxy.latency = result.ms;
            proxy.status = result.ok ? (result.ms <= 2000 ? 'ok' : 'warn') : 'fail';
            proxy.err = result.err;
            renderProxyList(); // 更新UI显示测试结果
        }

        /**
         * 测试所有代理延迟
         */
        async function testAllProxies() {
            if (state.proxies.length === 0) {
                showToast('没有代理可供测试');
                return;
            }

            el.proxyTestAllBtn.disabled = true;
            el.proxyTestAllSpinner.classList.remove('hidden');

            // Set all to testing state first
            state.proxies.forEach(proxy => {
                proxy.status = 'testing';
                proxy.latency = null;
                proxy.err = null;
            });
            renderProxyList(); // Update UI to show "testing..." for all

            const testPromises = state.proxies.map(async (proxy, index) => {
                const result = await testProxyConnectivity(proxy.url);
                state.proxies[index].latency = result.ms;
                state.proxies[index].status = result.ok ? (result.ms <= 2000 ? 'ok' : 'warn') : 'fail';
                state.proxies[index].err = result.err;
                renderProxyList(); // Update after each test completes
            });

            await Promise.allSettled(testPromises); // Wait for all tests to finish

            el.proxyTestAllBtn.disabled = false;
            el.proxyTestAllSpinner.classList.add('hidden');
            showToast('所有代理测试完成');
            renderProxyList(); // Final render to ensure all states are correct
        }
    </script>

</body>

</html>